// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/api/cloud/namespace/v1/message.proto

package namespace

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CertificateFilterSpec struct {
	// The common_name in the certificate.
	// Optional, default is empty.
	CommonName string `protobuf:"bytes,1,opt,name=common_name,json=commonName,proto3" json:"common_name,omitempty"`
	// The organization in the certificate.
	// Optional, default is empty.
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
	// The organizational_unit in the certificate.
	// Optional, default is empty.
	OrganizationalUnit string `protobuf:"bytes,3,opt,name=organizational_unit,json=organizationalUnit,proto3" json:"organizational_unit,omitempty"`
	// The subject_alternative_name in the certificate.
	// Optional, default is empty.
	SubjectAlternativeName string `protobuf:"bytes,4,opt,name=subject_alternative_name,json=subjectAlternativeName,proto3" json:"subject_alternative_name,omitempty"`
}

func (m *CertificateFilterSpec) Reset()      { *m = CertificateFilterSpec{} }
func (*CertificateFilterSpec) ProtoMessage() {}
func (*CertificateFilterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{0}
}
func (m *CertificateFilterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateFilterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateFilterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateFilterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateFilterSpec.Merge(m, src)
}
func (m *CertificateFilterSpec) XXX_Size() int {
	return m.Size()
}
func (m *CertificateFilterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateFilterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateFilterSpec proto.InternalMessageInfo

func (m *CertificateFilterSpec) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

func (m *CertificateFilterSpec) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *CertificateFilterSpec) GetOrganizationalUnit() string {
	if m != nil {
		return m.OrganizationalUnit
	}
	return ""
}

func (m *CertificateFilterSpec) GetSubjectAlternativeName() string {
	if m != nil {
		return m.SubjectAlternativeName
	}
	return ""
}

type MtlsAuthSpec struct {
	// The base64 encoded ca cert(s) in PEM format that the clients can use for authentication and authorization.
	// This must only be one value, but the CA can have a chain.
	AcceptedClientCa string `protobuf:"bytes,1,opt,name=accepted_client_ca,json=acceptedClientCa,proto3" json:"accepted_client_ca,omitempty"`
	// Certificate filters which, if specified, only allow connections from client certificates whose distinguished name properties match at least one of the filters.
	// This allows limiting access to specific end-entity certificates.
	// Optional, default is empty.
	CertificateFilters []*CertificateFilterSpec `protobuf:"bytes,2,rep,name=certificate_filters,json=certificateFilters,proto3" json:"certificate_filters,omitempty"`
	// Flag to enable mTLS auth (default: disabled).
	// Note: disabling mTLS auth will cause existing mTLS connections to fail.
	// temporal:versioning:min_version=2024-05-13-00
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *MtlsAuthSpec) Reset()      { *m = MtlsAuthSpec{} }
func (*MtlsAuthSpec) ProtoMessage() {}
func (*MtlsAuthSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{1}
}
func (m *MtlsAuthSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MtlsAuthSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MtlsAuthSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MtlsAuthSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MtlsAuthSpec.Merge(m, src)
}
func (m *MtlsAuthSpec) XXX_Size() int {
	return m.Size()
}
func (m *MtlsAuthSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MtlsAuthSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MtlsAuthSpec proto.InternalMessageInfo

func (m *MtlsAuthSpec) GetAcceptedClientCa() string {
	if m != nil {
		return m.AcceptedClientCa
	}
	return ""
}

func (m *MtlsAuthSpec) GetCertificateFilters() []*CertificateFilterSpec {
	if m != nil {
		return m.CertificateFilters
	}
	return nil
}

func (m *MtlsAuthSpec) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type ApiKeyAuthSpec struct {
	// Flag to enable API key auth (default: disabled).
	// Note: disabling API key auth will cause existing API key connections to fail.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *ApiKeyAuthSpec) Reset()      { *m = ApiKeyAuthSpec{} }
func (*ApiKeyAuthSpec) ProtoMessage() {}
func (*ApiKeyAuthSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{2}
}
func (m *ApiKeyAuthSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiKeyAuthSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiKeyAuthSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiKeyAuthSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiKeyAuthSpec.Merge(m, src)
}
func (m *ApiKeyAuthSpec) XXX_Size() int {
	return m.Size()
}
func (m *ApiKeyAuthSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiKeyAuthSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ApiKeyAuthSpec proto.InternalMessageInfo

func (m *ApiKeyAuthSpec) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type CodecServerSpec struct {
	// The codec server endpoint.
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Whether to pass the user access token with your endpoint.
	PassAccessToken bool `protobuf:"varint,2,opt,name=pass_access_token,json=passAccessToken,proto3" json:"pass_access_token,omitempty"`
	// Whether to include cross-origin credentials.
	IncludeCrossOriginCredentials bool `protobuf:"varint,3,opt,name=include_cross_origin_credentials,json=includeCrossOriginCredentials,proto3" json:"include_cross_origin_credentials,omitempty"`
}

func (m *CodecServerSpec) Reset()      { *m = CodecServerSpec{} }
func (*CodecServerSpec) ProtoMessage() {}
func (*CodecServerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{3}
}
func (m *CodecServerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodecServerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodecServerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodecServerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodecServerSpec.Merge(m, src)
}
func (m *CodecServerSpec) XXX_Size() int {
	return m.Size()
}
func (m *CodecServerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CodecServerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CodecServerSpec proto.InternalMessageInfo

func (m *CodecServerSpec) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *CodecServerSpec) GetPassAccessToken() bool {
	if m != nil {
		return m.PassAccessToken
	}
	return false
}

func (m *CodecServerSpec) GetIncludeCrossOriginCredentials() bool {
	if m != nil {
		return m.IncludeCrossOriginCredentials
	}
	return false
}

type NamespaceSpec struct {
	// The name to use for the namespace.
	// This will create a namespace that's available at '<name>.<account>.github.com/temporalio/tcld/protogen:7233'.
	// The name is immutable. Once set, it cannot be changed.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The ids of the regions where the namespace should be available.
	// Specifying more than one region makes the namespace "global", which is currently a preview only feature with restricted access.
	// Please reach out to Temporal support for more information on global namespaces.
	// When provisioned the global namespace will be active on the first region in the list and passive on the rest.
	// Number of supported regions is 2.
	// The regions is immutable. Once set, it cannot be changed.
	Regions []string `protobuf:"bytes,2,rep,name=regions,proto3" json:"regions,omitempty"`
	// The number of days the workflows data will be retained for.
	// Changes to the retention period may impact your storage costs.
	// Any changes to the retention period will be applied to all new running workflows.
	RetentionDays int32 `protobuf:"varint,3,opt,name=retention_days,json=retentionDays,proto3" json:"retention_days,omitempty"`
	// The mTLS auth configuration for the namespace.
	// If unspecified, mTLS will be disabled.
	MtlsAuth *MtlsAuthSpec `protobuf:"bytes,4,opt,name=mtls_auth,json=mtlsAuth,proto3" json:"mtls_auth,omitempty"`
	// The API key auth configuration for the namespace.
	// If unspecified, API keys will be disabled.
	// temporal:versioning:min_version=2024-05-13-00
	ApiKeyAuth *ApiKeyAuthSpec `protobuf:"bytes,7,opt,name=api_key_auth,json=apiKeyAuth,proto3" json:"api_key_auth,omitempty"`
	// The custom search attributes to use for the namespace.
	// The name of the attribute is the key and the type is the value.
	// Supported attribute types: text, keyword, int, double, bool, datetime, keyword_list.
	// NOTE: currently deleting a search attribute is not supported.
	// Optional, default is empty.
	CustomSearchAttributes map[string]string `protobuf:"bytes,5,rep,name=custom_search_attributes,json=customSearchAttributes,proto3" json:"custom_search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Codec server spec used by UI to decode payloads for all users interacting with this namespace.
	// Optional, default is unset.
	CodecServer *CodecServerSpec `protobuf:"bytes,6,opt,name=codec_server,json=codecServer,proto3" json:"codec_server,omitempty"`
}

func (m *NamespaceSpec) Reset()      { *m = NamespaceSpec{} }
func (*NamespaceSpec) ProtoMessage() {}
func (*NamespaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{4}
}
func (m *NamespaceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceSpec.Merge(m, src)
}
func (m *NamespaceSpec) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceSpec proto.InternalMessageInfo

func (m *NamespaceSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamespaceSpec) GetRegions() []string {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *NamespaceSpec) GetRetentionDays() int32 {
	if m != nil {
		return m.RetentionDays
	}
	return 0
}

func (m *NamespaceSpec) GetMtlsAuth() *MtlsAuthSpec {
	if m != nil {
		return m.MtlsAuth
	}
	return nil
}

func (m *NamespaceSpec) GetApiKeyAuth() *ApiKeyAuthSpec {
	if m != nil {
		return m.ApiKeyAuth
	}
	return nil
}

func (m *NamespaceSpec) GetCustomSearchAttributes() map[string]string {
	if m != nil {
		return m.CustomSearchAttributes
	}
	return nil
}

func (m *NamespaceSpec) GetCodecServer() *CodecServerSpec {
	if m != nil {
		return m.CodecServer
	}
	return nil
}

type Endpoints struct {
	// The web UI address.
	WebAddress string `protobuf:"bytes,1,opt,name=web_address,json=webAddress,proto3" json:"web_address,omitempty"`
	// The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
	MtlsGrpcAddress string `protobuf:"bytes,2,opt,name=mtls_grpc_address,json=mtlsGrpcAddress,proto3" json:"mtls_grpc_address,omitempty"`
	// The gRPC address for API key client connections (may be empty if API keys are disabled).
	GrpcAddress string `protobuf:"bytes,3,opt,name=grpc_address,json=grpcAddress,proto3" json:"grpc_address,omitempty"`
}

func (m *Endpoints) Reset()      { *m = Endpoints{} }
func (*Endpoints) ProtoMessage() {}
func (*Endpoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{5}
}
func (m *Endpoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoints.Merge(m, src)
}
func (m *Endpoints) XXX_Size() int {
	return m.Size()
}
func (m *Endpoints) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoints.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoints proto.InternalMessageInfo

func (m *Endpoints) GetWebAddress() string {
	if m != nil {
		return m.WebAddress
	}
	return ""
}

func (m *Endpoints) GetMtlsGrpcAddress() string {
	if m != nil {
		return m.MtlsGrpcAddress
	}
	return ""
}

func (m *Endpoints) GetGrpcAddress() string {
	if m != nil {
		return m.GrpcAddress
	}
	return ""
}

type Limits struct {
	// The number of actions per second (APS) that is currently allowed for the namespace.
	// The namespace may be throttled if its APS exceeds the limit.
	ActionsPerSecondLimit int32 `protobuf:"varint,1,opt,name=actions_per_second_limit,json=actionsPerSecondLimit,proto3" json:"actions_per_second_limit,omitempty"`
}

func (m *Limits) Reset()      { *m = Limits{} }
func (*Limits) ProtoMessage() {}
func (*Limits) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{6}
}
func (m *Limits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limits.Merge(m, src)
}
func (m *Limits) XXX_Size() int {
	return m.Size()
}
func (m *Limits) XXX_DiscardUnknown() {
	xxx_messageInfo_Limits.DiscardUnknown(m)
}

var xxx_messageInfo_Limits proto.InternalMessageInfo

func (m *Limits) GetActionsPerSecondLimit() int32 {
	if m != nil {
		return m.ActionsPerSecondLimit
	}
	return 0
}

type AWSPrivateLinkInfo struct {
	// The list of principal arns that are allowed to access the namespace on the private link.
	AllowedPrincipalArns []string `protobuf:"bytes,1,rep,name=allowed_principal_arns,json=allowedPrincipalArns,proto3" json:"allowed_principal_arns,omitempty"`
	// The list of vpc endpoint service names that are associated with the namespace.
	VpcEndpointServiceNames []string `protobuf:"bytes,2,rep,name=vpc_endpoint_service_names,json=vpcEndpointServiceNames,proto3" json:"vpc_endpoint_service_names,omitempty"`
}

func (m *AWSPrivateLinkInfo) Reset()      { *m = AWSPrivateLinkInfo{} }
func (*AWSPrivateLinkInfo) ProtoMessage() {}
func (*AWSPrivateLinkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{7}
}
func (m *AWSPrivateLinkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSPrivateLinkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSPrivateLinkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSPrivateLinkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSPrivateLinkInfo.Merge(m, src)
}
func (m *AWSPrivateLinkInfo) XXX_Size() int {
	return m.Size()
}
func (m *AWSPrivateLinkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSPrivateLinkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AWSPrivateLinkInfo proto.InternalMessageInfo

func (m *AWSPrivateLinkInfo) GetAllowedPrincipalArns() []string {
	if m != nil {
		return m.AllowedPrincipalArns
	}
	return nil
}

func (m *AWSPrivateLinkInfo) GetVpcEndpointServiceNames() []string {
	if m != nil {
		return m.VpcEndpointServiceNames
	}
	return nil
}

type PrivateConnectivity struct {
	// The id of the region where the private connectivity applies.
	Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// The AWS PrivateLink info.
	// This will only be set for an aws region.
	AwsPrivateLink *AWSPrivateLinkInfo `protobuf:"bytes,2,opt,name=aws_private_link,json=awsPrivateLink,proto3" json:"aws_private_link,omitempty"`
}

func (m *PrivateConnectivity) Reset()      { *m = PrivateConnectivity{} }
func (*PrivateConnectivity) ProtoMessage() {}
func (*PrivateConnectivity) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{8}
}
func (m *PrivateConnectivity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrivateConnectivity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrivateConnectivity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrivateConnectivity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivateConnectivity.Merge(m, src)
}
func (m *PrivateConnectivity) XXX_Size() int {
	return m.Size()
}
func (m *PrivateConnectivity) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivateConnectivity.DiscardUnknown(m)
}

var xxx_messageInfo_PrivateConnectivity proto.InternalMessageInfo

func (m *PrivateConnectivity) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *PrivateConnectivity) GetAwsPrivateLink() *AWSPrivateLinkInfo {
	if m != nil {
		return m.AwsPrivateLink
	}
	return nil
}

type Namespace struct {
	// The namespace identifier.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// The current version of the namespace specification.
	// The next update operation will have to include this version.
	ResourceVersion string `protobuf:"bytes,2,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// The namespace specification.
	Spec *NamespaceSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	// The current state of the namespace.
	// Possible values: activating, activationfailed, active, updating, updatefailed, deleting, deletefailed, deleted, suspending, suspendfailed, suspended.
	// For any failed state, reach out to Temporal Cloud support for remediation.
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	// The id of the async operation that is creating/updating/deleting the namespace, if any.
	AsyncOperationId string `protobuf:"bytes,5,opt,name=async_operation_id,json=asyncOperationId,proto3" json:"async_operation_id,omitempty"`
	// The endpoints for the namespace.
	Endpoints *Endpoints `protobuf:"bytes,6,opt,name=endpoints,proto3" json:"endpoints,omitempty"`
	// The currently active region for the namespace.
	ActiveRegion string `protobuf:"bytes,7,opt,name=active_region,json=activeRegion,proto3" json:"active_region,omitempty"`
	// The limits set on the namespace currently.
	Limits *Limits `protobuf:"bytes,8,opt,name=limits,proto3" json:"limits,omitempty"`
	// The private connectivities for the namespace, if any.
	PrivateConnectivities []*PrivateConnectivity `protobuf:"bytes,9,rep,name=private_connectivities,json=privateConnectivities,proto3" json:"private_connectivities,omitempty"`
	// The date and time when the namespace was created.
	CreatedTime *types.Timestamp `protobuf:"bytes,10,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// The date and time when the namespace was last modified.
	// Will not be set if the namespace has never been modified.
	LastModifiedTime *types.Timestamp `protobuf:"bytes,11,opt,name=last_modified_time,json=lastModifiedTime,proto3" json:"last_modified_time,omitempty"`
	// The status of each region where the namespace is available.
	// The id of the region is the key and the status is the value of the map.
	RegionStatus map[string]*NamespaceRegionStatus `protobuf:"bytes,12,rep,name=region_status,json=regionStatus,proto3" json:"region_status,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Namespace) Reset()      { *m = Namespace{} }
func (*Namespace) ProtoMessage() {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{9}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Namespace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

func (m *Namespace) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Namespace) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *Namespace) GetSpec() *NamespaceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Namespace) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Namespace) GetAsyncOperationId() string {
	if m != nil {
		return m.AsyncOperationId
	}
	return ""
}

func (m *Namespace) GetEndpoints() *Endpoints {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *Namespace) GetActiveRegion() string {
	if m != nil {
		return m.ActiveRegion
	}
	return ""
}

func (m *Namespace) GetLimits() *Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Namespace) GetPrivateConnectivities() []*PrivateConnectivity {
	if m != nil {
		return m.PrivateConnectivities
	}
	return nil
}

func (m *Namespace) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *Namespace) GetLastModifiedTime() *types.Timestamp {
	if m != nil {
		return m.LastModifiedTime
	}
	return nil
}

func (m *Namespace) GetRegionStatus() map[string]*NamespaceRegionStatus {
	if m != nil {
		return m.RegionStatus
	}
	return nil
}

type NamespaceRegionStatus struct {
	// The current state of the namespace region.
	// Possible values: adding, active, passive, removing, failed.
	// For any failed state, reach out to Temporal Cloud support for remediation.
	State string `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	// The id of the async operation that is making changes to where the namespace is available, if any.
	AsyncOperationId string `protobuf:"bytes,2,opt,name=async_operation_id,json=asyncOperationId,proto3" json:"async_operation_id,omitempty"`
}

func (m *NamespaceRegionStatus) Reset()      { *m = NamespaceRegionStatus{} }
func (*NamespaceRegionStatus) ProtoMessage() {}
func (*NamespaceRegionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{10}
}
func (m *NamespaceRegionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceRegionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceRegionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceRegionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceRegionStatus.Merge(m, src)
}
func (m *NamespaceRegionStatus) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceRegionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceRegionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceRegionStatus proto.InternalMessageInfo

func (m *NamespaceRegionStatus) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *NamespaceRegionStatus) GetAsyncOperationId() string {
	if m != nil {
		return m.AsyncOperationId
	}
	return ""
}

func init() {
	proto.RegisterType((*CertificateFilterSpec)(nil), "temporal.api.cloud.namespace.v1.CertificateFilterSpec")
	proto.RegisterType((*MtlsAuthSpec)(nil), "temporal.api.cloud.namespace.v1.MtlsAuthSpec")
	proto.RegisterType((*ApiKeyAuthSpec)(nil), "temporal.api.cloud.namespace.v1.ApiKeyAuthSpec")
	proto.RegisterType((*CodecServerSpec)(nil), "temporal.api.cloud.namespace.v1.CodecServerSpec")
	proto.RegisterType((*NamespaceSpec)(nil), "temporal.api.cloud.namespace.v1.NamespaceSpec")
	proto.RegisterMapType((map[string]string)(nil), "temporal.api.cloud.namespace.v1.NamespaceSpec.CustomSearchAttributesEntry")
	proto.RegisterType((*Endpoints)(nil), "temporal.api.cloud.namespace.v1.Endpoints")
	proto.RegisterType((*Limits)(nil), "temporal.api.cloud.namespace.v1.Limits")
	proto.RegisterType((*AWSPrivateLinkInfo)(nil), "temporal.api.cloud.namespace.v1.AWSPrivateLinkInfo")
	proto.RegisterType((*PrivateConnectivity)(nil), "temporal.api.cloud.namespace.v1.PrivateConnectivity")
	proto.RegisterType((*Namespace)(nil), "temporal.api.cloud.namespace.v1.Namespace")
	proto.RegisterMapType((map[string]*NamespaceRegionStatus)(nil), "temporal.api.cloud.namespace.v1.Namespace.RegionStatusEntry")
	proto.RegisterType((*NamespaceRegionStatus)(nil), "temporal.api.cloud.namespace.v1.NamespaceRegionStatus")
}

func init() {
	proto.RegisterFile("temporal/api/cloud/namespace/v1/message.proto", fileDescriptor_4ea8dce281a9b52e)
}

var fileDescriptor_4ea8dce281a9b52e = []byte{
	// 1224 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4b, 0x6f, 0x1c, 0xc5,
	0x13, 0xf7, 0x38, 0xb6, 0xe3, 0xad, 0x5d, 0xc7, 0x4e, 0x27, 0xf6, 0x7f, 0xe4, 0x3f, 0x6c, 0xc2,
	0x22, 0x44, 0x88, 0xc8, 0x2e, 0x71, 0x22, 0x88, 0x08, 0x08, 0x6d, 0x96, 0x90, 0x07, 0x79, 0x31,
	0x1b, 0x40, 0x02, 0xa1, 0x56, 0xbb, 0xa7, 0xbc, 0x69, 0x3c, 0xd3, 0x3d, 0xea, 0xee, 0x5d, 0x6b,
	0xe1, 0xc2, 0x01, 0x89, 0x0b, 0x07, 0x3e, 0x03, 0x27, 0xc4, 0x97, 0xe0, 0x08, 0xc7, 0x1c, 0x73,
	0x42, 0x64, 0x73, 0xe1, 0x98, 0x8f, 0x80, 0xba, 0x67, 0x66, 0x1f, 0xc4, 0xb0, 0xe1, 0x36, 0x55,
	0xf5, 0xab, 0x9a, 0x7a, 0xfc, 0xba, 0xba, 0xe1, 0x9c, 0xc5, 0x34, 0x53, 0x9a, 0x25, 0x2d, 0x96,
	0x89, 0x16, 0x4f, 0x54, 0x3f, 0x6e, 0x49, 0x96, 0xa2, 0xc9, 0x18, 0xc7, 0xd6, 0xe0, 0x7c, 0x2b,
	0x45, 0x63, 0x58, 0x0f, 0x9b, 0x99, 0x56, 0x56, 0x91, 0x53, 0x25, 0xbc, 0xc9, 0x32, 0xd1, 0xf4,
	0xf0, 0xe6, 0x18, 0xde, 0x1c, 0x9c, 0xdf, 0x3e, 0xd5, 0x53, 0xaa, 0x97, 0x60, 0xcb, 0xc3, 0x77,
	0xfb, 0x7b, 0x2d, 0x2b, 0x52, 0x34, 0x96, 0xa5, 0x59, 0x1e, 0xa1, 0xf1, 0x6b, 0x00, 0x9b, 0x1d,
	0xd4, 0x56, 0xec, 0x09, 0xce, 0x2c, 0x7e, 0x20, 0x12, 0x8b, 0xba, 0x9b, 0x21, 0x27, 0xa7, 0xa0,
	0xca, 0x55, 0x9a, 0x2a, 0x49, 0x5d, 0xc4, 0x30, 0x38, 0x1d, 0x9c, 0xa9, 0x44, 0x90, 0xab, 0xee,
	0xb0, 0x14, 0x49, 0x03, 0x6a, 0x4a, 0xf7, 0x98, 0x14, 0x5f, 0x31, 0x2b, 0x94, 0x0c, 0x17, 0x3d,
	0x62, 0x46, 0x47, 0x5a, 0x70, 0x62, 0x5a, 0x66, 0x09, 0xed, 0x4b, 0x61, 0xc3, 0x23, 0x1e, 0x4a,
	0x66, 0x4d, 0x1f, 0x4b, 0x61, 0xc9, 0x25, 0x08, 0x4d, 0x7f, 0xf7, 0x4b, 0xe4, 0x96, 0x32, 0x97,
	0x8a, 0x64, 0x56, 0x0c, 0x30, 0x4f, 0x61, 0xc9, 0x7b, 0x6d, 0x15, 0xf6, 0xf6, 0xc4, 0xec, 0xd2,
	0x69, 0xfc, 0x12, 0x40, 0xed, 0xb6, 0x4d, 0x4c, 0xbb, 0x6f, 0x1f, 0xf8, 0x02, 0x5e, 0x07, 0xc2,
	0x38, 0xc7, 0xcc, 0x62, 0x4c, 0x79, 0x22, 0x50, 0x5a, 0xca, 0x59, 0x51, 0xc7, 0x46, 0x69, 0xe9,
	0x78, 0x43, 0x87, 0x91, 0x1e, 0x9c, 0xe0, 0x93, 0x3e, 0xd0, 0x3d, 0xdf, 0x08, 0x13, 0x2e, 0x9e,
	0x3e, 0x72, 0xa6, 0xba, 0xf3, 0x66, 0x73, 0x4e, 0xa3, 0x9b, 0x87, 0xf6, 0x30, 0x22, 0xfc, 0xef,
	0x6a, 0x43, 0x42, 0x38, 0x8a, 0x92, 0xed, 0x26, 0x18, 0xfb, 0x36, 0xac, 0x46, 0xa5, 0xd8, 0x38,
	0x0b, 0xc7, 0xda, 0x99, 0xf8, 0x10, 0x87, 0xe3, 0x12, 0xa6, 0xb0, 0xc1, 0x2c, 0xf6, 0xc7, 0x00,
	0xd6, 0x3b, 0x2a, 0x46, 0xde, 0x45, 0x3d, 0x28, 0x26, 0xb6, 0x0d, 0xab, 0x28, 0xe3, 0x4c, 0x09,
	0x69, 0x8b, 0x32, 0xc7, 0x32, 0x39, 0x0b, 0xc7, 0x33, 0x66, 0x0c, 0x75, 0x75, 0x1b, 0x43, 0xad,
	0xda, 0xc7, 0x7c, 0x62, 0xab, 0xd1, 0xba, 0x33, 0xb4, 0xbd, 0xfe, 0xbe, 0x53, 0x93, 0x6b, 0x70,
	0x5a, 0x48, 0x9e, 0xf4, 0x63, 0xa4, 0x5c, 0x2b, 0x63, 0xa8, 0xd2, 0xa2, 0x27, 0x24, 0xe5, 0x1a,
	0x63, 0x94, 0x56, 0xb0, 0xc4, 0x14, 0xa9, 0xbf, 0x58, 0xe0, 0x3a, 0x0e, 0x76, 0xd7, 0xa3, 0x3a,
	0x13, 0x50, 0xe3, 0xe7, 0x25, 0x58, 0xbb, 0x53, 0x76, 0xc9, 0xa7, 0x48, 0x60, 0x69, 0x8a, 0x4d,
	0xfe, 0xdb, 0x15, 0xa9, 0xb1, 0x27, 0x94, 0xcc, 0xbb, 0x5d, 0x89, 0x4a, 0x91, 0xbc, 0x02, 0xc7,
	0x34, 0x5a, 0x17, 0x4d, 0x49, 0x1a, 0xb3, 0x61, 0xfe, 0xdb, 0xe5, 0x68, 0x6d, 0xac, 0x7d, 0x9f,
	0x0d, 0x0d, 0xb9, 0x09, 0x95, 0xd4, 0x26, 0x86, 0xb2, 0xbe, 0x7d, 0xe0, 0x49, 0x52, 0xdd, 0x39,
	0x37, 0x77, 0x60, 0xd3, 0x54, 0x89, 0x56, 0xd3, 0x42, 0x22, 0x1f, 0x41, 0x8d, 0x65, 0x82, 0xee,
	0xe3, 0x30, 0x0f, 0x77, 0xd4, 0x87, 0x6b, 0xcd, 0x0d, 0x37, 0x3b, 0xb8, 0x08, 0xd8, 0x58, 0x26,
	0xdf, 0x06, 0x10, 0xf2, 0xbe, 0xb1, 0x2a, 0xa5, 0x06, 0x99, 0xe6, 0x0f, 0x28, 0xb3, 0x56, 0x8b,
	0xdd, 0xbe, 0x45, 0x13, 0x2e, 0x7b, 0x7e, 0xdd, 0x9c, 0x1b, 0x7f, 0xa6, 0x8d, 0xcd, 0x8e, 0x0f,
	0xd7, 0xf5, 0xd1, 0xda, 0xe3, 0x60, 0x57, 0xa5, 0xd5, 0xc3, 0x68, 0x8b, 0x1f, 0x6a, 0x24, 0x5d,
	0xa8, 0x71, 0x47, 0x18, 0x6a, 0x3c, 0x63, 0xc2, 0x15, 0x5f, 0xd9, 0x1b, 0xf3, 0x99, 0x3d, 0xcb,
	0xb2, 0xa8, 0xca, 0x27, 0x8a, 0xed, 0x1b, 0xf0, 0xff, 0x7f, 0xc9, 0x85, 0x6c, 0xc0, 0x91, 0x7d,
	0x1c, 0x16, 0xd3, 0x76, 0x9f, 0xe4, 0x24, 0x2c, 0x0f, 0x58, 0xd2, 0xc7, 0x62, 0x5b, 0xe4, 0xc2,
	0xdb, 0x8b, 0x97, 0x82, 0xc6, 0xd7, 0x50, 0xb9, 0x5a, 0xb0, 0xd5, 0xb8, 0xe5, 0x73, 0x80, 0xbb,
	0x94, 0xc5, 0xb1, 0x46, 0x63, 0xca, 0xe5, 0x73, 0x80, 0xbb, 0xed, 0x5c, 0xe3, 0xf8, 0xec, 0x67,
	0xde, 0xd3, 0x19, 0x1f, 0xc3, 0xf2, 0x98, 0xeb, 0xce, 0x70, 0x4d, 0x67, 0xbc, 0xc4, 0xbe, 0x04,
	0xb5, 0x19, 0x58, 0xbe, 0x7d, 0xaa, 0xbd, 0x09, 0xa4, 0xd1, 0x86, 0x95, 0x5b, 0x22, 0x15, 0xd6,
	0x90, 0xb7, 0x20, 0x64, 0xdc, 0x51, 0xcb, 0xd0, 0x0c, 0x35, 0x35, 0xc8, 0x95, 0x8c, 0x69, 0xe2,
	0x8c, 0x3e, 0x8d, 0xe5, 0x68, 0xb3, 0xb0, 0xdf, 0x43, 0xdd, 0xf5, 0x56, 0xef, 0xd9, 0xf8, 0x2e,
	0x00, 0xd2, 0xfe, 0xb4, 0x7b, 0x4f, 0x8b, 0x01, 0xb3, 0x78, 0x4b, 0xc8, 0xfd, 0x1b, 0x72, 0x4f,
	0x91, 0x8b, 0xb0, 0xc5, 0x92, 0x44, 0x1d, 0x60, 0x4c, 0x33, 0x2d, 0x24, 0x17, 0x19, 0x4b, 0x28,
	0xd3, 0xd2, 0x15, 0xe5, 0xc8, 0x7e, 0xb2, 0xb0, 0xde, 0x2b, 0x8d, 0x6d, 0x2d, 0x0d, 0xb9, 0x0c,
	0xdb, 0x83, 0x8c, 0xd3, 0xf2, 0xf8, 0xfa, 0x99, 0x09, 0x9e, 0xef, 0xc1, 0xf2, 0x98, 0xfc, 0x6f,
	0x90, 0xf1, 0xb2, 0x63, 0xdd, 0xdc, 0xee, 0x59, 0xd2, 0xf8, 0x3e, 0x80, 0x13, 0x45, 0x1a, 0x1d,
	0x25, 0x25, 0x72, 0x2b, 0x06, 0xc2, 0x0e, 0xc9, 0x16, 0xac, 0xe4, 0x27, 0xab, 0xe8, 0x67, 0x21,
	0x91, 0x2f, 0x60, 0x83, 0x1d, 0x18, 0x97, 0x9e, 0x73, 0xa1, 0x89, 0x90, 0xfb, 0xbe, 0x95, 0xd5,
	0x9d, 0x0b, 0xf3, 0x79, 0xff, 0x4c, 0xc5, 0xd1, 0x31, 0x76, 0x60, 0xa6, 0x74, 0x8d, 0xdf, 0x57,
	0xa0, 0x32, 0xa6, 0x2f, 0x79, 0x01, 0x2a, 0xe3, 0x00, 0x45, 0x1e, 0x13, 0x05, 0x79, 0x0d, 0x36,
	0x34, 0x1a, 0xd5, 0xd7, 0x1c, 0xe9, 0x00, 0xb5, 0x99, 0xdc, 0x2b, 0xeb, 0xa5, 0xfe, 0x93, 0x5c,
	0x4d, 0xae, 0xc0, 0x92, 0xc9, 0x90, 0xfb, 0x69, 0x56, 0x77, 0x9a, 0xff, 0xed, 0x04, 0x45, 0xde,
	0xd7, 0xb1, 0xd1, 0x58, 0x66, 0xcb, 0xab, 0x25, 0x17, 0xfc, 0xc5, 0x61, 0x86, 0x92, 0x53, 0x95,
	0xa1, 0xf6, 0x97, 0x13, 0x15, 0x71, 0xb8, 0x5c, 0x5c, 0x1c, 0xce, 0x72, 0xb7, 0x34, 0xdc, 0x88,
	0xc9, 0x75, 0xa8, 0x94, 0x63, 0x32, 0xc5, 0xa1, 0x3a, 0x3b, 0x37, 0x99, 0x31, 0xd3, 0xa3, 0x89,
	0x33, 0x79, 0x19, 0xd6, 0x1c, 0xb5, 0x06, 0x48, 0x8b, 0x31, 0x1d, 0xcd, 0x6f, 0xd4, 0x5c, 0x19,
	0xe5, 0xc3, 0x7a, 0x0f, 0x56, 0x3c, 0x19, 0x4d, 0xb8, 0xea, 0xff, 0xf5, 0xea, 0xdc, 0x7f, 0xe5,
	0xc4, 0x8e, 0x0a, 0x37, 0xb2, 0x0f, 0x5b, 0xe5, 0xa4, 0xf9, 0x84, 0x1d, 0x02, 0x4d, 0x58, 0xf1,
	0xbb, 0xe8, 0xe2, 0xdc, 0x80, 0x87, 0x70, 0x2b, 0xda, 0xcc, 0x9e, 0x51, 0x0a, 0x34, 0xe4, 0x5d,
	0xa8, 0x71, 0x8d, 0xcc, 0x5d, 0xc1, 0xee, 0xe5, 0x11, 0x82, 0xcf, 0x79, 0xbb, 0x99, 0x3f, 0x4b,
	0x9a, 0xe5, 0xb3, 0xa4, 0x79, 0xbf, 0x7c, 0x96, 0x44, 0xd5, 0x02, 0xef, 0x34, 0xe4, 0x3a, 0x90,
	0x84, 0x19, 0x4b, 0x53, 0x15, 0x8b, 0x3d, 0x51, 0x06, 0xa9, 0xce, 0x0d, 0xb2, 0xe1, 0xbc, 0x6e,
	0x17, 0x4e, 0x3e, 0x12, 0x83, 0xb5, 0xbc, 0xa9, 0xd4, 0xcd, 0xb8, 0x6f, 0xc2, 0x9a, 0x2f, 0xf6,
	0x9d, 0xe7, 0xa7, 0x4d, 0x33, 0x1f, 0x40, 0xd7, 0xbb, 0xe7, 0xab, 0xb6, 0xa6, 0xa7, 0x54, 0xdb,
	0x07, 0x70, 0xfc, 0x19, 0xc8, 0x21, 0x1b, 0xf0, 0xd6, 0xf4, 0x06, 0x7c, 0x9e, 0xa7, 0xc5, 0x38,
	0x83, 0xe9, 0xe8, 0xd3, 0x9b, 0xf3, 0x73, 0xd8, 0x3c, 0x14, 0x33, 0xa1, 0x77, 0x30, 0x9f, 0xde,
	0x8b, 0x87, 0xd3, 0xfb, 0x0a, 0x3e, 0x7c, 0x5c, 0x5f, 0x78, 0xf4, 0xb8, 0xbe, 0xf0, 0xf4, 0x71,
	0x3d, 0xf8, 0x66, 0x54, 0x0f, 0x7e, 0x1a, 0xd5, 0x83, 0xdf, 0x46, 0xf5, 0xe0, 0xe1, 0xa8, 0x1e,
	0xfc, 0x31, 0xaa, 0x07, 0x7f, 0x8e, 0xea, 0x0b, 0x4f, 0x47, 0xf5, 0xe0, 0x87, 0x27, 0xf5, 0x85,
	0x87, 0x4f, 0xea, 0x0b, 0x8f, 0x9e, 0xd4, 0x17, 0x3e, 0x6b, 0xf5, 0xd4, 0xa4, 0x2e, 0xa1, 0xfe,
	0xe1, 0x35, 0x7b, 0x79, 0x2c, 0xec, 0xae, 0xf8, 0x29, 0x5e, 0xf8, 0x2b, 0x00, 0x00, 0xff, 0xff,
	0x3d, 0xd6, 0x0f, 0x4c, 0x01, 0x0b, 0x00, 0x00,
}

func (this *CertificateFilterSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CertificateFilterSpec)
	if !ok {
		that2, ok := that.(CertificateFilterSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CommonName != that1.CommonName {
		return false
	}
	if this.Organization != that1.Organization {
		return false
	}
	if this.OrganizationalUnit != that1.OrganizationalUnit {
		return false
	}
	if this.SubjectAlternativeName != that1.SubjectAlternativeName {
		return false
	}
	return true
}
func (this *MtlsAuthSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MtlsAuthSpec)
	if !ok {
		that2, ok := that.(MtlsAuthSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AcceptedClientCa != that1.AcceptedClientCa {
		return false
	}
	if len(this.CertificateFilters) != len(that1.CertificateFilters) {
		return false
	}
	for i := range this.CertificateFilters {
		if !this.CertificateFilters[i].Equal(that1.CertificateFilters[i]) {
			return false
		}
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (this *ApiKeyAuthSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApiKeyAuthSpec)
	if !ok {
		that2, ok := that.(ApiKeyAuthSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (this *CodecServerSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodecServerSpec)
	if !ok {
		that2, ok := that.(CodecServerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Endpoint != that1.Endpoint {
		return false
	}
	if this.PassAccessToken != that1.PassAccessToken {
		return false
	}
	if this.IncludeCrossOriginCredentials != that1.IncludeCrossOriginCredentials {
		return false
	}
	return true
}
func (this *NamespaceSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceSpec)
	if !ok {
		that2, ok := that.(NamespaceSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Regions) != len(that1.Regions) {
		return false
	}
	for i := range this.Regions {
		if this.Regions[i] != that1.Regions[i] {
			return false
		}
	}
	if this.RetentionDays != that1.RetentionDays {
		return false
	}
	if !this.MtlsAuth.Equal(that1.MtlsAuth) {
		return false
	}
	if !this.ApiKeyAuth.Equal(that1.ApiKeyAuth) {
		return false
	}
	if len(this.CustomSearchAttributes) != len(that1.CustomSearchAttributes) {
		return false
	}
	for i := range this.CustomSearchAttributes {
		if this.CustomSearchAttributes[i] != that1.CustomSearchAttributes[i] {
			return false
		}
	}
	if !this.CodecServer.Equal(that1.CodecServer) {
		return false
	}
	return true
}
func (this *Endpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Endpoints)
	if !ok {
		that2, ok := that.(Endpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WebAddress != that1.WebAddress {
		return false
	}
	if this.MtlsGrpcAddress != that1.MtlsGrpcAddress {
		return false
	}
	if this.GrpcAddress != that1.GrpcAddress {
		return false
	}
	return true
}
func (this *Limits) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Limits)
	if !ok {
		that2, ok := that.(Limits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActionsPerSecondLimit != that1.ActionsPerSecondLimit {
		return false
	}
	return true
}
func (this *AWSPrivateLinkInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSPrivateLinkInfo)
	if !ok {
		that2, ok := that.(AWSPrivateLinkInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AllowedPrincipalArns) != len(that1.AllowedPrincipalArns) {
		return false
	}
	for i := range this.AllowedPrincipalArns {
		if this.AllowedPrincipalArns[i] != that1.AllowedPrincipalArns[i] {
			return false
		}
	}
	if len(this.VpcEndpointServiceNames) != len(that1.VpcEndpointServiceNames) {
		return false
	}
	for i := range this.VpcEndpointServiceNames {
		if this.VpcEndpointServiceNames[i] != that1.VpcEndpointServiceNames[i] {
			return false
		}
	}
	return true
}
func (this *PrivateConnectivity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrivateConnectivity)
	if !ok {
		that2, ok := that.(PrivateConnectivity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if !this.AwsPrivateLink.Equal(that1.AwsPrivateLink) {
		return false
	}
	return true
}
func (this *Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Namespace)
	if !ok {
		that2, ok := that.(Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.AsyncOperationId != that1.AsyncOperationId {
		return false
	}
	if !this.Endpoints.Equal(that1.Endpoints) {
		return false
	}
	if this.ActiveRegion != that1.ActiveRegion {
		return false
	}
	if !this.Limits.Equal(that1.Limits) {
		return false
	}
	if len(this.PrivateConnectivities) != len(that1.PrivateConnectivities) {
		return false
	}
	for i := range this.PrivateConnectivities {
		if !this.PrivateConnectivities[i].Equal(that1.PrivateConnectivities[i]) {
			return false
		}
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.LastModifiedTime.Equal(that1.LastModifiedTime) {
		return false
	}
	if len(this.RegionStatus) != len(that1.RegionStatus) {
		return false
	}
	for i := range this.RegionStatus {
		if !this.RegionStatus[i].Equal(that1.RegionStatus[i]) {
			return false
		}
	}
	return true
}
func (this *NamespaceRegionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRegionStatus)
	if !ok {
		that2, ok := that.(NamespaceRegionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.AsyncOperationId != that1.AsyncOperationId {
		return false
	}
	return true
}
func (this *CertificateFilterSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&namespace.CertificateFilterSpec{")
	s = append(s, "CommonName: "+fmt.Sprintf("%#v", this.CommonName)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "OrganizationalUnit: "+fmt.Sprintf("%#v", this.OrganizationalUnit)+",\n")
	s = append(s, "SubjectAlternativeName: "+fmt.Sprintf("%#v", this.SubjectAlternativeName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MtlsAuthSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&namespace.MtlsAuthSpec{")
	s = append(s, "AcceptedClientCa: "+fmt.Sprintf("%#v", this.AcceptedClientCa)+",\n")
	if this.CertificateFilters != nil {
		s = append(s, "CertificateFilters: "+fmt.Sprintf("%#v", this.CertificateFilters)+",\n")
	}
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApiKeyAuthSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.ApiKeyAuthSpec{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodecServerSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&namespace.CodecServerSpec{")
	s = append(s, "Endpoint: "+fmt.Sprintf("%#v", this.Endpoint)+",\n")
	s = append(s, "PassAccessToken: "+fmt.Sprintf("%#v", this.PassAccessToken)+",\n")
	s = append(s, "IncludeCrossOriginCredentials: "+fmt.Sprintf("%#v", this.IncludeCrossOriginCredentials)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&namespace.NamespaceSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Regions: "+fmt.Sprintf("%#v", this.Regions)+",\n")
	s = append(s, "RetentionDays: "+fmt.Sprintf("%#v", this.RetentionDays)+",\n")
	if this.MtlsAuth != nil {
		s = append(s, "MtlsAuth: "+fmt.Sprintf("%#v", this.MtlsAuth)+",\n")
	}
	if this.ApiKeyAuth != nil {
		s = append(s, "ApiKeyAuth: "+fmt.Sprintf("%#v", this.ApiKeyAuth)+",\n")
	}
	keysForCustomSearchAttributes := make([]string, 0, len(this.CustomSearchAttributes))
	for k, _ := range this.CustomSearchAttributes {
		keysForCustomSearchAttributes = append(keysForCustomSearchAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCustomSearchAttributes)
	mapStringForCustomSearchAttributes := "map[string]string{"
	for _, k := range keysForCustomSearchAttributes {
		mapStringForCustomSearchAttributes += fmt.Sprintf("%#v: %#v,", k, this.CustomSearchAttributes[k])
	}
	mapStringForCustomSearchAttributes += "}"
	if this.CustomSearchAttributes != nil {
		s = append(s, "CustomSearchAttributes: "+mapStringForCustomSearchAttributes+",\n")
	}
	if this.CodecServer != nil {
		s = append(s, "CodecServer: "+fmt.Sprintf("%#v", this.CodecServer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Endpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&namespace.Endpoints{")
	s = append(s, "WebAddress: "+fmt.Sprintf("%#v", this.WebAddress)+",\n")
	s = append(s, "MtlsGrpcAddress: "+fmt.Sprintf("%#v", this.MtlsGrpcAddress)+",\n")
	s = append(s, "GrpcAddress: "+fmt.Sprintf("%#v", this.GrpcAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Limits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.Limits{")
	s = append(s, "ActionsPerSecondLimit: "+fmt.Sprintf("%#v", this.ActionsPerSecondLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSPrivateLinkInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.AWSPrivateLinkInfo{")
	s = append(s, "AllowedPrincipalArns: "+fmt.Sprintf("%#v", this.AllowedPrincipalArns)+",\n")
	s = append(s, "VpcEndpointServiceNames: "+fmt.Sprintf("%#v", this.VpcEndpointServiceNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PrivateConnectivity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.PrivateConnectivity{")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	if this.AwsPrivateLink != nil {
		s = append(s, "AwsPrivateLink: "+fmt.Sprintf("%#v", this.AwsPrivateLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Namespace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&namespace.Namespace{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "AsyncOperationId: "+fmt.Sprintf("%#v", this.AsyncOperationId)+",\n")
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+fmt.Sprintf("%#v", this.Endpoints)+",\n")
	}
	s = append(s, "ActiveRegion: "+fmt.Sprintf("%#v", this.ActiveRegion)+",\n")
	if this.Limits != nil {
		s = append(s, "Limits: "+fmt.Sprintf("%#v", this.Limits)+",\n")
	}
	if this.PrivateConnectivities != nil {
		s = append(s, "PrivateConnectivities: "+fmt.Sprintf("%#v", this.PrivateConnectivities)+",\n")
	}
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.LastModifiedTime != nil {
		s = append(s, "LastModifiedTime: "+fmt.Sprintf("%#v", this.LastModifiedTime)+",\n")
	}
	keysForRegionStatus := make([]string, 0, len(this.RegionStatus))
	for k, _ := range this.RegionStatus {
		keysForRegionStatus = append(keysForRegionStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRegionStatus)
	mapStringForRegionStatus := "map[string]*NamespaceRegionStatus{"
	for _, k := range keysForRegionStatus {
		mapStringForRegionStatus += fmt.Sprintf("%#v: %#v,", k, this.RegionStatus[k])
	}
	mapStringForRegionStatus += "}"
	if this.RegionStatus != nil {
		s = append(s, "RegionStatus: "+mapStringForRegionStatus+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRegionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.NamespaceRegionStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "AsyncOperationId: "+fmt.Sprintf("%#v", this.AsyncOperationId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CertificateFilterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateFilterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateFilterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubjectAlternativeName) > 0 {
		i -= len(m.SubjectAlternativeName)
		copy(dAtA[i:], m.SubjectAlternativeName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.SubjectAlternativeName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrganizationalUnit) > 0 {
		i -= len(m.OrganizationalUnit)
		copy(dAtA[i:], m.OrganizationalUnit)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.OrganizationalUnit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CommonName) > 0 {
		i -= len(m.CommonName)
		copy(dAtA[i:], m.CommonName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.CommonName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MtlsAuthSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MtlsAuthSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MtlsAuthSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.CertificateFilters) > 0 {
		for iNdEx := len(m.CertificateFilters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CertificateFilters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AcceptedClientCa) > 0 {
		i -= len(m.AcceptedClientCa)
		copy(dAtA[i:], m.AcceptedClientCa)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AcceptedClientCa)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApiKeyAuthSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiKeyAuthSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApiKeyAuthSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CodecServerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodecServerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodecServerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeCrossOriginCredentials {
		i--
		if m.IncludeCrossOriginCredentials {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PassAccessToken {
		i--
		if m.PassAccessToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApiKeyAuth != nil {
		{
			size, err := m.ApiKeyAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CodecServer != nil {
		{
			size, err := m.CodecServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CustomSearchAttributes) > 0 {
		for k := range m.CustomSearchAttributes {
			v := m.CustomSearchAttributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMessage(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MtlsAuth != nil {
		{
			size, err := m.MtlsAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RetentionDays != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RetentionDays))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Endpoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GrpcAddress) > 0 {
		i -= len(m.GrpcAddress)
		copy(dAtA[i:], m.GrpcAddress)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.GrpcAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MtlsGrpcAddress) > 0 {
		i -= len(m.MtlsGrpcAddress)
		copy(dAtA[i:], m.MtlsGrpcAddress)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MtlsGrpcAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WebAddress) > 0 {
		i -= len(m.WebAddress)
		copy(dAtA[i:], m.WebAddress)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.WebAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Limits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionsPerSecondLimit != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionsPerSecondLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AWSPrivateLinkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSPrivateLinkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSPrivateLinkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcEndpointServiceNames) > 0 {
		for iNdEx := len(m.VpcEndpointServiceNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VpcEndpointServiceNames[iNdEx])
			copy(dAtA[i:], m.VpcEndpointServiceNames[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.VpcEndpointServiceNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AllowedPrincipalArns) > 0 {
		for iNdEx := len(m.AllowedPrincipalArns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedPrincipalArns[iNdEx])
			copy(dAtA[i:], m.AllowedPrincipalArns[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.AllowedPrincipalArns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PrivateConnectivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivateConnectivity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrivateConnectivity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AwsPrivateLink != nil {
		{
			size, err := m.AwsPrivateLink.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegionStatus) > 0 {
		for k := range m.RegionStatus {
			v := m.RegionStatus[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.LastModifiedTime != nil {
		{
			size, err := m.LastModifiedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.PrivateConnectivities) > 0 {
		for iNdEx := len(m.PrivateConnectivities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrivateConnectivities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Limits != nil {
		{
			size, err := m.Limits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ActiveRegion) > 0 {
		i -= len(m.ActiveRegion)
		copy(dAtA[i:], m.ActiveRegion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ActiveRegion)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Endpoints != nil {
		{
			size, err := m.Endpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.AsyncOperationId) > 0 {
		i -= len(m.AsyncOperationId)
		copy(dAtA[i:], m.AsyncOperationId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AsyncOperationId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceRegionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRegionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceRegionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsyncOperationId) > 0 {
		i -= len(m.AsyncOperationId)
		copy(dAtA[i:], m.AsyncOperationId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AsyncOperationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CertificateFilterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommonName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.OrganizationalUnit)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.SubjectAlternativeName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *MtlsAuthSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AcceptedClientCa)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.CertificateFilters) > 0 {
		for _, e := range m.CertificateFilters {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *ApiKeyAuthSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *CodecServerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.PassAccessToken {
		n += 2
	}
	if m.IncludeCrossOriginCredentials {
		n += 2
	}
	return n
}

func (m *NamespaceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.RetentionDays != 0 {
		n += 1 + sovMessage(uint64(m.RetentionDays))
	}
	if m.MtlsAuth != nil {
		l = m.MtlsAuth.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.CustomSearchAttributes) > 0 {
		for k, v := range m.CustomSearchAttributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + len(v) + sovMessage(uint64(len(v)))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.CodecServer != nil {
		l = m.CodecServer.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ApiKeyAuth != nil {
		l = m.ApiKeyAuth.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Endpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WebAddress)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.MtlsGrpcAddress)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.GrpcAddress)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Limits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionsPerSecondLimit != 0 {
		n += 1 + sovMessage(uint64(m.ActionsPerSecondLimit))
	}
	return n
}

func (m *AWSPrivateLinkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowedPrincipalArns) > 0 {
		for _, s := range m.AllowedPrincipalArns {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.VpcEndpointServiceNames) > 0 {
		for _, s := range m.VpcEndpointServiceNames {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *PrivateConnectivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.AwsPrivateLink != nil {
		l = m.AwsPrivateLink.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AsyncOperationId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Endpoints != nil {
		l = m.Endpoints.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ActiveRegion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Limits != nil {
		l = m.Limits.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.PrivateConnectivities) > 0 {
		for _, e := range m.PrivateConnectivities {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LastModifiedTime != nil {
		l = m.LastModifiedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.RegionStatus) > 0 {
		for k, v := range m.RegionStatus {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NamespaceRegionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AsyncOperationId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CertificateFilterSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CertificateFilterSpec{`,
		`CommonName:` + fmt.Sprintf("%v", this.CommonName) + `,`,
		`Organization:` + fmt.Sprintf("%v", this.Organization) + `,`,
		`OrganizationalUnit:` + fmt.Sprintf("%v", this.OrganizationalUnit) + `,`,
		`SubjectAlternativeName:` + fmt.Sprintf("%v", this.SubjectAlternativeName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MtlsAuthSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCertificateFilters := "[]*CertificateFilterSpec{"
	for _, f := range this.CertificateFilters {
		repeatedStringForCertificateFilters += strings.Replace(f.String(), "CertificateFilterSpec", "CertificateFilterSpec", 1) + ","
	}
	repeatedStringForCertificateFilters += "}"
	s := strings.Join([]string{`&MtlsAuthSpec{`,
		`AcceptedClientCa:` + fmt.Sprintf("%v", this.AcceptedClientCa) + `,`,
		`CertificateFilters:` + repeatedStringForCertificateFilters + `,`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApiKeyAuthSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApiKeyAuthSpec{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodecServerSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodecServerSpec{`,
		`Endpoint:` + fmt.Sprintf("%v", this.Endpoint) + `,`,
		`PassAccessToken:` + fmt.Sprintf("%v", this.PassAccessToken) + `,`,
		`IncludeCrossOriginCredentials:` + fmt.Sprintf("%v", this.IncludeCrossOriginCredentials) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForCustomSearchAttributes := make([]string, 0, len(this.CustomSearchAttributes))
	for k, _ := range this.CustomSearchAttributes {
		keysForCustomSearchAttributes = append(keysForCustomSearchAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCustomSearchAttributes)
	mapStringForCustomSearchAttributes := "map[string]string{"
	for _, k := range keysForCustomSearchAttributes {
		mapStringForCustomSearchAttributes += fmt.Sprintf("%v: %v,", k, this.CustomSearchAttributes[k])
	}
	mapStringForCustomSearchAttributes += "}"
	s := strings.Join([]string{`&NamespaceSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Regions:` + fmt.Sprintf("%v", this.Regions) + `,`,
		`RetentionDays:` + fmt.Sprintf("%v", this.RetentionDays) + `,`,
		`MtlsAuth:` + strings.Replace(this.MtlsAuth.String(), "MtlsAuthSpec", "MtlsAuthSpec", 1) + `,`,
		`CustomSearchAttributes:` + mapStringForCustomSearchAttributes + `,`,
		`CodecServer:` + strings.Replace(this.CodecServer.String(), "CodecServerSpec", "CodecServerSpec", 1) + `,`,
		`ApiKeyAuth:` + strings.Replace(this.ApiKeyAuth.String(), "ApiKeyAuthSpec", "ApiKeyAuthSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Endpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Endpoints{`,
		`WebAddress:` + fmt.Sprintf("%v", this.WebAddress) + `,`,
		`MtlsGrpcAddress:` + fmt.Sprintf("%v", this.MtlsGrpcAddress) + `,`,
		`GrpcAddress:` + fmt.Sprintf("%v", this.GrpcAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Limits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Limits{`,
		`ActionsPerSecondLimit:` + fmt.Sprintf("%v", this.ActionsPerSecondLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSPrivateLinkInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSPrivateLinkInfo{`,
		`AllowedPrincipalArns:` + fmt.Sprintf("%v", this.AllowedPrincipalArns) + `,`,
		`VpcEndpointServiceNames:` + fmt.Sprintf("%v", this.VpcEndpointServiceNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrivateConnectivity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrivateConnectivity{`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`AwsPrivateLink:` + strings.Replace(this.AwsPrivateLink.String(), "AWSPrivateLinkInfo", "AWSPrivateLinkInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Namespace) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPrivateConnectivities := "[]*PrivateConnectivity{"
	for _, f := range this.PrivateConnectivities {
		repeatedStringForPrivateConnectivities += strings.Replace(f.String(), "PrivateConnectivity", "PrivateConnectivity", 1) + ","
	}
	repeatedStringForPrivateConnectivities += "}"
	keysForRegionStatus := make([]string, 0, len(this.RegionStatus))
	for k, _ := range this.RegionStatus {
		keysForRegionStatus = append(keysForRegionStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRegionStatus)
	mapStringForRegionStatus := "map[string]*NamespaceRegionStatus{"
	for _, k := range keysForRegionStatus {
		mapStringForRegionStatus += fmt.Sprintf("%v: %v,", k, this.RegionStatus[k])
	}
	mapStringForRegionStatus += "}"
	s := strings.Join([]string{`&Namespace{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "NamespaceSpec", "NamespaceSpec", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`AsyncOperationId:` + fmt.Sprintf("%v", this.AsyncOperationId) + `,`,
		`Endpoints:` + strings.Replace(this.Endpoints.String(), "Endpoints", "Endpoints", 1) + `,`,
		`ActiveRegion:` + fmt.Sprintf("%v", this.ActiveRegion) + `,`,
		`Limits:` + strings.Replace(this.Limits.String(), "Limits", "Limits", 1) + `,`,
		`PrivateConnectivities:` + repeatedStringForPrivateConnectivities + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastModifiedTime:` + strings.Replace(fmt.Sprintf("%v", this.LastModifiedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`RegionStatus:` + mapStringForRegionStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRegionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRegionStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`AsyncOperationId:` + fmt.Sprintf("%v", this.AsyncOperationId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CertificateFilterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateFilterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateFilterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationalUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationalUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAlternativeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectAlternativeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MtlsAuthSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MtlsAuthSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MtlsAuthSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedClientCa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptedClientCa = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateFilters = append(m.CertificateFilters, &CertificateFilterSpec{})
			if err := m.CertificateFilters[len(m.CertificateFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiKeyAuthSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiKeyAuthSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiKeyAuthSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodecServerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodecServerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodecServerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassAccessToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassAccessToken = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeCrossOriginCredentials", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeCrossOriginCredentials = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionDays", wireType)
			}
			m.RetentionDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetentionDays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtlsAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MtlsAuth == nil {
				m.MtlsAuth = &MtlsAuthSpec{}
			}
			if err := m.MtlsAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomSearchAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomSearchAttributes == nil {
				m.CustomSearchAttributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomSearchAttributes[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodecServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodecServer == nil {
				m.CodecServer = &CodecServerSpec{}
			}
			if err := m.CodecServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKeyAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiKeyAuth == nil {
				m.ApiKeyAuth = &ApiKeyAuthSpec{}
			}
			if err := m.ApiKeyAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtlsGrpcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MtlsGrpcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrpcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionsPerSecondLimit", wireType)
			}
			m.ActionsPerSecondLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionsPerSecondLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSPrivateLinkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSPrivateLinkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSPrivateLinkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPrincipalArns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedPrincipalArns = append(m.AllowedPrincipalArns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcEndpointServiceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcEndpointServiceNames = append(m.VpcEndpointServiceNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivateConnectivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivateConnectivity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivateConnectivity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPrivateLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwsPrivateLink == nil {
				m.AwsPrivateLink = &AWSPrivateLinkInfo{}
			}
			if err := m.AwsPrivateLink.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NamespaceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncOperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsyncOperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = &Endpoints{}
			}
			if err := m.Endpoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = &Limits{}
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateConnectivities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateConnectivities = append(m.PrivateConnectivities, &PrivateConnectivity{})
			if err := m.PrivateConnectivities[len(m.PrivateConnectivities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifiedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifiedTime == nil {
				m.LastModifiedTime = &types.Timestamp{}
			}
			if err := m.LastModifiedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionStatus == nil {
				m.RegionStatus = make(map[string]*NamespaceRegionStatus)
			}
			var mapkey string
			var mapvalue *NamespaceRegionStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamespaceRegionStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RegionStatus[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRegionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRegionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRegionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncOperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsyncOperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
