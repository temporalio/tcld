// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/api/cloud/namespace/v1/message.proto

package namespace

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	v11 "github.com/temporalio/tcld/protogen/api/cloud/connectivityrule/v1"
	v1 "github.com/temporalio/tcld/protogen/api/cloud/resource/v1"
	v12 "github.com/temporalio/tcld/protogen/api/cloud/sink/v1"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// temporal:dev
type Capacity_Request_State int32

const (
	STATE_CAPACITY_REQUEST_UNSPECIFIED Capacity_Request_State = 0
	STATE_CAPACITY_REQUEST_COMPLETED   Capacity_Request_State = 1
	STATE_CAPACITY_REQUEST_IN_PROGRESS Capacity_Request_State = 2
	STATE_CAPACITY_REQUEST_FAILED      Capacity_Request_State = 3
)

var Capacity_Request_State_name = map[int32]string{
	0: "StateCapacityRequestUnspecified",
	1: "StateCapacityRequestCompleted",
	2: "StateCapacityRequestInProgress",
	3: "StateCapacityRequestFailed",
}

var Capacity_Request_State_value = map[string]int32{
	"StateCapacityRequestUnspecified": 0,
	"StateCapacityRequestCompleted":   1,
	"StateCapacityRequestInProgress":  2,
	"StateCapacityRequestFailed":      3,
}

func (Capacity_Request_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{7, 2, 0}
}

type NamespaceSpec_SearchAttributeType int32

const (
	SEARCH_ATTRIBUTE_TYPE_UNSPECIFIED  NamespaceSpec_SearchAttributeType = 0
	SEARCH_ATTRIBUTE_TYPE_TEXT         NamespaceSpec_SearchAttributeType = 1
	SEARCH_ATTRIBUTE_TYPE_KEYWORD      NamespaceSpec_SearchAttributeType = 2
	SEARCH_ATTRIBUTE_TYPE_INT          NamespaceSpec_SearchAttributeType = 3
	SEARCH_ATTRIBUTE_TYPE_DOUBLE       NamespaceSpec_SearchAttributeType = 4
	SEARCH_ATTRIBUTE_TYPE_BOOL         NamespaceSpec_SearchAttributeType = 5
	SEARCH_ATTRIBUTE_TYPE_DATETIME     NamespaceSpec_SearchAttributeType = 6
	SEARCH_ATTRIBUTE_TYPE_KEYWORD_LIST NamespaceSpec_SearchAttributeType = 7
)

var NamespaceSpec_SearchAttributeType_name = map[int32]string{
	0: "SearchAttributeTypeUnspecified",
	1: "SearchAttributeTypeText",
	2: "SearchAttributeTypeKeyword",
	3: "SearchAttributeTypeInt",
	4: "SearchAttributeTypeDouble",
	5: "SearchAttributeTypeBool",
	6: "SearchAttributeTypeDatetime",
	7: "SearchAttributeTypeKeywordList",
}

var NamespaceSpec_SearchAttributeType_value = map[string]int32{
	"SearchAttributeTypeUnspecified": 0,
	"SearchAttributeTypeText":        1,
	"SearchAttributeTypeKeyword":     2,
	"SearchAttributeTypeInt":         3,
	"SearchAttributeTypeDouble":      4,
	"SearchAttributeTypeBool":        5,
	"SearchAttributeTypeDatetime":    6,
	"SearchAttributeTypeKeywordList": 7,
}

func (NamespaceSpec_SearchAttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{8, 0}
}

type NamespaceRegionStatus_State int32

const (
	STATE_UNSPECIFIED NamespaceRegionStatus_State = 0
	STATE_ADDING      NamespaceRegionStatus_State = 1
	STATE_ACTIVE      NamespaceRegionStatus_State = 2
	STATE_PASSIVE     NamespaceRegionStatus_State = 3
	STATE_REMOVING    NamespaceRegionStatus_State = 4
	STATE_FAILED      NamespaceRegionStatus_State = 5
)

var NamespaceRegionStatus_State_name = map[int32]string{
	0: "StateUnspecified",
	1: "StateAdding",
	2: "StateActive",
	3: "StatePassive",
	4: "StateRemoving",
	5: "StateFailed",
}

var NamespaceRegionStatus_State_value = map[string]int32{
	"StateUnspecified": 0,
	"StateAdding":      1,
	"StateActive":      2,
	"StatePassive":     3,
	"StateRemoving":    4,
	"StateFailed":      5,
}

func (NamespaceRegionStatus_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{14, 0}
}

type ExportSink_Health int32

const (
	HEALTH_UNSPECIFIED              ExportSink_Health = 0
	HEALTH_OK                       ExportSink_Health = 1
	HEALTH_ERROR_INTERNAL           ExportSink_Health = 2
	HEALTH_ERROR_USER_CONFIGURATION ExportSink_Health = 3
)

var ExportSink_Health_name = map[int32]string{
	0: "HealthUnspecified",
	1: "HealthOk",
	2: "HealthErrorInternal",
	3: "HealthErrorUserConfiguration",
}

var ExportSink_Health_value = map[string]int32{
	"HealthUnspecified":            0,
	"HealthOk":                     1,
	"HealthErrorInternal":          2,
	"HealthErrorUserConfiguration": 3,
}

func (ExportSink_Health) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{16, 0}
}

type Migration_State int32

const (
	STATE_MIGRATION_UNSPECIFIED             Migration_State = 0
	STATE_MIGRATION_MIGRATION_STARTED       Migration_State = 1
	STATE_MIGRATION_REPLICATION_IN_PROGRESS Migration_State = 2
	STATE_MIGRATION_WAITING_FOR_HANDOVER    Migration_State = 3
	STATE_MIGRATION_HANDOVER_IN_PROGRESS    Migration_State = 4
	STATE_MIGRATION_READY_FOR_CONFIRMATION  Migration_State = 5
	STATE_MIGRATION_COMPLETE                Migration_State = 6
	STATE_MIGRATION_FAILED                  Migration_State = 7
	STATE_MIGRATION_ABORT_IN_PROGRESS       Migration_State = 8
	STATE_MIGRATION_ABORTED                 Migration_State = 9
	STATE_MIGRATION_CONFIRM_IN_PROGRESS     Migration_State = 10
)

var Migration_State_name = map[int32]string{
	0:  "StateMigrationUnspecified",
	1:  "StateMigrationMigrationStarted",
	2:  "StateMigrationReplicationInProgress",
	3:  "StateMigrationWaitingForHandover",
	4:  "StateMigrationHandoverInProgress",
	5:  "StateMigrationReadyForConfirmation",
	6:  "StateMigrationComplete",
	7:  "StateMigrationFailed",
	8:  "StateMigrationAbortInProgress",
	9:  "StateMigrationAborted",
	10: "StateMigrationConfirmInProgress",
}

var Migration_State_value = map[string]int32{
	"StateMigrationUnspecified":           0,
	"StateMigrationMigrationStarted":      1,
	"StateMigrationReplicationInProgress": 2,
	"StateMigrationWaitingForHandover":    3,
	"StateMigrationHandoverInProgress":    4,
	"StateMigrationReadyForConfirmation":  5,
	"StateMigrationComplete":              6,
	"StateMigrationFailed":                7,
	"StateMigrationAbortInProgress":       8,
	"StateMigrationAborted":               9,
	"StateMigrationConfirmInProgress":     10,
}

func (Migration_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{19, 0}
}

type MigrationReplica_State int32

const (
	STATE_REPLICA_UNSPECIFIED         MigrationReplica_State = 0
	STATE_REPLICA_ACTIVE              MigrationReplica_State = 1
	STATE_REPLICA_PASSIVE_OUT_OF_SYNC MigrationReplica_State = 2
	STATE_REPLICA_PASSIVE_IN_SYNC     MigrationReplica_State = 3
	// If aborted migration, or if replication failed.
	STATE_REPLICA_ABANDONED MigrationReplica_State = 4
)

var MigrationReplica_State_name = map[int32]string{
	0: "StateReplicaUnspecified",
	1: "StateReplicaActive",
	2: "StateReplicaPassiveOutOfSync",
	3: "StateReplicaPassiveInSync",
	4: "StateReplicaAbandoned",
}

var MigrationReplica_State_value = map[string]int32{
	"StateReplicaUnspecified":      0,
	"StateReplicaActive":           1,
	"StateReplicaPassiveOutOfSync": 2,
	"StateReplicaPassiveInSync":    3,
	"StateReplicaAbandoned":        4,
}

func (MigrationReplica_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{20, 0}
}

type CertificateFilterSpec struct {
	// The common_name in the certificate.
	// Optional, default is empty.
	CommonName string `protobuf:"bytes,1,opt,name=common_name,json=commonName,proto3" json:"common_name,omitempty"`
	// The organization in the certificate.
	// Optional, default is empty.
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
	// The organizational_unit in the certificate.
	// Optional, default is empty.
	OrganizationalUnit string `protobuf:"bytes,3,opt,name=organizational_unit,json=organizationalUnit,proto3" json:"organizational_unit,omitempty"`
	// The subject_alternative_name in the certificate.
	// Optional, default is empty.
	SubjectAlternativeName string `protobuf:"bytes,4,opt,name=subject_alternative_name,json=subjectAlternativeName,proto3" json:"subject_alternative_name,omitempty"`
}

func (m *CertificateFilterSpec) Reset()      { *m = CertificateFilterSpec{} }
func (*CertificateFilterSpec) ProtoMessage() {}
func (*CertificateFilterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{0}
}
func (m *CertificateFilterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateFilterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateFilterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateFilterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateFilterSpec.Merge(m, src)
}
func (m *CertificateFilterSpec) XXX_Size() int {
	return m.Size()
}
func (m *CertificateFilterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateFilterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateFilterSpec proto.InternalMessageInfo

func (m *CertificateFilterSpec) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

func (m *CertificateFilterSpec) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *CertificateFilterSpec) GetOrganizationalUnit() string {
	if m != nil {
		return m.OrganizationalUnit
	}
	return ""
}

func (m *CertificateFilterSpec) GetSubjectAlternativeName() string {
	if m != nil {
		return m.SubjectAlternativeName
	}
	return ""
}

type MtlsAuthSpec struct {
	// The base64 encoded ca cert(s) in PEM format that the clients can use for authentication and authorization.
	// This must only be one value, but the CA can have a chain.
	//
	// (-- api-linter: core::0140::base64=disabled --)
	// Deprecated: Use accepted_client_ca instead. Will be ignored when accepted_client_ca is set.
	// temporal:versioning:max_version=v0.2.0
	AcceptedClientCaDeprecated string `protobuf:"bytes,1,opt,name=accepted_client_ca_deprecated,json=acceptedClientCaDeprecated,proto3" json:"accepted_client_ca_deprecated,omitempty"`
	// The ca cert(s) in PEM format that the clients can use for authentication and authorization.
	// This must only be one value, but the CA can have a chain.
	// temporal:versioning:min_version=v0.2.0
	// temporal:codegen:ignore
	AcceptedClientCa []byte `protobuf:"bytes,4,opt,name=accepted_client_ca,json=acceptedClientCa,proto3" json:"accepted_client_ca,omitempty"`
	// Certificate filters which, if specified, only allow connections from client certificates whose distinguished name properties match at least one of the filters.
	// This allows limiting access to specific end-entity certificates.
	// Optional, default is empty.
	CertificateFilters []*CertificateFilterSpec `protobuf:"bytes,2,rep,name=certificate_filters,json=certificateFilters,proto3" json:"certificate_filters,omitempty"`
	// Flag to enable mTLS auth (default: disabled).
	// Note: disabling mTLS auth will cause existing mTLS connections to fail.
	// temporal:versioning:min_version=v0.2.0
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *MtlsAuthSpec) Reset()      { *m = MtlsAuthSpec{} }
func (*MtlsAuthSpec) ProtoMessage() {}
func (*MtlsAuthSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{1}
}
func (m *MtlsAuthSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MtlsAuthSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MtlsAuthSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MtlsAuthSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MtlsAuthSpec.Merge(m, src)
}
func (m *MtlsAuthSpec) XXX_Size() int {
	return m.Size()
}
func (m *MtlsAuthSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MtlsAuthSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MtlsAuthSpec proto.InternalMessageInfo

func (m *MtlsAuthSpec) GetAcceptedClientCaDeprecated() string {
	if m != nil {
		return m.AcceptedClientCaDeprecated
	}
	return ""
}

func (m *MtlsAuthSpec) GetAcceptedClientCa() []byte {
	if m != nil {
		return m.AcceptedClientCa
	}
	return nil
}

func (m *MtlsAuthSpec) GetCertificateFilters() []*CertificateFilterSpec {
	if m != nil {
		return m.CertificateFilters
	}
	return nil
}

func (m *MtlsAuthSpec) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type ApiKeyAuthSpec struct {
	// Flag to enable API key auth (default: disabled).
	// Note: disabling API key auth will cause existing API key connections to fail.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *ApiKeyAuthSpec) Reset()      { *m = ApiKeyAuthSpec{} }
func (*ApiKeyAuthSpec) ProtoMessage() {}
func (*ApiKeyAuthSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{2}
}
func (m *ApiKeyAuthSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiKeyAuthSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiKeyAuthSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiKeyAuthSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiKeyAuthSpec.Merge(m, src)
}
func (m *ApiKeyAuthSpec) XXX_Size() int {
	return m.Size()
}
func (m *ApiKeyAuthSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiKeyAuthSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ApiKeyAuthSpec proto.InternalMessageInfo

func (m *ApiKeyAuthSpec) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type LifecycleSpec struct {
	// Flag to enable delete protection for the namespace.
	EnableDeleteProtection bool `protobuf:"varint,1,opt,name=enable_delete_protection,json=enableDeleteProtection,proto3" json:"enable_delete_protection,omitempty"`
}

func (m *LifecycleSpec) Reset()      { *m = LifecycleSpec{} }
func (*LifecycleSpec) ProtoMessage() {}
func (*LifecycleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{3}
}
func (m *LifecycleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LifecycleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LifecycleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LifecycleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifecycleSpec.Merge(m, src)
}
func (m *LifecycleSpec) XXX_Size() int {
	return m.Size()
}
func (m *LifecycleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LifecycleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LifecycleSpec proto.InternalMessageInfo

func (m *LifecycleSpec) GetEnableDeleteProtection() bool {
	if m != nil {
		return m.EnableDeleteProtection
	}
	return false
}

type CodecServerSpec struct {
	// The codec server endpoint.
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Whether to pass the user access token with your endpoint.
	PassAccessToken bool `protobuf:"varint,2,opt,name=pass_access_token,json=passAccessToken,proto3" json:"pass_access_token,omitempty"`
	// Whether to include cross-origin credentials.
	IncludeCrossOriginCredentials bool `protobuf:"varint,3,opt,name=include_cross_origin_credentials,json=includeCrossOriginCredentials,proto3" json:"include_cross_origin_credentials,omitempty"`
	// A custom error message to display for remote codec server errors.
	// temporal:versioning:min_version=v0.5.1
	CustomErrorMessage *CodecServerSpec_CustomErrorMessage `protobuf:"bytes,4,opt,name=custom_error_message,json=customErrorMessage,proto3" json:"custom_error_message,omitempty"`
}

func (m *CodecServerSpec) Reset()      { *m = CodecServerSpec{} }
func (*CodecServerSpec) ProtoMessage() {}
func (*CodecServerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{4}
}
func (m *CodecServerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodecServerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodecServerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodecServerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodecServerSpec.Merge(m, src)
}
func (m *CodecServerSpec) XXX_Size() int {
	return m.Size()
}
func (m *CodecServerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CodecServerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CodecServerSpec proto.InternalMessageInfo

func (m *CodecServerSpec) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *CodecServerSpec) GetPassAccessToken() bool {
	if m != nil {
		return m.PassAccessToken
	}
	return false
}

func (m *CodecServerSpec) GetIncludeCrossOriginCredentials() bool {
	if m != nil {
		return m.IncludeCrossOriginCredentials
	}
	return false
}

func (m *CodecServerSpec) GetCustomErrorMessage() *CodecServerSpec_CustomErrorMessage {
	if m != nil {
		return m.CustomErrorMessage
	}
	return nil
}

type CodecServerSpec_CustomErrorMessage struct {
	// The error message to display by default for any remote codec server errors.
	Default *CodecServerSpec_CustomErrorMessage_ErrorMessage `protobuf:"bytes,1,opt,name=default,proto3" json:"default,omitempty"`
}

func (m *CodecServerSpec_CustomErrorMessage) Reset()      { *m = CodecServerSpec_CustomErrorMessage{} }
func (*CodecServerSpec_CustomErrorMessage) ProtoMessage() {}
func (*CodecServerSpec_CustomErrorMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{4, 0}
}
func (m *CodecServerSpec_CustomErrorMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodecServerSpec_CustomErrorMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodecServerSpec_CustomErrorMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodecServerSpec_CustomErrorMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodecServerSpec_CustomErrorMessage.Merge(m, src)
}
func (m *CodecServerSpec_CustomErrorMessage) XXX_Size() int {
	return m.Size()
}
func (m *CodecServerSpec_CustomErrorMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CodecServerSpec_CustomErrorMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CodecServerSpec_CustomErrorMessage proto.InternalMessageInfo

func (m *CodecServerSpec_CustomErrorMessage) GetDefault() *CodecServerSpec_CustomErrorMessage_ErrorMessage {
	if m != nil {
		return m.Default
	}
	return nil
}

type CodecServerSpec_CustomErrorMessage_ErrorMessage struct {
	// A message to display.
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// A link that is displayed along side the configured message.
	Link string `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
}

func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) Reset() {
	*m = CodecServerSpec_CustomErrorMessage_ErrorMessage{}
}
func (*CodecServerSpec_CustomErrorMessage_ErrorMessage) ProtoMessage() {}
func (*CodecServerSpec_CustomErrorMessage_ErrorMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{4, 0, 0}
}
func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodecServerSpec_CustomErrorMessage_ErrorMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodecServerSpec_CustomErrorMessage_ErrorMessage.Merge(m, src)
}
func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) XXX_Size() int {
	return m.Size()
}
func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CodecServerSpec_CustomErrorMessage_ErrorMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CodecServerSpec_CustomErrorMessage_ErrorMessage proto.InternalMessageInfo

func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

type HighAvailabilitySpec struct {
	// Flag to disable managed failover for the namespace.
	DisableManagedFailover bool `protobuf:"varint,1,opt,name=disable_managed_failover,json=disableManagedFailover,proto3" json:"disable_managed_failover,omitempty"`
}

func (m *HighAvailabilitySpec) Reset()      { *m = HighAvailabilitySpec{} }
func (*HighAvailabilitySpec) ProtoMessage() {}
func (*HighAvailabilitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{5}
}
func (m *HighAvailabilitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HighAvailabilitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HighAvailabilitySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HighAvailabilitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HighAvailabilitySpec.Merge(m, src)
}
func (m *HighAvailabilitySpec) XXX_Size() int {
	return m.Size()
}
func (m *HighAvailabilitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HighAvailabilitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_HighAvailabilitySpec proto.InternalMessageInfo

func (m *HighAvailabilitySpec) GetDisableManagedFailover() bool {
	if m != nil {
		return m.DisableManagedFailover
	}
	return false
}

// temporal:dev
type CapacitySpec struct {
	// Types that are valid to be assigned to Spec:
	//
	//	*CapacitySpec_OnDemand_
	//	*CapacitySpec_Provisioned_
	Spec isCapacitySpec_Spec `protobuf_oneof:"spec"`
}

func (m *CapacitySpec) Reset()      { *m = CapacitySpec{} }
func (*CapacitySpec) ProtoMessage() {}
func (*CapacitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{6}
}
func (m *CapacitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapacitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CapacitySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CapacitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapacitySpec.Merge(m, src)
}
func (m *CapacitySpec) XXX_Size() int {
	return m.Size()
}
func (m *CapacitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CapacitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_CapacitySpec proto.InternalMessageInfo

type isCapacitySpec_Spec interface {
	isCapacitySpec_Spec()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CapacitySpec_OnDemand_ struct {
	OnDemand *CapacitySpec_OnDemand `protobuf:"bytes,1,opt,name=on_demand,json=onDemand,proto3,oneof" json:"on_demand,omitempty"`
}
type CapacitySpec_Provisioned_ struct {
	Provisioned *CapacitySpec_Provisioned `protobuf:"bytes,2,opt,name=provisioned,proto3,oneof" json:"provisioned,omitempty"`
}

func (*CapacitySpec_OnDemand_) isCapacitySpec_Spec()    {}
func (*CapacitySpec_Provisioned_) isCapacitySpec_Spec() {}

func (m *CapacitySpec) GetSpec() isCapacitySpec_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CapacitySpec) GetOnDemand() *CapacitySpec_OnDemand {
	if x, ok := m.GetSpec().(*CapacitySpec_OnDemand_); ok {
		return x.OnDemand
	}
	return nil
}

func (m *CapacitySpec) GetProvisioned() *CapacitySpec_Provisioned {
	if x, ok := m.GetSpec().(*CapacitySpec_Provisioned_); ok {
		return x.Provisioned
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CapacitySpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CapacitySpec_OnDemand_)(nil),
		(*CapacitySpec_Provisioned_)(nil),
	}
}

type CapacitySpec_OnDemand struct {
}

func (m *CapacitySpec_OnDemand) Reset()      { *m = CapacitySpec_OnDemand{} }
func (*CapacitySpec_OnDemand) ProtoMessage() {}
func (*CapacitySpec_OnDemand) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{6, 0}
}
func (m *CapacitySpec_OnDemand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapacitySpec_OnDemand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CapacitySpec_OnDemand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CapacitySpec_OnDemand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapacitySpec_OnDemand.Merge(m, src)
}
func (m *CapacitySpec_OnDemand) XXX_Size() int {
	return m.Size()
}
func (m *CapacitySpec_OnDemand) XXX_DiscardUnknown() {
	xxx_messageInfo_CapacitySpec_OnDemand.DiscardUnknown(m)
}

var xxx_messageInfo_CapacitySpec_OnDemand proto.InternalMessageInfo

type CapacitySpec_Provisioned struct {
	// the unit of the provisioned capacity (Temporal Resource Units)
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *CapacitySpec_Provisioned) Reset()      { *m = CapacitySpec_Provisioned{} }
func (*CapacitySpec_Provisioned) ProtoMessage() {}
func (*CapacitySpec_Provisioned) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{6, 1}
}
func (m *CapacitySpec_Provisioned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapacitySpec_Provisioned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CapacitySpec_Provisioned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CapacitySpec_Provisioned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapacitySpec_Provisioned.Merge(m, src)
}
func (m *CapacitySpec_Provisioned) XXX_Size() int {
	return m.Size()
}
func (m *CapacitySpec_Provisioned) XXX_DiscardUnknown() {
	xxx_messageInfo_CapacitySpec_Provisioned.DiscardUnknown(m)
}

var xxx_messageInfo_CapacitySpec_Provisioned proto.InternalMessageInfo

func (m *CapacitySpec_Provisioned) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// temporal:dev
type Capacity struct {
	// temporal:dev
	//
	// Types that are valid to be assigned to CurrentMode:
	//
	//	*Capacity_OnDemand_
	//	*Capacity_Provisioned_
	CurrentMode isCapacity_CurrentMode `protobuf_oneof:"current_mode"`
	// temporal:dev
	// The latest capacity request, if any.
	LatestRequest *Capacity_Request `protobuf:"bytes,3,opt,name=latest_request,json=latestRequest,proto3" json:"latest_request,omitempty"`
}

func (m *Capacity) Reset()      { *m = Capacity{} }
func (*Capacity) ProtoMessage() {}
func (*Capacity) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{7}
}
func (m *Capacity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Capacity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Capacity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Capacity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Capacity.Merge(m, src)
}
func (m *Capacity) XXX_Size() int {
	return m.Size()
}
func (m *Capacity) XXX_DiscardUnknown() {
	xxx_messageInfo_Capacity.DiscardUnknown(m)
}

var xxx_messageInfo_Capacity proto.InternalMessageInfo

type isCapacity_CurrentMode interface {
	isCapacity_CurrentMode()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Capacity_OnDemand_ struct {
	OnDemand *Capacity_OnDemand `protobuf:"bytes,1,opt,name=on_demand,json=onDemand,proto3,oneof" json:"on_demand,omitempty"`
}
type Capacity_Provisioned_ struct {
	Provisioned *Capacity_Provisioned `protobuf:"bytes,2,opt,name=provisioned,proto3,oneof" json:"provisioned,omitempty"`
}

func (*Capacity_OnDemand_) isCapacity_CurrentMode()    {}
func (*Capacity_Provisioned_) isCapacity_CurrentMode() {}

func (m *Capacity) GetCurrentMode() isCapacity_CurrentMode {
	if m != nil {
		return m.CurrentMode
	}
	return nil
}

func (m *Capacity) GetOnDemand() *Capacity_OnDemand {
	if x, ok := m.GetCurrentMode().(*Capacity_OnDemand_); ok {
		return x.OnDemand
	}
	return nil
}

func (m *Capacity) GetProvisioned() *Capacity_Provisioned {
	if x, ok := m.GetCurrentMode().(*Capacity_Provisioned_); ok {
		return x.Provisioned
	}
	return nil
}

func (m *Capacity) GetLatestRequest() *Capacity_Request {
	if m != nil {
		return m.LatestRequest
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Capacity) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Capacity_OnDemand_)(nil),
		(*Capacity_Provisioned_)(nil),
	}
}

// temporal:dev
type Capacity_OnDemand struct {
}

func (m *Capacity_OnDemand) Reset()      { *m = Capacity_OnDemand{} }
func (*Capacity_OnDemand) ProtoMessage() {}
func (*Capacity_OnDemand) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{7, 0}
}
func (m *Capacity_OnDemand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Capacity_OnDemand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Capacity_OnDemand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Capacity_OnDemand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Capacity_OnDemand.Merge(m, src)
}
func (m *Capacity_OnDemand) XXX_Size() int {
	return m.Size()
}
func (m *Capacity_OnDemand) XXX_DiscardUnknown() {
	xxx_messageInfo_Capacity_OnDemand.DiscardUnknown(m)
}

var xxx_messageInfo_Capacity_OnDemand proto.InternalMessageInfo

// temporal:dev
type Capacity_Provisioned struct {
	// the current unit of the provisioned capacity (Temporal Resource Units)
	CurrentValue float64 `protobuf:"fixed64,1,opt,name=current_value,json=currentValue,proto3" json:"current_value,omitempty"`
}

func (m *Capacity_Provisioned) Reset()      { *m = Capacity_Provisioned{} }
func (*Capacity_Provisioned) ProtoMessage() {}
func (*Capacity_Provisioned) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{7, 1}
}
func (m *Capacity_Provisioned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Capacity_Provisioned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Capacity_Provisioned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Capacity_Provisioned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Capacity_Provisioned.Merge(m, src)
}
func (m *Capacity_Provisioned) XXX_Size() int {
	return m.Size()
}
func (m *Capacity_Provisioned) XXX_DiscardUnknown() {
	xxx_messageInfo_Capacity_Provisioned.DiscardUnknown(m)
}

var xxx_messageInfo_Capacity_Provisioned proto.InternalMessageInfo

func (m *Capacity_Provisioned) GetCurrentValue() float64 {
	if m != nil {
		return m.CurrentValue
	}
	return 0
}

// temporal:dev
type Capacity_Request struct {
	// the current state of the capacity request (e.g. in-progress, completed, failed)
	State Capacity_Request_State `protobuf:"varint,1,opt,name=state,proto3,enum=temporal.api.cloud.namespace.v1.Capacity_Request_State" json:"state,omitempty"`
	// The date and time when the capacity request was created.
	StartTime *types.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// The date and time when the capacity request was completed or failed.
	EndTime *types.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// The id of the async operation that is creating/updating/deleting the capacity, if any.
	AsyncOperationId string `protobuf:"bytes,4,opt,name=async_operation_id,json=asyncOperationId,proto3" json:"async_operation_id,omitempty"`
	// The requested capacity specification.
	Spec *CapacitySpec `protobuf:"bytes,5,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Capacity_Request) Reset()      { *m = Capacity_Request{} }
func (*Capacity_Request) ProtoMessage() {}
func (*Capacity_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{7, 2}
}
func (m *Capacity_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Capacity_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Capacity_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Capacity_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Capacity_Request.Merge(m, src)
}
func (m *Capacity_Request) XXX_Size() int {
	return m.Size()
}
func (m *Capacity_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Capacity_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Capacity_Request proto.InternalMessageInfo

func (m *Capacity_Request) GetState() Capacity_Request_State {
	if m != nil {
		return m.State
	}
	return STATE_CAPACITY_REQUEST_UNSPECIFIED
}

func (m *Capacity_Request) GetStartTime() *types.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Capacity_Request) GetEndTime() *types.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Capacity_Request) GetAsyncOperationId() string {
	if m != nil {
		return m.AsyncOperationId
	}
	return ""
}

func (m *Capacity_Request) GetSpec() *CapacitySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type NamespaceSpec struct {
	// The name to use for the namespace.
	// This will create a namespace that's available at '<name>.<account>.github.com/temporalio/tcld/protogen:7233'.
	// The name is immutable. Once set, it cannot be changed.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The ids of the regions where the namespace should be available.
	// The GetRegions API can be used to get the list of valid region ids.
	// Specifying more than one region makes the namespace "global", which is currently a preview only feature with restricted access.
	// Please reach out to Temporal support for more information on global namespaces.
	// When provisioned the global namespace will be active on the first region in the list and passive on the rest.
	// Number of supported regions is 2.
	// The regions is immutable. Once set, it cannot be changed.
	// Example: ["aws-us-west-2"].
	Regions []string `protobuf:"bytes,2,rep,name=regions,proto3" json:"regions,omitempty"`
	// The number of days the workflows data will be retained for.
	// Changes to the retention period may impact your storage costs.
	// Any changes to the retention period will be applied to all new running workflows.
	RetentionDays int32 `protobuf:"varint,3,opt,name=retention_days,json=retentionDays,proto3" json:"retention_days,omitempty"`
	// The mTLS auth configuration for the namespace.
	// If unspecified, mTLS will be disabled.
	MtlsAuth *MtlsAuthSpec `protobuf:"bytes,4,opt,name=mtls_auth,json=mtlsAuth,proto3" json:"mtls_auth,omitempty"`
	// The API key auth configuration for the namespace.
	// If unspecified, API keys will be disabled.
	// temporal:versioning:min_version=v0.2.0
	ApiKeyAuth *ApiKeyAuthSpec `protobuf:"bytes,7,opt,name=api_key_auth,json=apiKeyAuth,proto3" json:"api_key_auth,omitempty"`
	// The custom search attributes to use for the namespace.
	// The name of the attribute is the key and the type is the value.
	// Supported attribute types: text, keyword, int, double, bool, datetime, keyword_list.
	// NOTE: currently deleting a search attribute is not supported.
	// Optional, default is empty.
	// Deprecated: Use search_attributes instead.
	// temporal:versioning:max_version=v0.3.0
	CustomSearchAttributes map[string]string `protobuf:"bytes,5,rep,name=custom_search_attributes,json=customSearchAttributes,proto3" json:"custom_search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` // Deprecated: Do not use.
	// The custom search attributes to use for the namespace.
	// The name of the attribute is the key and the type is the value.
	// Note: currently deleting a search attribute is not supported.
	// Optional, default is empty.
	// temporal:versioning:min_version=v0.3.0
	// temporal:enums:replaces=custom_search_attributes
	SearchAttributes map[string]NamespaceSpec_SearchAttributeType `protobuf:"bytes,8,rep,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=temporal.api.cloud.namespace.v1.NamespaceSpec_SearchAttributeType"`
	// Codec server spec used by UI to decode payloads for all users interacting with this namespace.
	// Optional, default is unset.
	CodecServer *CodecServerSpec `protobuf:"bytes,6,opt,name=codec_server,json=codecServer,proto3" json:"codec_server,omitempty"`
	// The lifecycle configuration for the namespace.
	// temporal:versioning:min_version=v0.4.0
	Lifecycle *LifecycleSpec `protobuf:"bytes,9,opt,name=lifecycle,proto3" json:"lifecycle,omitempty"`
	// The high availability configuration for the namespace.
	// temporal:versioning:min_version=v0.4.0
	HighAvailability *HighAvailabilitySpec `protobuf:"bytes,10,opt,name=high_availability,json=highAvailability,proto3" json:"high_availability,omitempty"`
	// The existing connectivity rule ids for the namespace.
	// temporal:versioning:min_version=v0.6.0
	ConnectivityRuleIds []string `protobuf:"bytes,11,rep,name=connectivity_rule_ids,json=connectivityRuleIds,proto3" json:"connectivity_rule_ids,omitempty"`
	// The capacity configuration for the namespace.
	// temporal:versioning:min_version=development
	// temporal:dev
	CapacitySpec *CapacitySpec `protobuf:"bytes,12,opt,name=capacity_spec,json=capacitySpec,proto3" json:"capacity_spec,omitempty"`
}

func (m *NamespaceSpec) Reset()      { *m = NamespaceSpec{} }
func (*NamespaceSpec) ProtoMessage() {}
func (*NamespaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{8}
}
func (m *NamespaceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceSpec.Merge(m, src)
}
func (m *NamespaceSpec) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceSpec proto.InternalMessageInfo

func (m *NamespaceSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamespaceSpec) GetRegions() []string {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *NamespaceSpec) GetRetentionDays() int32 {
	if m != nil {
		return m.RetentionDays
	}
	return 0
}

func (m *NamespaceSpec) GetMtlsAuth() *MtlsAuthSpec {
	if m != nil {
		return m.MtlsAuth
	}
	return nil
}

func (m *NamespaceSpec) GetApiKeyAuth() *ApiKeyAuthSpec {
	if m != nil {
		return m.ApiKeyAuth
	}
	return nil
}

// Deprecated: Do not use.
func (m *NamespaceSpec) GetCustomSearchAttributes() map[string]string {
	if m != nil {
		return m.CustomSearchAttributes
	}
	return nil
}

func (m *NamespaceSpec) GetSearchAttributes() map[string]NamespaceSpec_SearchAttributeType {
	if m != nil {
		return m.SearchAttributes
	}
	return nil
}

func (m *NamespaceSpec) GetCodecServer() *CodecServerSpec {
	if m != nil {
		return m.CodecServer
	}
	return nil
}

func (m *NamespaceSpec) GetLifecycle() *LifecycleSpec {
	if m != nil {
		return m.Lifecycle
	}
	return nil
}

func (m *NamespaceSpec) GetHighAvailability() *HighAvailabilitySpec {
	if m != nil {
		return m.HighAvailability
	}
	return nil
}

func (m *NamespaceSpec) GetConnectivityRuleIds() []string {
	if m != nil {
		return m.ConnectivityRuleIds
	}
	return nil
}

func (m *NamespaceSpec) GetCapacitySpec() *CapacitySpec {
	if m != nil {
		return m.CapacitySpec
	}
	return nil
}

type Endpoints struct {
	// The web UI address.
	WebAddress string `protobuf:"bytes,1,opt,name=web_address,json=webAddress,proto3" json:"web_address,omitempty"`
	// The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
	MtlsGrpcAddress string `protobuf:"bytes,2,opt,name=mtls_grpc_address,json=mtlsGrpcAddress,proto3" json:"mtls_grpc_address,omitempty"`
	// The gRPC address for API key client connections (may be empty if API keys are disabled).
	GrpcAddress string `protobuf:"bytes,3,opt,name=grpc_address,json=grpcAddress,proto3" json:"grpc_address,omitempty"`
}

func (m *Endpoints) Reset()      { *m = Endpoints{} }
func (*Endpoints) ProtoMessage() {}
func (*Endpoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{9}
}
func (m *Endpoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoints.Merge(m, src)
}
func (m *Endpoints) XXX_Size() int {
	return m.Size()
}
func (m *Endpoints) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoints.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoints proto.InternalMessageInfo

func (m *Endpoints) GetWebAddress() string {
	if m != nil {
		return m.WebAddress
	}
	return ""
}

func (m *Endpoints) GetMtlsGrpcAddress() string {
	if m != nil {
		return m.MtlsGrpcAddress
	}
	return ""
}

func (m *Endpoints) GetGrpcAddress() string {
	if m != nil {
		return m.GrpcAddress
	}
	return ""
}

type Limits struct {
	// The number of actions per second (APS) that is currently allowed for the namespace.
	// The namespace may be throttled if its APS exceeds the limit.
	ActionsPerSecondLimit int32 `protobuf:"varint,1,opt,name=actions_per_second_limit,json=actionsPerSecondLimit,proto3" json:"actions_per_second_limit,omitempty"`
}

func (m *Limits) Reset()      { *m = Limits{} }
func (*Limits) ProtoMessage() {}
func (*Limits) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{10}
}
func (m *Limits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limits.Merge(m, src)
}
func (m *Limits) XXX_Size() int {
	return m.Size()
}
func (m *Limits) XXX_DiscardUnknown() {
	xxx_messageInfo_Limits.DiscardUnknown(m)
}

var xxx_messageInfo_Limits proto.InternalMessageInfo

func (m *Limits) GetActionsPerSecondLimit() int32 {
	if m != nil {
		return m.ActionsPerSecondLimit
	}
	return 0
}

type AWSPrivateLinkInfo struct {
	// The list of principal arns that are allowed to access the namespace on the private link.
	AllowedPrincipalArns []string `protobuf:"bytes,1,rep,name=allowed_principal_arns,json=allowedPrincipalArns,proto3" json:"allowed_principal_arns,omitempty"`
	// The list of vpc endpoint service names that are associated with the namespace.
	VpcEndpointServiceNames []string `protobuf:"bytes,2,rep,name=vpc_endpoint_service_names,json=vpcEndpointServiceNames,proto3" json:"vpc_endpoint_service_names,omitempty"`
}

func (m *AWSPrivateLinkInfo) Reset()      { *m = AWSPrivateLinkInfo{} }
func (*AWSPrivateLinkInfo) ProtoMessage() {}
func (*AWSPrivateLinkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{11}
}
func (m *AWSPrivateLinkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSPrivateLinkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSPrivateLinkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSPrivateLinkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSPrivateLinkInfo.Merge(m, src)
}
func (m *AWSPrivateLinkInfo) XXX_Size() int {
	return m.Size()
}
func (m *AWSPrivateLinkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSPrivateLinkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AWSPrivateLinkInfo proto.InternalMessageInfo

func (m *AWSPrivateLinkInfo) GetAllowedPrincipalArns() []string {
	if m != nil {
		return m.AllowedPrincipalArns
	}
	return nil
}

func (m *AWSPrivateLinkInfo) GetVpcEndpointServiceNames() []string {
	if m != nil {
		return m.VpcEndpointServiceNames
	}
	return nil
}

type PrivateConnectivity struct {
	// The id of the region where the private connectivity applies.
	Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// The AWS PrivateLink info.
	// This will only be set for an aws region.
	AwsPrivateLink *AWSPrivateLinkInfo `protobuf:"bytes,2,opt,name=aws_private_link,json=awsPrivateLink,proto3" json:"aws_private_link,omitempty"`
}

func (m *PrivateConnectivity) Reset()      { *m = PrivateConnectivity{} }
func (*PrivateConnectivity) ProtoMessage() {}
func (*PrivateConnectivity) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{12}
}
func (m *PrivateConnectivity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrivateConnectivity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrivateConnectivity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrivateConnectivity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivateConnectivity.Merge(m, src)
}
func (m *PrivateConnectivity) XXX_Size() int {
	return m.Size()
}
func (m *PrivateConnectivity) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivateConnectivity.DiscardUnknown(m)
}

var xxx_messageInfo_PrivateConnectivity proto.InternalMessageInfo

func (m *PrivateConnectivity) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *PrivateConnectivity) GetAwsPrivateLink() *AWSPrivateLinkInfo {
	if m != nil {
		return m.AwsPrivateLink
	}
	return nil
}

type Namespace struct {
	// The namespace identifier.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// The current version of the namespace specification.
	// The next update operation will have to include this version.
	ResourceVersion string `protobuf:"bytes,2,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// The namespace specification.
	Spec *NamespaceSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	// The current state of the namespace.
	// Deprecated: Use state instead.
	// temporal:versioning:max_version=v0.3.0
	StateDeprecated string `protobuf:"bytes,4,opt,name=state_deprecated,json=stateDeprecated,proto3" json:"state_deprecated,omitempty"` // Deprecated: Do not use.
	// The current state of the namespace.
	// For any failed state, reach out to Temporal Cloud support for remediation.
	// temporal:versioning:min_version=v0.3.0
	// temporal:enums:replaces=state_deprecated
	State v1.ResourceState `protobuf:"varint,13,opt,name=state,proto3,enum=temporal.api.cloud.resource.v1.ResourceState" json:"state,omitempty"`
	// The id of the async operation that is creating/updating/deleting the namespace, if any.
	AsyncOperationId string `protobuf:"bytes,5,opt,name=async_operation_id,json=asyncOperationId,proto3" json:"async_operation_id,omitempty"`
	// The endpoints for the namespace.
	Endpoints *Endpoints `protobuf:"bytes,6,opt,name=endpoints,proto3" json:"endpoints,omitempty"`
	// The currently active region for the namespace.
	ActiveRegion string `protobuf:"bytes,7,opt,name=active_region,json=activeRegion,proto3" json:"active_region,omitempty"`
	// The limits set on the namespace currently.
	Limits *Limits `protobuf:"bytes,8,opt,name=limits,proto3" json:"limits,omitempty"`
	// The private connectivities for the namespace, if any.
	PrivateConnectivities []*PrivateConnectivity `protobuf:"bytes,9,rep,name=private_connectivities,json=privateConnectivities,proto3" json:"private_connectivities,omitempty"`
	// The date and time when the namespace was created.
	CreatedTime *types.Timestamp `protobuf:"bytes,10,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// The date and time when the namespace was last modified.
	// Will not be set if the namespace has never been modified.
	LastModifiedTime *types.Timestamp `protobuf:"bytes,11,opt,name=last_modified_time,json=lastModifiedTime,proto3" json:"last_modified_time,omitempty"`
	// The status of each region where the namespace is available.
	// The id of the region is the key and the status is the value of the map.
	RegionStatus map[string]*NamespaceRegionStatus `protobuf:"bytes,12,rep,name=region_status,json=regionStatus,proto3" json:"region_status,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// connectivity_rules that set on this namespace
	ConnectivityRules []*v11.ConnectivityRule `protobuf:"bytes,14,rep,name=connectivity_rules,json=connectivityRules,proto3" json:"connectivity_rules,omitempty"`
	// The tags for the namespace.
	// temporal:dev
	Tags map[string]string `protobuf:"bytes,15,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The capacity of the namespace.
	// temporal:dev
	Capacity *Capacity `protobuf:"bytes,16,opt,name=capacity,proto3" json:"capacity,omitempty"`
}

func (m *Namespace) Reset()      { *m = Namespace{} }
func (*Namespace) ProtoMessage() {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{13}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Namespace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

func (m *Namespace) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Namespace) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *Namespace) GetSpec() *NamespaceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Deprecated: Do not use.
func (m *Namespace) GetStateDeprecated() string {
	if m != nil {
		return m.StateDeprecated
	}
	return ""
}

func (m *Namespace) GetState() v1.ResourceState {
	if m != nil {
		return m.State
	}
	return v1.RESOURCE_STATE_UNSPECIFIED
}

func (m *Namespace) GetAsyncOperationId() string {
	if m != nil {
		return m.AsyncOperationId
	}
	return ""
}

func (m *Namespace) GetEndpoints() *Endpoints {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *Namespace) GetActiveRegion() string {
	if m != nil {
		return m.ActiveRegion
	}
	return ""
}

func (m *Namespace) GetLimits() *Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Namespace) GetPrivateConnectivities() []*PrivateConnectivity {
	if m != nil {
		return m.PrivateConnectivities
	}
	return nil
}

func (m *Namespace) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *Namespace) GetLastModifiedTime() *types.Timestamp {
	if m != nil {
		return m.LastModifiedTime
	}
	return nil
}

func (m *Namespace) GetRegionStatus() map[string]*NamespaceRegionStatus {
	if m != nil {
		return m.RegionStatus
	}
	return nil
}

func (m *Namespace) GetConnectivityRules() []*v11.ConnectivityRule {
	if m != nil {
		return m.ConnectivityRules
	}
	return nil
}

func (m *Namespace) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Namespace) GetCapacity() *Capacity {
	if m != nil {
		return m.Capacity
	}
	return nil
}

type NamespaceRegionStatus struct {
	// The current state of the namespace region.
	// Possible values: adding, active, passive, removing, failed.
	// For any failed state, reach out to Temporal Cloud support for remediation.
	// Deprecated: Use state instead.
	// temporal:versioning:max_version=v0.3.0
	StateDeprecated string `protobuf:"bytes,1,opt,name=state_deprecated,json=stateDeprecated,proto3" json:"state_deprecated,omitempty"` // Deprecated: Do not use.
	// The current state of the namespace region.
	// temporal:versioning:min_version=v0.3.0
	// temporal:enums:replaces=state_deprecated
	State NamespaceRegionStatus_State `protobuf:"varint,3,opt,name=state,proto3,enum=temporal.api.cloud.namespace.v1.NamespaceRegionStatus_State" json:"state,omitempty"`
	// The id of the async operation that is making changes to where the namespace is available, if any.
	AsyncOperationId string `protobuf:"bytes,2,opt,name=async_operation_id,json=asyncOperationId,proto3" json:"async_operation_id,omitempty"`
}

func (m *NamespaceRegionStatus) Reset()      { *m = NamespaceRegionStatus{} }
func (*NamespaceRegionStatus) ProtoMessage() {}
func (*NamespaceRegionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{14}
}
func (m *NamespaceRegionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceRegionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceRegionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceRegionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceRegionStatus.Merge(m, src)
}
func (m *NamespaceRegionStatus) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceRegionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceRegionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceRegionStatus proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *NamespaceRegionStatus) GetStateDeprecated() string {
	if m != nil {
		return m.StateDeprecated
	}
	return ""
}

func (m *NamespaceRegionStatus) GetState() NamespaceRegionStatus_State {
	if m != nil {
		return m.State
	}
	return STATE_UNSPECIFIED
}

func (m *NamespaceRegionStatus) GetAsyncOperationId() string {
	if m != nil {
		return m.AsyncOperationId
	}
	return ""
}

type ExportSinkSpec struct {
	// The unique name of the export sink.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A flag indicating whether the export sink is enabled or not.
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// The S3 configuration details when destination_type is S3.
	S3 *v12.S3Spec `protobuf:"bytes,3,opt,name=s3,proto3" json:"s3,omitempty"`
	// This is a feature under development. We will allow GCS sink support for GCP Namespaces.
	// The GCS configuration details when destination_type is GCS.
	Gcs *v12.GCSSpec `protobuf:"bytes,4,opt,name=gcs,proto3" json:"gcs,omitempty"`
}

func (m *ExportSinkSpec) Reset()      { *m = ExportSinkSpec{} }
func (*ExportSinkSpec) ProtoMessage() {}
func (*ExportSinkSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{15}
}
func (m *ExportSinkSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportSinkSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportSinkSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportSinkSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportSinkSpec.Merge(m, src)
}
func (m *ExportSinkSpec) XXX_Size() int {
	return m.Size()
}
func (m *ExportSinkSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportSinkSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExportSinkSpec proto.InternalMessageInfo

func (m *ExportSinkSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExportSinkSpec) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *ExportSinkSpec) GetS3() *v12.S3Spec {
	if m != nil {
		return m.S3
	}
	return nil
}

func (m *ExportSinkSpec) GetGcs() *v12.GCSSpec {
	if m != nil {
		return m.Gcs
	}
	return nil
}

type ExportSink struct {
	// The unique name of the export sink, once set it can't be changed
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The version of the export sink resource.
	ResourceVersion string `protobuf:"bytes,2,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// The current state of the export sink.
	State v1.ResourceState `protobuf:"varint,3,opt,name=state,proto3,enum=temporal.api.cloud.resource.v1.ResourceState" json:"state,omitempty"`
	// The specification details of the export sink.
	Spec *ExportSinkSpec `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty"`
	// The health status of the export sink.
	Health ExportSink_Health `protobuf:"varint,5,opt,name=health,proto3,enum=temporal.api.cloud.namespace.v1.ExportSink_Health" json:"health,omitempty"`
	// An error message describing any issues with the export sink, if applicable.
	ErrorMessage string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// The timestamp of the latest successful data export.
	LatestDataExportTime *types.Timestamp `protobuf:"bytes,7,opt,name=latest_data_export_time,json=latestDataExportTime,proto3" json:"latest_data_export_time,omitempty"`
	// The timestamp of the last health check performed on the export sink.
	LastHealthCheckTime *types.Timestamp `protobuf:"bytes,8,opt,name=last_health_check_time,json=lastHealthCheckTime,proto3" json:"last_health_check_time,omitempty"`
}

func (m *ExportSink) Reset()      { *m = ExportSink{} }
func (*ExportSink) ProtoMessage() {}
func (*ExportSink) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{16}
}
func (m *ExportSink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportSink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportSink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportSink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportSink.Merge(m, src)
}
func (m *ExportSink) XXX_Size() int {
	return m.Size()
}
func (m *ExportSink) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportSink.DiscardUnknown(m)
}

var xxx_messageInfo_ExportSink proto.InternalMessageInfo

func (m *ExportSink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExportSink) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *ExportSink) GetState() v1.ResourceState {
	if m != nil {
		return m.State
	}
	return v1.RESOURCE_STATE_UNSPECIFIED
}

func (m *ExportSink) GetSpec() *ExportSinkSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ExportSink) GetHealth() ExportSink_Health {
	if m != nil {
		return m.Health
	}
	return HEALTH_UNSPECIFIED
}

func (m *ExportSink) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ExportSink) GetLatestDataExportTime() *types.Timestamp {
	if m != nil {
		return m.LatestDataExportTime
	}
	return nil
}

func (m *ExportSink) GetLastHealthCheckTime() *types.Timestamp {
	if m != nil {
		return m.LastHealthCheckTime
	}
	return nil
}

// temporal:dev
type MigrationSpec struct {
	// The id of the migration endpoint used for connecting
	// the self-hosted Temporal cluster to Temporal cloud.
	MigrationEndpointId string `protobuf:"bytes,1,opt,name=migration_endpoint_id,json=migrationEndpointId,proto3" json:"migration_endpoint_id,omitempty"`
	// Types that are valid to be assigned to Spec:
	//
	//	*MigrationSpec_ToCloudSpec
	Spec isMigrationSpec_Spec `protobuf_oneof:"spec"`
}

func (m *MigrationSpec) Reset()      { *m = MigrationSpec{} }
func (*MigrationSpec) ProtoMessage() {}
func (*MigrationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{17}
}
func (m *MigrationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationSpec.Merge(m, src)
}
func (m *MigrationSpec) XXX_Size() int {
	return m.Size()
}
func (m *MigrationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationSpec proto.InternalMessageInfo

type isMigrationSpec_Spec interface {
	isMigrationSpec_Spec()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MigrationSpec_ToCloudSpec struct {
	ToCloudSpec *MigrationToCloudSpec `protobuf:"bytes,2,opt,name=to_cloud_spec,json=toCloudSpec,proto3,oneof" json:"to_cloud_spec,omitempty"`
}

func (*MigrationSpec_ToCloudSpec) isMigrationSpec_Spec() {}

func (m *MigrationSpec) GetSpec() isMigrationSpec_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MigrationSpec) GetMigrationEndpointId() string {
	if m != nil {
		return m.MigrationEndpointId
	}
	return ""
}

func (m *MigrationSpec) GetToCloudSpec() *MigrationToCloudSpec {
	if x, ok := m.GetSpec().(*MigrationSpec_ToCloudSpec); ok {
		return x.ToCloudSpec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MigrationSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MigrationSpec_ToCloudSpec)(nil),
	}
}

// temporal:dev
type MigrationToCloudSpec struct {
	// The source namespace name for the migration.
	SourceNamespace string `protobuf:"bytes,1,opt,name=source_namespace,json=sourceNamespace,proto3" json:"source_namespace,omitempty"`
	// The target namespace name for the migration.
	TargetNamespace string `protobuf:"bytes,2,opt,name=target_namespace,json=targetNamespace,proto3" json:"target_namespace,omitempty"`
}

func (m *MigrationToCloudSpec) Reset()      { *m = MigrationToCloudSpec{} }
func (*MigrationToCloudSpec) ProtoMessage() {}
func (*MigrationToCloudSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{18}
}
func (m *MigrationToCloudSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationToCloudSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationToCloudSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationToCloudSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationToCloudSpec.Merge(m, src)
}
func (m *MigrationToCloudSpec) XXX_Size() int {
	return m.Size()
}
func (m *MigrationToCloudSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationToCloudSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationToCloudSpec proto.InternalMessageInfo

func (m *MigrationToCloudSpec) GetSourceNamespace() string {
	if m != nil {
		return m.SourceNamespace
	}
	return ""
}

func (m *MigrationToCloudSpec) GetTargetNamespace() string {
	if m != nil {
		return m.TargetNamespace
	}
	return ""
}

// temporal:dev
type Migration struct {
	// The unique id of this migration.
	MigrationId string `protobuf:"bytes,1,opt,name=migration_id,json=migrationId,proto3" json:"migration_id,omitempty"`
	// The MigrationSpec provided in the StartMigrationRequest.
	Spec *MigrationSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	// The state of the migration.
	State Migration_State `protobuf:"varint,3,opt,name=state,proto3,enum=temporal.api.cloud.namespace.v1.Migration_State" json:"state,omitempty"`
	// The source and destination replicas involved in the migration.
	Replicas []*MigrationReplica `protobuf:"bytes,4,rep,name=replicas,proto3" json:"replicas,omitempty"`
	// The number of workflows replicated.
	ReplicatedWorkflows int64 `protobuf:"varint,5,opt,name=replicated_workflows,json=replicatedWorkflows,proto3" json:"replicated_workflows,omitempty"`
	// The number of workflows remaining.
	ReplicatedWorkflowsRemaining int64 `protobuf:"varint,6,opt,name=replicated_workflows_remaining,json=replicatedWorkflowsRemaining,proto3" json:"replicated_workflows_remaining,omitempty"`
	// An error message if the migration failed.
	FailureMessage string `protobuf:"bytes,7,opt,name=failure_message,json=failureMessage,proto3" json:"failure_message,omitempty"`
}

func (m *Migration) Reset()      { *m = Migration{} }
func (*Migration) ProtoMessage() {}
func (*Migration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{19}
}
func (m *Migration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Migration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Migration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Migration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Migration.Merge(m, src)
}
func (m *Migration) XXX_Size() int {
	return m.Size()
}
func (m *Migration) XXX_DiscardUnknown() {
	xxx_messageInfo_Migration.DiscardUnknown(m)
}

var xxx_messageInfo_Migration proto.InternalMessageInfo

func (m *Migration) GetMigrationId() string {
	if m != nil {
		return m.MigrationId
	}
	return ""
}

func (m *Migration) GetSpec() *MigrationSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Migration) GetState() Migration_State {
	if m != nil {
		return m.State
	}
	return STATE_MIGRATION_UNSPECIFIED
}

func (m *Migration) GetReplicas() []*MigrationReplica {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *Migration) GetReplicatedWorkflows() int64 {
	if m != nil {
		return m.ReplicatedWorkflows
	}
	return 0
}

func (m *Migration) GetReplicatedWorkflowsRemaining() int64 {
	if m != nil {
		return m.ReplicatedWorkflowsRemaining
	}
	return 0
}

func (m *Migration) GetFailureMessage() string {
	if m != nil {
		return m.FailureMessage
	}
	return ""
}

// temporal:dev
type MigrationReplica struct {
	// The id of this replica. Indicates whether the replica is on the source
	// or destination side of the migration.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The state of this replica.
	State MigrationReplica_State `protobuf:"varint,2,opt,name=state,proto3,enum=temporal.api.cloud.namespace.v1.MigrationReplica_State" json:"state,omitempty"`
}

func (m *MigrationReplica) Reset()      { *m = MigrationReplica{} }
func (*MigrationReplica) ProtoMessage() {}
func (*MigrationReplica) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ea8dce281a9b52e, []int{20}
}
func (m *MigrationReplica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationReplica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationReplica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationReplica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationReplica.Merge(m, src)
}
func (m *MigrationReplica) XXX_Size() int {
	return m.Size()
}
func (m *MigrationReplica) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationReplica.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationReplica proto.InternalMessageInfo

func (m *MigrationReplica) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MigrationReplica) GetState() MigrationReplica_State {
	if m != nil {
		return m.State
	}
	return STATE_REPLICA_UNSPECIFIED
}

func init() {
	proto.RegisterEnum("temporal.api.cloud.namespace.v1.Capacity_Request_State", Capacity_Request_State_name, Capacity_Request_State_value)
	proto.RegisterEnum("temporal.api.cloud.namespace.v1.NamespaceSpec_SearchAttributeType", NamespaceSpec_SearchAttributeType_name, NamespaceSpec_SearchAttributeType_value)
	proto.RegisterEnum("temporal.api.cloud.namespace.v1.NamespaceRegionStatus_State", NamespaceRegionStatus_State_name, NamespaceRegionStatus_State_value)
	proto.RegisterEnum("temporal.api.cloud.namespace.v1.ExportSink_Health", ExportSink_Health_name, ExportSink_Health_value)
	proto.RegisterEnum("temporal.api.cloud.namespace.v1.Migration_State", Migration_State_name, Migration_State_value)
	proto.RegisterEnum("temporal.api.cloud.namespace.v1.MigrationReplica_State", MigrationReplica_State_name, MigrationReplica_State_value)
	proto.RegisterType((*CertificateFilterSpec)(nil), "temporal.api.cloud.namespace.v1.CertificateFilterSpec")
	proto.RegisterType((*MtlsAuthSpec)(nil), "temporal.api.cloud.namespace.v1.MtlsAuthSpec")
	proto.RegisterType((*ApiKeyAuthSpec)(nil), "temporal.api.cloud.namespace.v1.ApiKeyAuthSpec")
	proto.RegisterType((*LifecycleSpec)(nil), "temporal.api.cloud.namespace.v1.LifecycleSpec")
	proto.RegisterType((*CodecServerSpec)(nil), "temporal.api.cloud.namespace.v1.CodecServerSpec")
	proto.RegisterType((*CodecServerSpec_CustomErrorMessage)(nil), "temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage")
	proto.RegisterType((*CodecServerSpec_CustomErrorMessage_ErrorMessage)(nil), "temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage.ErrorMessage")
	proto.RegisterType((*HighAvailabilitySpec)(nil), "temporal.api.cloud.namespace.v1.HighAvailabilitySpec")
	proto.RegisterType((*CapacitySpec)(nil), "temporal.api.cloud.namespace.v1.CapacitySpec")
	proto.RegisterType((*CapacitySpec_OnDemand)(nil), "temporal.api.cloud.namespace.v1.CapacitySpec.OnDemand")
	proto.RegisterType((*CapacitySpec_Provisioned)(nil), "temporal.api.cloud.namespace.v1.CapacitySpec.Provisioned")
	proto.RegisterType((*Capacity)(nil), "temporal.api.cloud.namespace.v1.Capacity")
	proto.RegisterType((*Capacity_OnDemand)(nil), "temporal.api.cloud.namespace.v1.Capacity.OnDemand")
	proto.RegisterType((*Capacity_Provisioned)(nil), "temporal.api.cloud.namespace.v1.Capacity.Provisioned")
	proto.RegisterType((*Capacity_Request)(nil), "temporal.api.cloud.namespace.v1.Capacity.Request")
	proto.RegisterType((*NamespaceSpec)(nil), "temporal.api.cloud.namespace.v1.NamespaceSpec")
	proto.RegisterMapType((map[string]string)(nil), "temporal.api.cloud.namespace.v1.NamespaceSpec.CustomSearchAttributesEntry")
	proto.RegisterMapType((map[string]NamespaceSpec_SearchAttributeType)(nil), "temporal.api.cloud.namespace.v1.NamespaceSpec.SearchAttributesEntry")
	proto.RegisterType((*Endpoints)(nil), "temporal.api.cloud.namespace.v1.Endpoints")
	proto.RegisterType((*Limits)(nil), "temporal.api.cloud.namespace.v1.Limits")
	proto.RegisterType((*AWSPrivateLinkInfo)(nil), "temporal.api.cloud.namespace.v1.AWSPrivateLinkInfo")
	proto.RegisterType((*PrivateConnectivity)(nil), "temporal.api.cloud.namespace.v1.PrivateConnectivity")
	proto.RegisterType((*Namespace)(nil), "temporal.api.cloud.namespace.v1.Namespace")
	proto.RegisterMapType((map[string]*NamespaceRegionStatus)(nil), "temporal.api.cloud.namespace.v1.Namespace.RegionStatusEntry")
	proto.RegisterMapType((map[string]string)(nil), "temporal.api.cloud.namespace.v1.Namespace.TagsEntry")
	proto.RegisterType((*NamespaceRegionStatus)(nil), "temporal.api.cloud.namespace.v1.NamespaceRegionStatus")
	proto.RegisterType((*ExportSinkSpec)(nil), "temporal.api.cloud.namespace.v1.ExportSinkSpec")
	proto.RegisterType((*ExportSink)(nil), "temporal.api.cloud.namespace.v1.ExportSink")
	proto.RegisterType((*MigrationSpec)(nil), "temporal.api.cloud.namespace.v1.MigrationSpec")
	proto.RegisterType((*MigrationToCloudSpec)(nil), "temporal.api.cloud.namespace.v1.MigrationToCloudSpec")
	proto.RegisterType((*Migration)(nil), "temporal.api.cloud.namespace.v1.Migration")
	proto.RegisterType((*MigrationReplica)(nil), "temporal.api.cloud.namespace.v1.MigrationReplica")
}

func init() {
	proto.RegisterFile("temporal/api/cloud/namespace/v1/message.proto", fileDescriptor_4ea8dce281a9b52e)
}

var fileDescriptor_4ea8dce281a9b52e = []byte{
	// 2948 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0xcd, 0x6f, 0x23, 0xc7,
	0x95, 0x57, 0x93, 0xfa, 0xe2, 0x23, 0x25, 0xf5, 0x94, 0x3e, 0x4c, 0xd3, 0x33, 0x9c, 0x19, 0x8e,
	0xed, 0x19, 0xcf, 0xda, 0x94, 0x47, 0x63, 0xaf, 0xc7, 0xb2, 0x17, 0x8b, 0x16, 0xd9, 0x92, 0x68,
	0x4b, 0x22, 0xa7, 0x48, 0xcd, 0x78, 0x76, 0x61, 0x34, 0x4a, 0xcd, 0x12, 0x55, 0x56, 0xb3, 0x9b,
	0xee, 0x6e, 0x4a, 0xab, 0xf5, 0x65, 0xb1, 0x17, 0xe7, 0x90, 0x43, 0x0e, 0xb9, 0xe5, 0x12, 0x20,
	0x87, 0x38, 0x41, 0xfe, 0x86, 0x5c, 0x82, 0x20, 0x39, 0x3a, 0x37, 0x23, 0x01, 0x82, 0x78, 0x8c,
	0x00, 0x41, 0x2e, 0xf1, 0x3f, 0x10, 0x20, 0xe8, 0xaa, 0xea, 0x26, 0x9b, 0x6a, 0x8d, 0x38, 0x4e,
	0x6e, 0xac, 0xf7, 0xf1, 0xab, 0x57, 0xaf, 0xdf, 0x57, 0x95, 0x04, 0x6f, 0xf8, 0xb4, 0xdb, 0x73,
	0x5c, 0x62, 0xad, 0x92, 0x1e, 0x5b, 0x35, 0x2d, 0xa7, 0xdf, 0x5e, 0xb5, 0x49, 0x97, 0x7a, 0x3d,
	0x62, 0xd2, 0xd5, 0x93, 0x7b, 0xab, 0x5d, 0xea, 0x79, 0xa4, 0x43, 0xcb, 0x3d, 0xd7, 0xf1, 0x1d,
	0x74, 0x3d, 0x14, 0x2f, 0x93, 0x1e, 0x2b, 0x73, 0xf1, 0x72, 0x24, 0x5e, 0x3e, 0xb9, 0x57, 0x78,
	0x3d, 0x01, 0xcf, 0xa5, 0x9e, 0xd3, 0x77, 0x13, 0xe0, 0x0a, 0xd7, 0x3b, 0x8e, 0xd3, 0xb1, 0xe8,
	0x2a, 0x5f, 0x1d, 0xf4, 0x0f, 0x57, 0x7d, 0xd6, 0xa5, 0x9e, 0x4f, 0xba, 0x3d, 0x29, 0x70, 0x27,
	0x01, 0xce, 0x63, 0xf6, 0xf1, 0x79, 0xa8, 0xb7, 0x12, 0x24, 0x4d, 0xc7, 0xb6, 0xa9, 0xe9, 0xb3,
	0x13, 0xe6, 0x9f, 0xb9, 0x7d, 0xeb, 0xbc, 0x01, 0xa5, 0xdf, 0x28, 0xb0, 0x5c, 0xa1, 0xae, 0xcf,
	0x0e, 0x99, 0x49, 0x7c, 0xba, 0xc9, 0x2c, 0x9f, 0xba, 0xcd, 0x1e, 0x35, 0xd1, 0x75, 0xc8, 0x9a,
	0x4e, 0xb7, 0xeb, 0xd8, 0x46, 0x70, 0xbe, 0xbc, 0x72, 0x43, 0xb9, 0x93, 0xc1, 0x20, 0x48, 0x7b,
	0xa4, 0x4b, 0x51, 0x09, 0x72, 0x8e, 0xdb, 0x21, 0x36, 0xfb, 0x5f, 0xe2, 0x33, 0xc7, 0xce, 0xa7,
	0xb8, 0x44, 0x8c, 0x86, 0x56, 0x61, 0x71, 0x78, 0x4d, 0x2c, 0xa3, 0x6f, 0x33, 0x3f, 0x9f, 0xe6,
	0xa2, 0x28, 0xce, 0xda, 0xb7, 0x99, 0x8f, 0x1e, 0x40, 0xde, 0xeb, 0x1f, 0x7c, 0x42, 0x4d, 0xdf,
	0x20, 0x81, 0x29, 0x36, 0xf1, 0xd9, 0x09, 0x15, 0x26, 0x4c, 0x72, 0xad, 0x15, 0xc9, 0xd7, 0x06,
	0xec, 0xc0, 0x9c, 0xd2, 0xff, 0xa7, 0x20, 0xb7, 0xeb, 0x5b, 0x9e, 0xd6, 0xf7, 0x8f, 0xf8, 0x01,
	0x34, 0xb8, 0x46, 0x4c, 0x93, 0xf6, 0x7c, 0xda, 0x36, 0x4c, 0x8b, 0x51, 0xdb, 0x37, 0x4c, 0x62,
	0xb4, 0x69, 0xcf, 0xa5, 0xc1, 0x51, 0xdb, 0xf2, 0x48, 0x85, 0x50, 0xa8, 0xc2, 0x65, 0x2a, 0xa4,
	0x1a, 0x49, 0xa0, 0xd7, 0x01, 0x9d, 0x87, 0xe0, 0x76, 0xe4, 0xb0, 0x3a, 0xaa, 0x87, 0x3a, 0xb0,
	0x68, 0x0e, 0x5c, 0x69, 0x1c, 0x72, 0x5f, 0x7a, 0xf9, 0xd4, 0x8d, 0xf4, 0x9d, 0xec, 0xda, 0xbf,
	0x97, 0x2f, 0x89, 0x9c, 0x72, 0xe2, 0x67, 0xc0, 0xc8, 0x1c, 0x25, 0x7b, 0x28, 0x0f, 0x33, 0xd4,
	0x26, 0x07, 0x16, 0x6d, 0x73, 0x4f, 0xce, 0xe2, 0x70, 0x59, 0xba, 0x0b, 0xf3, 0x5a, 0x8f, 0x7d,
	0x48, 0xcf, 0x22, 0x2f, 0x0c, 0xc9, 0x2a, 0x71, 0xd9, 0x1a, 0xcc, 0xed, 0xb0, 0x43, 0x6a, 0x9e,
	0x99, 0x16, 0xe5, 0xa2, 0x0f, 0x20, 0x2f, 0x78, 0x46, 0x9b, 0x5a, 0xd4, 0xa7, 0x46, 0x10, 0x22,
	0x41, 0xf8, 0x38, 0xb6, 0xd4, 0x5d, 0x11, 0xfc, 0x2a, 0x67, 0x37, 0x22, 0x6e, 0xe9, 0xf7, 0x69,
	0x58, 0xa8, 0x38, 0x6d, 0x6a, 0x36, 0xa9, 0x7b, 0x22, 0xe3, 0xa7, 0x00, 0xb3, 0xd4, 0x6e, 0xf7,
	0x1c, 0x66, 0xfb, 0xd2, 0xd3, 0xd1, 0x1a, 0xdd, 0x85, 0x2b, 0x3d, 0xe2, 0x79, 0x46, 0xe0, 0x42,
	0xcf, 0x33, 0x7c, 0xe7, 0x98, 0x8a, 0xf8, 0x99, 0xc5, 0x0b, 0x01, 0x43, 0xe3, 0xf4, 0x56, 0x40,
	0x46, 0x5b, 0x70, 0x83, 0xd9, 0xa6, 0xd5, 0x6f, 0x53, 0xc3, 0x74, 0x1d, 0xcf, 0x33, 0x1c, 0x97,
	0x75, 0x98, 0x6d, 0x98, 0x2e, 0x6d, 0x53, 0xdb, 0x67, 0xc4, 0xf2, 0xa4, 0x17, 0xae, 0x49, 0xb9,
	0x4a, 0x20, 0x56, 0xe7, 0x52, 0x95, 0x81, 0x10, 0xea, 0xc3, 0x92, 0xd9, 0xf7, 0x7c, 0xa7, 0x6b,
	0x50, 0xd7, 0x75, 0x5c, 0x43, 0x26, 0x02, 0xff, 0x9c, 0xd9, 0xb5, 0xca, 0xe5, 0xdf, 0x27, 0x7e,
	0xc0, 0x72, 0x85, 0x83, 0xe9, 0x01, 0xd6, 0xae, 0x80, 0xc2, 0xc8, 0x3c, 0x47, 0x2b, 0xfc, 0x52,
	0x01, 0x74, 0x5e, 0x14, 0x7d, 0x02, 0x33, 0x6d, 0x7a, 0x48, 0xfa, 0x96, 0xf0, 0x4e, 0x76, 0xad,
	0xf1, 0x2f, 0x30, 0xa0, 0x1c, 0xb3, 0x26, 0xdc, 0xa0, 0xf0, 0x3e, 0xe4, 0x62, 0x7b, 0xe7, 0x61,
	0x26, 0x3c, 0xbc, 0xf8, 0x32, 0xe1, 0x12, 0x21, 0x98, 0xb4, 0x98, 0x7d, 0x2c, 0x73, 0x99, 0xff,
	0x2e, 0x35, 0x60, 0x69, 0x9b, 0x75, 0x8e, 0xb4, 0x13, 0xc2, 0x2c, 0x72, 0xc0, 0x2c, 0xe6, 0x9f,
	0x85, 0xe1, 0xd2, 0x66, 0x1e, 0x8f, 0x97, 0x2e, 0xb1, 0x49, 0x87, 0xb6, 0x8d, 0x43, 0xc2, 0x2c,
	0xe7, 0x84, 0xba, 0x61, 0xb8, 0x48, 0xfe, 0xae, 0x60, 0x6f, 0x4a, 0x6e, 0xe9, 0xef, 0x0a, 0xe4,
	0x2a, 0xa4, 0x47, 0xcc, 0x10, 0x6a, 0x1f, 0x32, 0x8e, 0x6d, 0xb4, 0x69, 0x97, 0xd8, 0x6d, 0xe9,
	0x8e, 0x31, 0xf2, 0x65, 0x08, 0xa1, 0x5c, 0xb7, 0xab, 0x5c, 0x7b, 0x7b, 0x02, 0xcf, 0x3a, 0xf2,
	0x37, 0xfa, 0x18, 0xb2, 0x3d, 0xd7, 0x39, 0x61, 0x1e, 0x73, 0x6c, 0xda, 0xe6, 0x87, 0xca, 0xae,
	0xbd, 0xfb, 0x7c, 0xc0, 0x8d, 0x01, 0xc0, 0xf6, 0x04, 0x1e, 0xc6, 0x2b, 0x00, 0xcc, 0x86, 0xdb,
	0x16, 0x6e, 0x41, 0x76, 0x48, 0x12, 0x2d, 0xc1, 0xd4, 0x09, 0xb1, 0xfa, 0xc2, 0xbf, 0x0a, 0x16,
	0x8b, 0x8d, 0x69, 0x98, 0xf4, 0x7a, 0xd4, 0x2c, 0xfd, 0x6a, 0x1a, 0x66, 0xc3, 0x4d, 0xd0, 0xc3,
	0xf3, 0x67, 0x5f, 0x1b, 0xdb, 0xc4, 0xe4, 0x73, 0x3f, 0x49, 0x3a, 0xf7, 0xdb, 0xe3, 0x83, 0x5e,
	0x7c, 0x66, 0xf4, 0x11, 0xcc, 0x5b, 0xc4, 0xa7, 0x9e, 0x6f, 0xb8, 0xf4, 0xd3, 0x3e, 0xf5, 0x44,
	0x2d, 0xcf, 0xae, 0xdd, 0x1b, 0x1f, 0x1d, 0x0b, 0x45, 0x3c, 0x27, 0x80, 0xe4, 0x32, 0xe6, 0xcd,
	0xb5, 0xb8, 0x37, 0x6f, 0xc1, 0x9c, 0xd9, 0x77, 0xdd, 0xa0, 0xfc, 0x0e, 0x7b, 0x35, 0x27, 0x89,
	0x8f, 0x02, 0x5a, 0xe1, 0x8f, 0x69, 0x98, 0x91, 0x58, 0x68, 0x17, 0xa6, 0x3c, 0x9f, 0xf8, 0x42,
	0x70, 0x7e, 0xed, 0x9d, 0xe7, 0x36, 0xae, 0xdc, 0x0c, 0xd4, 0xb1, 0x40, 0x41, 0xef, 0x02, 0x78,
	0x3e, 0x71, 0x7d, 0x23, 0xe8, 0xce, 0xd2, 0x9d, 0x85, 0xb2, 0x68, 0xdd, 0xe5, 0xb0, 0x75, 0x97,
	0x5b, 0x61, 0xeb, 0xc6, 0x19, 0x2e, 0x1d, 0xac, 0xd1, 0xdb, 0xbc, 0x0a, 0x0a, 0xc5, 0xf4, 0xa5,
	0x8a, 0x33, 0xd4, 0x6e, 0x73, 0xb5, 0xa0, 0xf1, 0x78, 0x67, 0xb6, 0x69, 0x38, 0x3d, 0xea, 0xf2,
	0xfe, 0x68, 0xb0, 0xb6, 0x6c, 0x80, 0x2a, 0xe7, 0xd4, 0x43, 0x46, 0xad, 0x8d, 0x34, 0x11, 0x57,
	0xf9, 0x29, 0xbe, 0xc1, 0x1b, 0xcf, 0x15, 0xe0, 0x58, 0x84, 0xe4, 0x8f, 0x15, 0x98, 0xe2, 0x67,
	0x46, 0xaf, 0x42, 0xa9, 0xd9, 0xd2, 0x5a, 0xba, 0x51, 0xd1, 0x1a, 0x5a, 0xa5, 0xd6, 0x7a, 0x62,
	0x60, 0xfd, 0xe1, 0xbe, 0xde, 0x6c, 0x19, 0xfb, 0x7b, 0xcd, 0x86, 0x5e, 0xa9, 0x6d, 0xd6, 0xf4,
	0xaa, 0x3a, 0x81, 0x5e, 0x86, 0x1b, 0x17, 0xc8, 0x55, 0xea, 0xbb, 0x8d, 0x1d, 0xbd, 0xa5, 0x57,
	0x55, 0xe5, 0x19, 0x68, 0xb5, 0x3d, 0xa3, 0x81, 0xeb, 0x5b, 0x58, 0x6f, 0x36, 0xd5, 0x14, 0xba,
	0x09, 0xd7, 0x2e, 0x90, 0xdb, 0xd4, 0x6a, 0x3b, 0x7a, 0x55, 0x4d, 0x6f, 0xcc, 0x43, 0xf8, 0xc1,
	0x8d, 0xae, 0xd3, 0xa6, 0xa5, 0x1f, 0x66, 0x61, 0x6e, 0x2f, 0x3c, 0x16, 0x2f, 0x23, 0x08, 0x26,
	0x87, 0x66, 0x15, 0xfe, 0x3b, 0xa8, 0x75, 0x2e, 0xed, 0x30, 0xc7, 0x16, 0x8d, 0x38, 0x83, 0xc3,
	0x25, 0x7a, 0x05, 0xe6, 0x5d, 0xea, 0x07, 0xdd, 0x21, 0xc8, 0x3f, 0x72, 0x26, 0xda, 0xc8, 0x14,
	0x9e, 0x8b, 0xa8, 0x55, 0x72, 0xe6, 0xa1, 0x0f, 0x20, 0xd3, 0xf5, 0x2d, 0xcf, 0x20, 0x7d, 0xff,
	0x48, 0xf6, 0x8a, 0xcb, 0x3d, 0x3c, 0x3c, 0x88, 0xe0, 0xd9, 0xae, 0x5c, 0xa1, 0x87, 0x90, 0x23,
	0x3d, 0x66, 0x1c, 0xd3, 0x33, 0x01, 0x37, 0xc3, 0xe1, 0x56, 0x2f, 0x85, 0x8b, 0xf7, 0x74, 0x0c,
	0x24, 0x5a, 0xa3, 0xef, 0x29, 0x90, 0x97, 0x6d, 0xcd, 0xa3, 0xc4, 0x35, 0x8f, 0x0c, 0xe2, 0xfb,
	0x2e, 0x3b, 0xe8, 0xfb, 0xd4, 0xcb, 0x4f, 0xf1, 0xd1, 0xe3, 0x83, 0x4b, 0xf1, 0x63, 0x6e, 0x94,
	0x7d, 0xa5, 0xc9, 0xd1, 0xb4, 0x08, 0x4c, 0xb7, 0x7d, 0xf7, 0x6c, 0x23, 0x95, 0x57, 0xf0, 0x8a,
	0x99, 0x28, 0x80, 0x3e, 0x85, 0x2b, 0xe7, 0x4d, 0x98, 0xe5, 0x26, 0x54, 0x9f, 0xd3, 0x84, 0xc4,
	0xcd, 0xb1, 0xea, 0x8d, 0x6e, 0xd9, 0x84, 0x9c, 0x19, 0x74, 0x45, 0xc3, 0xe3, 0x6d, 0x31, 0x3f,
	0xcd, 0x1d, 0xfa, 0xe6, 0xf3, 0xb6, 0x52, 0x9c, 0x35, 0x07, 0x04, 0xb4, 0x03, 0x19, 0x2b, 0x1c,
	0x8c, 0xf2, 0x19, 0x8e, 0x58, 0xbe, 0x14, 0x31, 0x36, 0x4a, 0xe1, 0x01, 0x00, 0x3a, 0x80, 0x2b,
	0x47, 0xac, 0x73, 0x64, 0x90, 0xa1, 0xfe, 0x99, 0x87, 0x31, 0x4b, 0x72, 0x52, 0xe3, 0xc5, 0xea,
	0xd1, 0x08, 0x15, 0xad, 0xc1, 0xf2, 0xf0, 0xa8, 0x6f, 0x04, 0xb3, 0xbe, 0xc1, 0xda, 0x5e, 0x3e,
	0xcb, 0x43, 0x7e, 0x71, 0x98, 0x89, 0xfb, 0x16, 0xad, 0xb5, 0x3d, 0x84, 0x61, 0xce, 0x94, 0x75,
	0xc0, 0xe0, 0xd5, 0x23, 0xf7, 0x5d, 0xaa, 0x47, 0xce, 0x1c, 0x5a, 0x15, 0x6a, 0xf0, 0xd2, 0x33,
	0x82, 0x07, 0xa9, 0x90, 0x3e, 0xa6, 0x67, 0x32, 0x3d, 0x83, 0x9f, 0x83, 0x3e, 0x29, 0x06, 0x0e,
	0xb1, 0x58, 0x4f, 0x3d, 0x50, 0x0a, 0x9f, 0x2b, 0xb0, 0x3c, 0x2e, 0xca, 0x47, 0xc3, 0x28, 0xf3,
	0x6b, 0x1b, 0xff, 0x5c, 0xb0, 0xb5, 0xce, 0x7a, 0x74, 0xc8, 0x92, 0xd2, 0x2f, 0x52, 0xb0, 0x98,
	0x20, 0x82, 0x5e, 0x81, 0x9b, 0x4d, 0x5d, 0xc3, 0x95, 0x6d, 0x43, 0x6b, 0xb5, 0x70, 0x6d, 0x63,
	0xbf, 0xa5, 0x1b, 0xad, 0x27, 0x0d, 0x7d, 0xa4, 0x4e, 0x16, 0xa1, 0x90, 0x2c, 0xd6, 0xd2, 0x3f,
	0x6a, 0xa9, 0x0a, 0xaf, 0x7c, 0x89, 0xfc, 0x0f, 0xf5, 0x27, 0x8f, 0xeb, 0xb8, 0xaa, 0xa6, 0xd0,
	0x35, 0x78, 0x31, 0x59, 0xa4, 0xb6, 0xd7, 0x52, 0xd3, 0xe8, 0x06, 0x5c, 0x4d, 0x66, 0x57, 0xeb,
	0xfb, 0x1b, 0x3b, 0xba, 0x3a, 0x79, 0xb1, 0x0d, 0x1b, 0xf5, 0xfa, 0x8e, 0x3a, 0x85, 0x4a, 0x50,
	0xbc, 0x00, 0x41, 0x6b, 0xe9, 0xad, 0xda, 0xae, 0xae, 0x4e, 0xf3, 0x4a, 0xfe, 0x2c, 0x3b, 0x8d,
	0x9d, 0x5a, 0xb3, 0xa5, 0xce, 0x94, 0x3e, 0x83, 0x8c, 0x2e, 0xe7, 0x7c, 0x2f, 0xb8, 0x44, 0x9e,
	0xd2, 0x03, 0x83, 0xb4, 0xdb, 0x2e, 0xf5, 0xbc, 0xf0, 0x12, 0x79, 0x4a, 0x0f, 0x34, 0x41, 0x09,
	0x6e, 0x02, 0xbc, 0xba, 0x76, 0xdc, 0x9e, 0x19, 0x89, 0x89, 0x60, 0x58, 0x08, 0x18, 0x5b, 0x6e,
	0xcf, 0x0c, 0x65, 0x6f, 0x42, 0x2e, 0x26, 0x26, 0x6e, 0x91, 0xd9, 0xce, 0x40, 0xa4, 0xa4, 0xc1,
	0xf4, 0x0e, 0xeb, 0x32, 0xdf, 0x43, 0xef, 0x40, 0x9e, 0xf0, 0xcb, 0x89, 0x67, 0xf4, 0xa8, 0x6b,
	0x78, 0xd4, 0x74, 0xec, 0xb6, 0x61, 0x05, 0x4c, 0x6e, 0xc6, 0x14, 0x5e, 0x96, 0xfc, 0x06, 0x75,
	0x9b, 0x9c, 0xcb, 0x35, 0x4b, 0x9f, 0x2b, 0x80, 0xb4, 0xc7, 0xcd, 0x86, 0xcb, 0x4e, 0x88, 0x4f,
	0x77, 0x98, 0x7d, 0x5c, 0xb3, 0x0f, 0x1d, 0xf4, 0x16, 0xac, 0x10, 0xcb, 0x72, 0x4e, 0x69, 0xdb,
	0xe8, 0xb9, 0xcc, 0x36, 0x59, 0x8f, 0x58, 0x06, 0x71, 0xed, 0xe0, 0x50, 0x41, 0x8e, 0x2d, 0x49,
	0x6e, 0x23, 0x64, 0x6a, 0xae, 0xed, 0xa1, 0xf7, 0xa0, 0x70, 0xd2, 0x33, 0x8d, 0xf0, 0xe2, 0xc3,
	0xcb, 0x14, 0x33, 0xc5, 0x7d, 0x36, 0x6c, 0x48, 0x2f, 0x9c, 0xf4, 0xcc, 0xd0, 0x63, 0x4d, 0xc1,
	0xe7, 0xf1, 0x59, 0xfa, 0xbe, 0x02, 0x8b, 0xd2, 0x8c, 0xca, 0x50, 0x02, 0xa3, 0x15, 0x98, 0x16,
	0x3d, 0x4c, 0xfa, 0x53, 0xae, 0xd0, 0xc7, 0xa0, 0x92, 0x53, 0x2f, 0x30, 0x2f, 0x50, 0x31, 0xa2,
	0x41, 0x3e, 0xbb, 0x76, 0xff, 0xf2, 0x0e, 0x73, 0xee, 0xc4, 0x78, 0x9e, 0x9c, 0x7a, 0x43, 0xb4,
	0xd2, 0xdf, 0x32, 0x90, 0x89, 0x12, 0x07, 0x5d, 0x85, 0x4c, 0x04, 0x20, 0xed, 0x18, 0x10, 0xd0,
	0x6b, 0xa0, 0x86, 0x8f, 0x1e, 0xc6, 0x09, 0x75, 0xbd, 0xc1, 0xfb, 0xc0, 0x42, 0x48, 0x7f, 0x24,
	0xc8, 0x68, 0x43, 0x0e, 0x2f, 0xe9, 0x31, 0x0b, 0x6d, 0x2c, 0x77, 0xc5, 0xf4, 0x82, 0xde, 0x00,
	0x95, 0x4f, 0x6a, 0xc3, 0xb7, 0x7b, 0x3e, 0x2c, 0xf1, 0x7e, 0xb5, 0xc0, 0x79, 0x43, 0xd7, 0xfa,
	0x4a, 0x38, 0x1e, 0xce, 0xf1, 0x7a, 0x91, 0x58, 0xf2, 0x42, 0x33, 0x83, 0x2d, 0xb1, 0xfc, 0x1d,
	0x1b, 0x0a, 0x93, 0x47, 0xb4, 0xa9, 0x0b, 0x46, 0xb4, 0x6d, 0xc8, 0x84, 0x41, 0xe0, 0xc9, 0x2e,
	0x75, 0xf7, 0xd2, 0xa3, 0x46, 0x79, 0x84, 0x07, 0xca, 0xc1, 0x30, 0x1c, 0x04, 0xee, 0x09, 0x35,
	0x64, 0x10, 0xcc, 0x88, 0x77, 0x17, 0x41, 0xc4, 0x22, 0x14, 0xfe, 0x13, 0xa6, 0x79, 0xa8, 0x07,
	0xfd, 0x37, 0xd8, 0xeb, 0xf6, 0x18, 0xfd, 0x2b, 0x10, 0xc7, 0x52, 0x0d, 0x1d, 0xc3, 0x4a, 0x18,
	0x47, 0x43, 0xcd, 0x83, 0x51, 0x2f, 0x9f, 0xe1, 0x0d, 0xfd, 0xad, 0x4b, 0x01, 0x13, 0x22, 0x17,
	0x2f, 0xf7, 0xce, 0x11, 0x19, 0xf5, 0xd0, 0x7f, 0x40, 0xce, 0x74, 0x69, 0xf0, 0x69, 0xc4, 0xa0,
	0x0c, 0x97, 0x0e, 0xca, 0x59, 0x29, 0xcf, 0x87, 0xe5, 0x6d, 0x40, 0x16, 0xf1, 0xf8, 0x54, 0xc8,
	0x0e, 0x59, 0x08, 0x92, 0xbd, 0x14, 0x44, 0x0d, 0xb4, 0x76, 0xa5, 0x12, 0x47, 0x22, 0x30, 0x27,
	0x9c, 0x6a, 0x04, 0xdf, 0xb8, 0xef, 0xe5, 0x73, 0xfc, 0xb0, 0xef, 0x8f, 0x1f, 0x94, 0x65, 0xf1,
	0x01, 0x9a, 0x5c, 0x5d, 0x4c, 0x2d, 0x39, 0x77, 0x88, 0x84, 0x3a, 0x80, 0xce, 0xb5, 0x6a, 0x2f,
	0x3f, 0xcf, 0xf7, 0x79, 0x90, 0xb4, 0xcf, 0xe8, 0x1b, 0x9e, 0x18, 0x5f, 0xe2, 0xfd, 0x1c, 0x5f,
	0x19, 0xed, 0xf0, 0x1e, 0xda, 0x86, 0x49, 0x9f, 0x74, 0xbc, 0xfc, 0xc2, 0x98, 0xdf, 0x6b, 0x70,
	0x84, 0x16, 0xe9, 0x48, 0xd3, 0x39, 0x02, 0xd2, 0x61, 0x36, 0xec, 0xf2, 0x79, 0x95, 0x7b, 0xf5,
	0xb5, 0xb1, 0x87, 0x04, 0x1c, 0xa9, 0x16, 0x4e, 0xe1, 0xca, 0x39, 0xe7, 0x24, 0x34, 0xf3, 0x9d,
	0xe1, 0x66, 0x3e, 0xce, 0x3b, 0x40, 0x64, 0xf8, 0x30, 0xfa, 0xf0, 0x28, 0xf1, 0x0e, 0x64, 0xa2,
	0x23, 0x3d, 0xcf, 0x0c, 0x52, 0xfa, 0x75, 0x0a, 0x96, 0x13, 0xd1, 0x13, 0x0b, 0x8e, 0x72, 0x71,
	0xc1, 0xc1, 0x61, 0xc1, 0x49, 0xf3, 0x82, 0xf3, 0xfe, 0x77, 0x3b, 0x53, 0x79, 0x8c, 0xfa, 0x93,
	0x4a, 0xae, 0x3f, 0xa5, 0xcf, 0xc2, 0xeb, 0xdd, 0x32, 0x5c, 0x11, 0x17, 0xad, 0xf8, 0x94, 0xa2,
	0x42, 0x4e, 0x90, 0xb5, 0x6a, 0xb5, 0xb6, 0xb7, 0xa5, 0x2a, 0x43, 0x94, 0x4a, 0xab, 0xf6, 0x48,
	0x57, 0x53, 0xe8, 0x0a, 0xcc, 0x09, 0x4a, 0x43, 0x6b, 0x36, 0x03, 0x52, 0x1a, 0x21, 0x98, 0x17,
	0x24, 0xac, 0xef, 0xd6, 0x1f, 0x05, 0x8a, 0x93, 0x03, 0x45, 0x79, 0x73, 0x9b, 0x2a, 0xfd, 0x4c,
	0x81, 0x79, 0xfd, 0x7f, 0x7a, 0x8e, 0xeb, 0x37, 0x99, 0x7d, 0xfc, 0xac, 0xab, 0x5a, 0xf8, 0x54,
	0x99, 0x8a, 0x3d, 0x55, 0xa2, 0x35, 0x48, 0x79, 0xf7, 0x65, 0x87, 0x28, 0x25, 0x39, 0xcf, 0x63,
	0xf6, 0x71, 0xe0, 0xb7, 0xe6, 0x7d, 0xde, 0x15, 0x52, 0xde, 0x7d, 0xf4, 0x36, 0xa4, 0x3b, 0xa6,
	0x27, 0x6f, 0x6c, 0xb7, 0x9e, 0xa5, 0xb4, 0x55, 0x69, 0x72, 0xad, 0x40, 0xbe, 0xf4, 0x87, 0x49,
	0x80, 0x81, 0xad, 0x89, 0x76, 0x3e, 0x47, 0x73, 0xab, 0xc4, 0x3f, 0xfc, 0x77, 0xeb, 0x34, 0x15,
	0xd9, 0x21, 0x27, 0xc7, 0xbc, 0x2d, 0xc6, 0x5d, 0x2d, 0x5b, 0xe4, 0x07, 0x30, 0x7d, 0x44, 0x89,
	0xe5, 0x1f, 0xf1, 0x16, 0x35, 0x3f, 0xc6, 0x1b, 0xd3, 0x00, 0xa6, 0xbc, 0xcd, 0x35, 0xb1, 0x44,
	0x08, 0x5a, 0x50, 0xfc, 0x09, 0x75, 0x5a, 0xb4, 0x20, 0x3a, 0xfc, 0xc8, 0xf8, 0x10, 0x5e, 0x90,
	0x2f, 0x45, 0x6d, 0xe2, 0x13, 0x83, 0x72, 0x34, 0x51, 0x9a, 0x67, 0x2e, 0x2d, 0xcd, 0x4b, 0x42,
	0xb5, 0x4a, 0x7c, 0x22, 0xcc, 0xe0, 0xe5, 0xb9, 0x0e, 0x2b, 0xbc, 0xd0, 0x0b, 0x33, 0x0c, 0xf3,
	0x88, 0x9a, 0xc7, 0x02, 0x71, 0xf6, 0x52, 0xc4, 0xc5, 0x40, 0x53, 0x9c, 0xa3, 0x12, 0xe8, 0x05,
	0x9c, 0x92, 0x03, 0xd3, 0x82, 0x84, 0x56, 0x00, 0x6d, 0xeb, 0xda, 0x4e, 0x6b, 0x7b, 0x24, 0x2f,
	0xe6, 0x20, 0x23, 0xe9, 0xf5, 0x0f, 0x55, 0x05, 0xbd, 0x08, 0xcb, 0x72, 0xa9, 0x63, 0x5c, 0xc7,
	0xc1, 0x00, 0xae, 0xe3, 0x3d, 0x6d, 0x47, 0x4d, 0xa1, 0x5b, 0x70, 0x3d, 0xc6, 0xda, 0x6f, 0xea,
	0xd8, 0xa8, 0xd4, 0xf7, 0x36, 0x6b, 0x5b, 0xfb, 0x58, 0x6b, 0xd5, 0xea, 0x7b, 0x6a, 0xba, 0xf4,
	0x85, 0x02, 0x73, 0xbb, 0xac, 0x23, 0xd2, 0x92, 0x27, 0xc2, 0x1a, 0x2c, 0x77, 0x43, 0xc2, 0x60,
	0x4e, 0x64, 0xe1, 0x5f, 0x27, 0x16, 0x23, 0x66, 0x38, 0x0c, 0xd4, 0xda, 0xe8, 0xbf, 0x61, 0xce,
	0x77, 0x0c, 0xfe, 0xc9, 0xc4, 0xd5, 0x6d, 0xdc, 0x17, 0xbe, 0x68, 0xeb, 0x96, 0x53, 0x09, 0xb8,
	0x81, 0x05, 0xdb, 0x13, 0x38, 0xeb, 0x0f, 0x96, 0xd1, 0x23, 0xa5, 0x05, 0x4b, 0x49, 0xe2, 0x41,
	0xf4, 0xcb, 0xd8, 0x1f, 0x9d, 0xff, 0x16, 0x04, 0x7d, 0x6f, 0x78, 0x0a, 0xf4, 0x89, 0xdb, 0xa1,
	0xfe, 0x90, 0xa8, 0x4c, 0x14, 0x41, 0x8f, 0x44, 0x4b, 0xbf, 0x9b, 0x86, 0x4c, 0xb4, 0x5d, 0x30,
	0xe9, 0x0f, 0x9c, 0x12, 0xf9, 0x22, 0x1b, 0xd1, 0x6a, 0xed, 0x68, 0x6c, 0x4c, 0x8d, 0x39, 0x36,
	0xc6, 0xbc, 0x2e, 0x73, 0x62, 0x33, 0x9e, 0x9d, 0x6f, 0x8e, 0x0f, 0x12, 0x2f, 0xc5, 0xbb, 0x30,
	0xeb, 0xd2, 0x9e, 0xc5, 0x4c, 0x12, 0xd4, 0x9b, 0xf4, 0x58, 0xcf, 0xa1, 0x11, 0x14, 0x16, 0x9a,
	0x38, 0x82, 0x40, 0xf7, 0x60, 0x49, 0xfe, 0x0e, 0x26, 0xa2, 0x53, 0xc7, 0x3d, 0x3e, 0xb4, 0x9c,
	0x53, 0x8f, 0x27, 0x6e, 0x1a, 0x2f, 0x0e, 0x78, 0x8f, 0x43, 0x16, 0xaa, 0x42, 0x31, 0x49, 0xc5,
	0x70, 0x69, 0x97, 0x30, 0x9b, 0xd9, 0x1d, 0x9e, 0xa2, 0x69, 0x7c, 0x35, 0x41, 0x19, 0x87, 0x32,
	0xe8, 0x36, 0x2c, 0x1c, 0x12, 0x66, 0xf5, 0x5d, 0x1a, 0x65, 0xb6, 0x18, 0x2e, 0xe7, 0x25, 0x59,
	0xe6, 0x76, 0xe9, 0x27, 0xe9, 0xb0, 0x9d, 0x5c, 0x87, 0x97, 0x44, 0xb1, 0xdf, 0xad, 0x6d, 0x89,
	0x28, 0x1f, 0x49, 0xa0, 0xe0, 0x96, 0x3c, 0x22, 0x30, 0xf8, 0xd5, 0x6c, 0x69, 0x58, 0xbc, 0x13,
	0xfe, 0x1b, 0xdc, 0x1e, 0x15, 0xc3, 0x7a, 0x63, 0xa7, 0x56, 0x11, 0xbf, 0xe3, 0x8f, 0x85, 0x77,
	0xe0, 0xe5, 0x51, 0xe1, 0xc7, 0x5a, 0xad, 0x55, 0xdb, 0xdb, 0x32, 0x36, 0xeb, 0xd8, 0xd8, 0xd6,
	0xf6, 0xaa, 0xf5, 0x47, 0x3a, 0x56, 0xd3, 0x49, 0x92, 0x21, 0x37, 0x86, 0x39, 0x89, 0xee, 0xc2,
	0xab, 0xe7, 0x0d, 0xd0, 0xaa, 0x4f, 0x38, 0x22, 0x4f, 0x63, 0xbc, 0x2b, 0xb2, 0x78, 0x0a, 0x5d,
	0x85, 0xfc, 0xa8, 0x6c, 0xf8, 0xe6, 0xa9, 0x4e, 0xa3, 0x02, 0xac, 0x8c, 0x72, 0x65, 0x27, 0x9c,
	0x49, 0xf2, 0x86, 0xb6, 0x51, 0xc7, 0xf1, 0xd7, 0xd0, 0x59, 0xf4, 0x12, 0xbc, 0x90, 0x28, 0xa6,
	0x57, 0xd5, 0x0c, 0xba, 0x0d, 0xb7, 0xce, 0xef, 0xce, 0xed, 0x8b, 0xa1, 0x40, 0xe9, 0x47, 0x29,
	0x50, 0x47, 0xc3, 0x0c, 0xcd, 0x43, 0x2a, 0x4a, 0xa8, 0x14, 0x6b, 0x0f, 0x9e, 0xca, 0x53, 0x63,
	0x3e, 0x95, 0x8f, 0x22, 0xc6, 0x52, 0xa1, 0xf4, 0xd3, 0xe8, 0x1d, 0xf9, 0x1a, 0xbc, 0x18, 0x8e,
	0x06, 0xfc, 0x3b, 0x8e, 0xc4, 0x45, 0x1e, 0x96, 0xe2, 0x6c, 0x39, 0x66, 0x28, 0x03, 0x1f, 0x85,
	0x1c, 0x39, 0x6e, 0x18, 0xf5, 0xfd, 0x96, 0x51, 0xdf, 0x34, 0x9a, 0x4f, 0xf6, 0x2a, 0xc3, 0x2f,
	0xc6, 0xa3, 0x62, 0xb5, 0x3d, 0x21, 0x92, 0x1e, 0xb8, 0x31, 0xda, 0x63, 0x23, 0xf8, 0xf8, 0x7b,
	0x7a, 0x55, 0x9d, 0xdc, 0xf8, 0xb3, 0xf2, 0xe5, 0xd7, 0xc5, 0x89, 0xaf, 0xbe, 0x2e, 0x4e, 0x7c,
	0xfb, 0x75, 0x51, 0xf9, 0xbf, 0xa7, 0x45, 0xe5, 0x8b, 0xa7, 0x45, 0xe5, 0xb7, 0x4f, 0x8b, 0xca,
	0x97, 0x4f, 0x8b, 0xca, 0x9f, 0x9e, 0x16, 0x95, 0xbf, 0x3c, 0x2d, 0x4e, 0x7c, 0xfb, 0xb4, 0xa8,
	0xfc, 0xe0, 0x9b, 0xe2, 0xc4, 0x97, 0xdf, 0x14, 0x27, 0xbe, 0xfa, 0xa6, 0x38, 0x01, 0x25, 0xe6,
	0x5c, 0xe6, 0xa2, 0x8d, 0x9c, 0xcc, 0x93, 0x46, 0xd0, 0x86, 0x1a, 0xca, 0x7f, 0xad, 0x76, 0x86,
	0x74, 0x98, 0x73, 0xc1, 0x7f, 0x1a, 0xbc, 0x17, 0x2d, 0x7e, 0x9e, 0xba, 0xd9, 0x92, 0xe2, 0xcc,
	0x29, 0x6b, 0x3d, 0x56, 0xe6, 0xe5, 0x77, 0x68, 0x44, 0x7f, 0x74, 0xef, 0xaf, 0xa9, 0x57, 0x06,
	0x32, 0xeb, 0xeb, 0x5a, 0x8f, 0xad, 0xaf, 0x73, 0xa9, 0xf5, 0xf5, 0x48, 0x6c, 0x7d, 0xfd, 0xd1,
	0xbd, 0x83, 0x69, 0xde, 0x0c, 0xef, 0xff, 0x23, 0x00, 0x00, 0xff, 0xff, 0xf5, 0xfe, 0xc1, 0xf3,
	0xe9, 0x20, 0x00, 0x00,
}

func (x Capacity_Request_State) String() string {
	s, ok := Capacity_Request_State_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NamespaceSpec_SearchAttributeType) String() string {
	s, ok := NamespaceSpec_SearchAttributeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NamespaceRegionStatus_State) String() string {
	s, ok := NamespaceRegionStatus_State_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ExportSink_Health) String() string {
	s, ok := ExportSink_Health_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Migration_State) String() string {
	s, ok := Migration_State_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MigrationReplica_State) String() string {
	s, ok := MigrationReplica_State_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *CertificateFilterSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CertificateFilterSpec)
	if !ok {
		that2, ok := that.(CertificateFilterSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CommonName != that1.CommonName {
		return false
	}
	if this.Organization != that1.Organization {
		return false
	}
	if this.OrganizationalUnit != that1.OrganizationalUnit {
		return false
	}
	if this.SubjectAlternativeName != that1.SubjectAlternativeName {
		return false
	}
	return true
}
func (this *MtlsAuthSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MtlsAuthSpec)
	if !ok {
		that2, ok := that.(MtlsAuthSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AcceptedClientCaDeprecated != that1.AcceptedClientCaDeprecated {
		return false
	}
	if !bytes.Equal(this.AcceptedClientCa, that1.AcceptedClientCa) {
		return false
	}
	if len(this.CertificateFilters) != len(that1.CertificateFilters) {
		return false
	}
	for i := range this.CertificateFilters {
		if !this.CertificateFilters[i].Equal(that1.CertificateFilters[i]) {
			return false
		}
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (this *ApiKeyAuthSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApiKeyAuthSpec)
	if !ok {
		that2, ok := that.(ApiKeyAuthSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (this *LifecycleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LifecycleSpec)
	if !ok {
		that2, ok := that.(LifecycleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnableDeleteProtection != that1.EnableDeleteProtection {
		return false
	}
	return true
}
func (this *CodecServerSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodecServerSpec)
	if !ok {
		that2, ok := that.(CodecServerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Endpoint != that1.Endpoint {
		return false
	}
	if this.PassAccessToken != that1.PassAccessToken {
		return false
	}
	if this.IncludeCrossOriginCredentials != that1.IncludeCrossOriginCredentials {
		return false
	}
	if !this.CustomErrorMessage.Equal(that1.CustomErrorMessage) {
		return false
	}
	return true
}
func (this *CodecServerSpec_CustomErrorMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodecServerSpec_CustomErrorMessage)
	if !ok {
		that2, ok := that.(CodecServerSpec_CustomErrorMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Default.Equal(that1.Default) {
		return false
	}
	return true
}
func (this *CodecServerSpec_CustomErrorMessage_ErrorMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodecServerSpec_CustomErrorMessage_ErrorMessage)
	if !ok {
		that2, ok := that.(CodecServerSpec_CustomErrorMessage_ErrorMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.Link != that1.Link {
		return false
	}
	return true
}
func (this *HighAvailabilitySpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HighAvailabilitySpec)
	if !ok {
		that2, ok := that.(HighAvailabilitySpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DisableManagedFailover != that1.DisableManagedFailover {
		return false
	}
	return true
}
func (this *CapacitySpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CapacitySpec)
	if !ok {
		that2, ok := that.(CapacitySpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Spec == nil {
		if this.Spec != nil {
			return false
		}
	} else if this.Spec == nil {
		return false
	} else if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *CapacitySpec_OnDemand_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CapacitySpec_OnDemand_)
	if !ok {
		that2, ok := that.(CapacitySpec_OnDemand_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnDemand.Equal(that1.OnDemand) {
		return false
	}
	return true
}
func (this *CapacitySpec_Provisioned_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CapacitySpec_Provisioned_)
	if !ok {
		that2, ok := that.(CapacitySpec_Provisioned_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Provisioned.Equal(that1.Provisioned) {
		return false
	}
	return true
}
func (this *CapacitySpec_OnDemand) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CapacitySpec_OnDemand)
	if !ok {
		that2, ok := that.(CapacitySpec_OnDemand)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CapacitySpec_Provisioned) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CapacitySpec_Provisioned)
	if !ok {
		that2, ok := that.(CapacitySpec_Provisioned)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Capacity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Capacity)
	if !ok {
		that2, ok := that.(Capacity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CurrentMode == nil {
		if this.CurrentMode != nil {
			return false
		}
	} else if this.CurrentMode == nil {
		return false
	} else if !this.CurrentMode.Equal(that1.CurrentMode) {
		return false
	}
	if !this.LatestRequest.Equal(that1.LatestRequest) {
		return false
	}
	return true
}
func (this *Capacity_OnDemand_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Capacity_OnDemand_)
	if !ok {
		that2, ok := that.(Capacity_OnDemand_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnDemand.Equal(that1.OnDemand) {
		return false
	}
	return true
}
func (this *Capacity_Provisioned_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Capacity_Provisioned_)
	if !ok {
		that2, ok := that.(Capacity_Provisioned_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Provisioned.Equal(that1.Provisioned) {
		return false
	}
	return true
}
func (this *Capacity_OnDemand) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Capacity_OnDemand)
	if !ok {
		that2, ok := that.(Capacity_OnDemand)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Capacity_Provisioned) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Capacity_Provisioned)
	if !ok {
		that2, ok := that.(Capacity_Provisioned)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CurrentValue != that1.CurrentValue {
		return false
	}
	return true
}
func (this *Capacity_Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Capacity_Request)
	if !ok {
		that2, ok := that.(Capacity_Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.StartTime.Equal(that1.StartTime) {
		return false
	}
	if !this.EndTime.Equal(that1.EndTime) {
		return false
	}
	if this.AsyncOperationId != that1.AsyncOperationId {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *NamespaceSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceSpec)
	if !ok {
		that2, ok := that.(NamespaceSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Regions) != len(that1.Regions) {
		return false
	}
	for i := range this.Regions {
		if this.Regions[i] != that1.Regions[i] {
			return false
		}
	}
	if this.RetentionDays != that1.RetentionDays {
		return false
	}
	if !this.MtlsAuth.Equal(that1.MtlsAuth) {
		return false
	}
	if !this.ApiKeyAuth.Equal(that1.ApiKeyAuth) {
		return false
	}
	if len(this.CustomSearchAttributes) != len(that1.CustomSearchAttributes) {
		return false
	}
	for i := range this.CustomSearchAttributes {
		if this.CustomSearchAttributes[i] != that1.CustomSearchAttributes[i] {
			return false
		}
	}
	if len(this.SearchAttributes) != len(that1.SearchAttributes) {
		return false
	}
	for i := range this.SearchAttributes {
		if this.SearchAttributes[i] != that1.SearchAttributes[i] {
			return false
		}
	}
	if !this.CodecServer.Equal(that1.CodecServer) {
		return false
	}
	if !this.Lifecycle.Equal(that1.Lifecycle) {
		return false
	}
	if !this.HighAvailability.Equal(that1.HighAvailability) {
		return false
	}
	if len(this.ConnectivityRuleIds) != len(that1.ConnectivityRuleIds) {
		return false
	}
	for i := range this.ConnectivityRuleIds {
		if this.ConnectivityRuleIds[i] != that1.ConnectivityRuleIds[i] {
			return false
		}
	}
	if !this.CapacitySpec.Equal(that1.CapacitySpec) {
		return false
	}
	return true
}
func (this *Endpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Endpoints)
	if !ok {
		that2, ok := that.(Endpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WebAddress != that1.WebAddress {
		return false
	}
	if this.MtlsGrpcAddress != that1.MtlsGrpcAddress {
		return false
	}
	if this.GrpcAddress != that1.GrpcAddress {
		return false
	}
	return true
}
func (this *Limits) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Limits)
	if !ok {
		that2, ok := that.(Limits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActionsPerSecondLimit != that1.ActionsPerSecondLimit {
		return false
	}
	return true
}
func (this *AWSPrivateLinkInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSPrivateLinkInfo)
	if !ok {
		that2, ok := that.(AWSPrivateLinkInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AllowedPrincipalArns) != len(that1.AllowedPrincipalArns) {
		return false
	}
	for i := range this.AllowedPrincipalArns {
		if this.AllowedPrincipalArns[i] != that1.AllowedPrincipalArns[i] {
			return false
		}
	}
	if len(this.VpcEndpointServiceNames) != len(that1.VpcEndpointServiceNames) {
		return false
	}
	for i := range this.VpcEndpointServiceNames {
		if this.VpcEndpointServiceNames[i] != that1.VpcEndpointServiceNames[i] {
			return false
		}
	}
	return true
}
func (this *PrivateConnectivity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrivateConnectivity)
	if !ok {
		that2, ok := that.(PrivateConnectivity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if !this.AwsPrivateLink.Equal(that1.AwsPrivateLink) {
		return false
	}
	return true
}
func (this *Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Namespace)
	if !ok {
		that2, ok := that.(Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.StateDeprecated != that1.StateDeprecated {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.AsyncOperationId != that1.AsyncOperationId {
		return false
	}
	if !this.Endpoints.Equal(that1.Endpoints) {
		return false
	}
	if this.ActiveRegion != that1.ActiveRegion {
		return false
	}
	if !this.Limits.Equal(that1.Limits) {
		return false
	}
	if len(this.PrivateConnectivities) != len(that1.PrivateConnectivities) {
		return false
	}
	for i := range this.PrivateConnectivities {
		if !this.PrivateConnectivities[i].Equal(that1.PrivateConnectivities[i]) {
			return false
		}
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.LastModifiedTime.Equal(that1.LastModifiedTime) {
		return false
	}
	if len(this.RegionStatus) != len(that1.RegionStatus) {
		return false
	}
	for i := range this.RegionStatus {
		if !this.RegionStatus[i].Equal(that1.RegionStatus[i]) {
			return false
		}
	}
	if len(this.ConnectivityRules) != len(that1.ConnectivityRules) {
		return false
	}
	for i := range this.ConnectivityRules {
		if !this.ConnectivityRules[i].Equal(that1.ConnectivityRules[i]) {
			return false
		}
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !this.Capacity.Equal(that1.Capacity) {
		return false
	}
	return true
}
func (this *NamespaceRegionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRegionStatus)
	if !ok {
		that2, ok := that.(NamespaceRegionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StateDeprecated != that1.StateDeprecated {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.AsyncOperationId != that1.AsyncOperationId {
		return false
	}
	return true
}
func (this *ExportSinkSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExportSinkSpec)
	if !ok {
		that2, ok := that.(ExportSinkSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if !this.S3.Equal(that1.S3) {
		return false
	}
	if !this.Gcs.Equal(that1.Gcs) {
		return false
	}
	return true
}
func (this *ExportSink) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExportSink)
	if !ok {
		that2, ok := that.(ExportSink)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.Health != that1.Health {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	if !this.LatestDataExportTime.Equal(that1.LatestDataExportTime) {
		return false
	}
	if !this.LastHealthCheckTime.Equal(that1.LastHealthCheckTime) {
		return false
	}
	return true
}
func (this *MigrationSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MigrationSpec)
	if !ok {
		that2, ok := that.(MigrationSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MigrationEndpointId != that1.MigrationEndpointId {
		return false
	}
	if that1.Spec == nil {
		if this.Spec != nil {
			return false
		}
	} else if this.Spec == nil {
		return false
	} else if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *MigrationSpec_ToCloudSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MigrationSpec_ToCloudSpec)
	if !ok {
		that2, ok := that.(MigrationSpec_ToCloudSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ToCloudSpec.Equal(that1.ToCloudSpec) {
		return false
	}
	return true
}
func (this *MigrationToCloudSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MigrationToCloudSpec)
	if !ok {
		that2, ok := that.(MigrationToCloudSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SourceNamespace != that1.SourceNamespace {
		return false
	}
	if this.TargetNamespace != that1.TargetNamespace {
		return false
	}
	return true
}
func (this *Migration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Migration)
	if !ok {
		that2, ok := that.(Migration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MigrationId != that1.MigrationId {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if len(this.Replicas) != len(that1.Replicas) {
		return false
	}
	for i := range this.Replicas {
		if !this.Replicas[i].Equal(that1.Replicas[i]) {
			return false
		}
	}
	if this.ReplicatedWorkflows != that1.ReplicatedWorkflows {
		return false
	}
	if this.ReplicatedWorkflowsRemaining != that1.ReplicatedWorkflowsRemaining {
		return false
	}
	if this.FailureMessage != that1.FailureMessage {
		return false
	}
	return true
}
func (this *MigrationReplica) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MigrationReplica)
	if !ok {
		that2, ok := that.(MigrationReplica)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *CertificateFilterSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&namespace.CertificateFilterSpec{")
	s = append(s, "CommonName: "+fmt.Sprintf("%#v", this.CommonName)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "OrganizationalUnit: "+fmt.Sprintf("%#v", this.OrganizationalUnit)+",\n")
	s = append(s, "SubjectAlternativeName: "+fmt.Sprintf("%#v", this.SubjectAlternativeName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MtlsAuthSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&namespace.MtlsAuthSpec{")
	s = append(s, "AcceptedClientCaDeprecated: "+fmt.Sprintf("%#v", this.AcceptedClientCaDeprecated)+",\n")
	s = append(s, "AcceptedClientCa: "+fmt.Sprintf("%#v", this.AcceptedClientCa)+",\n")
	if this.CertificateFilters != nil {
		s = append(s, "CertificateFilters: "+fmt.Sprintf("%#v", this.CertificateFilters)+",\n")
	}
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApiKeyAuthSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.ApiKeyAuthSpec{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LifecycleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.LifecycleSpec{")
	s = append(s, "EnableDeleteProtection: "+fmt.Sprintf("%#v", this.EnableDeleteProtection)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodecServerSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&namespace.CodecServerSpec{")
	s = append(s, "Endpoint: "+fmt.Sprintf("%#v", this.Endpoint)+",\n")
	s = append(s, "PassAccessToken: "+fmt.Sprintf("%#v", this.PassAccessToken)+",\n")
	s = append(s, "IncludeCrossOriginCredentials: "+fmt.Sprintf("%#v", this.IncludeCrossOriginCredentials)+",\n")
	if this.CustomErrorMessage != nil {
		s = append(s, "CustomErrorMessage: "+fmt.Sprintf("%#v", this.CustomErrorMessage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodecServerSpec_CustomErrorMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.CodecServerSpec_CustomErrorMessage{")
	if this.Default != nil {
		s = append(s, "Default: "+fmt.Sprintf("%#v", this.Default)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodecServerSpec_CustomErrorMessage_ErrorMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.CodecServerSpec_CustomErrorMessage_ErrorMessage{")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "Link: "+fmt.Sprintf("%#v", this.Link)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HighAvailabilitySpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.HighAvailabilitySpec{")
	s = append(s, "DisableManagedFailover: "+fmt.Sprintf("%#v", this.DisableManagedFailover)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CapacitySpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.CapacitySpec{")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CapacitySpec_OnDemand_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&namespace.CapacitySpec_OnDemand_{` +
		`OnDemand:` + fmt.Sprintf("%#v", this.OnDemand) + `}`}, ", ")
	return s
}
func (this *CapacitySpec_Provisioned_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&namespace.CapacitySpec_Provisioned_{` +
		`Provisioned:` + fmt.Sprintf("%#v", this.Provisioned) + `}`}, ", ")
	return s
}
func (this *CapacitySpec_OnDemand) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&namespace.CapacitySpec_OnDemand{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CapacitySpec_Provisioned) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.CapacitySpec_Provisioned{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Capacity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&namespace.Capacity{")
	if this.CurrentMode != nil {
		s = append(s, "CurrentMode: "+fmt.Sprintf("%#v", this.CurrentMode)+",\n")
	}
	if this.LatestRequest != nil {
		s = append(s, "LatestRequest: "+fmt.Sprintf("%#v", this.LatestRequest)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Capacity_OnDemand_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&namespace.Capacity_OnDemand_{` +
		`OnDemand:` + fmt.Sprintf("%#v", this.OnDemand) + `}`}, ", ")
	return s
}
func (this *Capacity_Provisioned_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&namespace.Capacity_Provisioned_{` +
		`Provisioned:` + fmt.Sprintf("%#v", this.Provisioned) + `}`}, ", ")
	return s
}
func (this *Capacity_OnDemand) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&namespace.Capacity_OnDemand{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Capacity_Provisioned) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.Capacity_Provisioned{")
	s = append(s, "CurrentValue: "+fmt.Sprintf("%#v", this.CurrentValue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Capacity_Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&namespace.Capacity_Request{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.StartTime != nil {
		s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	}
	if this.EndTime != nil {
		s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	}
	s = append(s, "AsyncOperationId: "+fmt.Sprintf("%#v", this.AsyncOperationId)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&namespace.NamespaceSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Regions: "+fmt.Sprintf("%#v", this.Regions)+",\n")
	s = append(s, "RetentionDays: "+fmt.Sprintf("%#v", this.RetentionDays)+",\n")
	if this.MtlsAuth != nil {
		s = append(s, "MtlsAuth: "+fmt.Sprintf("%#v", this.MtlsAuth)+",\n")
	}
	if this.ApiKeyAuth != nil {
		s = append(s, "ApiKeyAuth: "+fmt.Sprintf("%#v", this.ApiKeyAuth)+",\n")
	}
	keysForCustomSearchAttributes := make([]string, 0, len(this.CustomSearchAttributes))
	for k, _ := range this.CustomSearchAttributes {
		keysForCustomSearchAttributes = append(keysForCustomSearchAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCustomSearchAttributes)
	mapStringForCustomSearchAttributes := "map[string]string{"
	for _, k := range keysForCustomSearchAttributes {
		mapStringForCustomSearchAttributes += fmt.Sprintf("%#v: %#v,", k, this.CustomSearchAttributes[k])
	}
	mapStringForCustomSearchAttributes += "}"
	if this.CustomSearchAttributes != nil {
		s = append(s, "CustomSearchAttributes: "+mapStringForCustomSearchAttributes+",\n")
	}
	keysForSearchAttributes := make([]string, 0, len(this.SearchAttributes))
	for k, _ := range this.SearchAttributes {
		keysForSearchAttributes = append(keysForSearchAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSearchAttributes)
	mapStringForSearchAttributes := "map[string]NamespaceSpec_SearchAttributeType{"
	for _, k := range keysForSearchAttributes {
		mapStringForSearchAttributes += fmt.Sprintf("%#v: %#v,", k, this.SearchAttributes[k])
	}
	mapStringForSearchAttributes += "}"
	if this.SearchAttributes != nil {
		s = append(s, "SearchAttributes: "+mapStringForSearchAttributes+",\n")
	}
	if this.CodecServer != nil {
		s = append(s, "CodecServer: "+fmt.Sprintf("%#v", this.CodecServer)+",\n")
	}
	if this.Lifecycle != nil {
		s = append(s, "Lifecycle: "+fmt.Sprintf("%#v", this.Lifecycle)+",\n")
	}
	if this.HighAvailability != nil {
		s = append(s, "HighAvailability: "+fmt.Sprintf("%#v", this.HighAvailability)+",\n")
	}
	s = append(s, "ConnectivityRuleIds: "+fmt.Sprintf("%#v", this.ConnectivityRuleIds)+",\n")
	if this.CapacitySpec != nil {
		s = append(s, "CapacitySpec: "+fmt.Sprintf("%#v", this.CapacitySpec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Endpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&namespace.Endpoints{")
	s = append(s, "WebAddress: "+fmt.Sprintf("%#v", this.WebAddress)+",\n")
	s = append(s, "MtlsGrpcAddress: "+fmt.Sprintf("%#v", this.MtlsGrpcAddress)+",\n")
	s = append(s, "GrpcAddress: "+fmt.Sprintf("%#v", this.GrpcAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Limits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&namespace.Limits{")
	s = append(s, "ActionsPerSecondLimit: "+fmt.Sprintf("%#v", this.ActionsPerSecondLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSPrivateLinkInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.AWSPrivateLinkInfo{")
	s = append(s, "AllowedPrincipalArns: "+fmt.Sprintf("%#v", this.AllowedPrincipalArns)+",\n")
	s = append(s, "VpcEndpointServiceNames: "+fmt.Sprintf("%#v", this.VpcEndpointServiceNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PrivateConnectivity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.PrivateConnectivity{")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	if this.AwsPrivateLink != nil {
		s = append(s, "AwsPrivateLink: "+fmt.Sprintf("%#v", this.AwsPrivateLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Namespace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&namespace.Namespace{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "StateDeprecated: "+fmt.Sprintf("%#v", this.StateDeprecated)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "AsyncOperationId: "+fmt.Sprintf("%#v", this.AsyncOperationId)+",\n")
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+fmt.Sprintf("%#v", this.Endpoints)+",\n")
	}
	s = append(s, "ActiveRegion: "+fmt.Sprintf("%#v", this.ActiveRegion)+",\n")
	if this.Limits != nil {
		s = append(s, "Limits: "+fmt.Sprintf("%#v", this.Limits)+",\n")
	}
	if this.PrivateConnectivities != nil {
		s = append(s, "PrivateConnectivities: "+fmt.Sprintf("%#v", this.PrivateConnectivities)+",\n")
	}
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.LastModifiedTime != nil {
		s = append(s, "LastModifiedTime: "+fmt.Sprintf("%#v", this.LastModifiedTime)+",\n")
	}
	keysForRegionStatus := make([]string, 0, len(this.RegionStatus))
	for k, _ := range this.RegionStatus {
		keysForRegionStatus = append(keysForRegionStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRegionStatus)
	mapStringForRegionStatus := "map[string]*NamespaceRegionStatus{"
	for _, k := range keysForRegionStatus {
		mapStringForRegionStatus += fmt.Sprintf("%#v: %#v,", k, this.RegionStatus[k])
	}
	mapStringForRegionStatus += "}"
	if this.RegionStatus != nil {
		s = append(s, "RegionStatus: "+mapStringForRegionStatus+",\n")
	}
	if this.ConnectivityRules != nil {
		s = append(s, "ConnectivityRules: "+fmt.Sprintf("%#v", this.ConnectivityRules)+",\n")
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.Capacity != nil {
		s = append(s, "Capacity: "+fmt.Sprintf("%#v", this.Capacity)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRegionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&namespace.NamespaceRegionStatus{")
	s = append(s, "StateDeprecated: "+fmt.Sprintf("%#v", this.StateDeprecated)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "AsyncOperationId: "+fmt.Sprintf("%#v", this.AsyncOperationId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExportSinkSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&namespace.ExportSinkSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	if this.S3 != nil {
		s = append(s, "S3: "+fmt.Sprintf("%#v", this.S3)+",\n")
	}
	if this.Gcs != nil {
		s = append(s, "Gcs: "+fmt.Sprintf("%#v", this.Gcs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExportSink) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&namespace.ExportSink{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "Health: "+fmt.Sprintf("%#v", this.Health)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	if this.LatestDataExportTime != nil {
		s = append(s, "LatestDataExportTime: "+fmt.Sprintf("%#v", this.LatestDataExportTime)+",\n")
	}
	if this.LastHealthCheckTime != nil {
		s = append(s, "LastHealthCheckTime: "+fmt.Sprintf("%#v", this.LastHealthCheckTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MigrationSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.MigrationSpec{")
	s = append(s, "MigrationEndpointId: "+fmt.Sprintf("%#v", this.MigrationEndpointId)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MigrationSpec_ToCloudSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&namespace.MigrationSpec_ToCloudSpec{` +
		`ToCloudSpec:` + fmt.Sprintf("%#v", this.ToCloudSpec) + `}`}, ", ")
	return s
}
func (this *MigrationToCloudSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.MigrationToCloudSpec{")
	s = append(s, "SourceNamespace: "+fmt.Sprintf("%#v", this.SourceNamespace)+",\n")
	s = append(s, "TargetNamespace: "+fmt.Sprintf("%#v", this.TargetNamespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Migration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&namespace.Migration{")
	s = append(s, "MigrationId: "+fmt.Sprintf("%#v", this.MigrationId)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.Replicas != nil {
		s = append(s, "Replicas: "+fmt.Sprintf("%#v", this.Replicas)+",\n")
	}
	s = append(s, "ReplicatedWorkflows: "+fmt.Sprintf("%#v", this.ReplicatedWorkflows)+",\n")
	s = append(s, "ReplicatedWorkflowsRemaining: "+fmt.Sprintf("%#v", this.ReplicatedWorkflowsRemaining)+",\n")
	s = append(s, "FailureMessage: "+fmt.Sprintf("%#v", this.FailureMessage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MigrationReplica) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&namespace.MigrationReplica{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CertificateFilterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateFilterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateFilterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubjectAlternativeName) > 0 {
		i -= len(m.SubjectAlternativeName)
		copy(dAtA[i:], m.SubjectAlternativeName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.SubjectAlternativeName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrganizationalUnit) > 0 {
		i -= len(m.OrganizationalUnit)
		copy(dAtA[i:], m.OrganizationalUnit)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.OrganizationalUnit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CommonName) > 0 {
		i -= len(m.CommonName)
		copy(dAtA[i:], m.CommonName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.CommonName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MtlsAuthSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MtlsAuthSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MtlsAuthSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptedClientCa) > 0 {
		i -= len(m.AcceptedClientCa)
		copy(dAtA[i:], m.AcceptedClientCa)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AcceptedClientCa)))
		i--
		dAtA[i] = 0x22
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.CertificateFilters) > 0 {
		for iNdEx := len(m.CertificateFilters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CertificateFilters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AcceptedClientCaDeprecated) > 0 {
		i -= len(m.AcceptedClientCaDeprecated)
		copy(dAtA[i:], m.AcceptedClientCaDeprecated)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AcceptedClientCaDeprecated)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApiKeyAuthSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiKeyAuthSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApiKeyAuthSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LifecycleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LifecycleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LifecycleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableDeleteProtection {
		i--
		if m.EnableDeleteProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CodecServerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodecServerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodecServerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CustomErrorMessage != nil {
		{
			size, err := m.CustomErrorMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IncludeCrossOriginCredentials {
		i--
		if m.IncludeCrossOriginCredentials {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PassAccessToken {
		i--
		if m.PassAccessToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodecServerSpec_CustomErrorMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodecServerSpec_CustomErrorMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodecServerSpec_CustomErrorMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HighAvailabilitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HighAvailabilitySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HighAvailabilitySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisableManagedFailover {
		i--
		if m.DisableManagedFailover {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CapacitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapacitySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapacitySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size := m.Spec.Size()
			i -= size
			if _, err := m.Spec.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CapacitySpec_OnDemand_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapacitySpec_OnDemand_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OnDemand != nil {
		{
			size, err := m.OnDemand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CapacitySpec_Provisioned_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapacitySpec_Provisioned_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Provisioned != nil {
		{
			size, err := m.Provisioned.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CapacitySpec_OnDemand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapacitySpec_OnDemand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapacitySpec_OnDemand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CapacitySpec_Provisioned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapacitySpec_Provisioned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapacitySpec_Provisioned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Capacity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Capacity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Capacity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestRequest != nil {
		{
			size, err := m.LatestRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CurrentMode != nil {
		{
			size := m.CurrentMode.Size()
			i -= size
			if _, err := m.CurrentMode.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Capacity_OnDemand_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Capacity_OnDemand_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OnDemand != nil {
		{
			size, err := m.OnDemand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Capacity_Provisioned_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Capacity_Provisioned_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Provisioned != nil {
		{
			size, err := m.Provisioned.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Capacity_OnDemand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Capacity_OnDemand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Capacity_OnDemand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Capacity_Provisioned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Capacity_Provisioned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Capacity_Provisioned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentValue))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Capacity_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Capacity_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Capacity_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AsyncOperationId) > 0 {
		i -= len(m.AsyncOperationId)
		copy(dAtA[i:], m.AsyncOperationId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AsyncOperationId)))
		i--
		dAtA[i] = 0x22
	}
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CapacitySpec != nil {
		{
			size, err := m.CapacitySpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.ConnectivityRuleIds) > 0 {
		for iNdEx := len(m.ConnectivityRuleIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConnectivityRuleIds[iNdEx])
			copy(dAtA[i:], m.ConnectivityRuleIds[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.ConnectivityRuleIds[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.HighAvailability != nil {
		{
			size, err := m.HighAvailability.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Lifecycle != nil {
		{
			size, err := m.Lifecycle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SearchAttributes) > 0 {
		for k := range m.SearchAttributes {
			v := m.SearchAttributes[k]
			baseI := i
			i = encodeVarintMessage(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ApiKeyAuth != nil {
		{
			size, err := m.ApiKeyAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CodecServer != nil {
		{
			size, err := m.CodecServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CustomSearchAttributes) > 0 {
		for k := range m.CustomSearchAttributes {
			v := m.CustomSearchAttributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMessage(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MtlsAuth != nil {
		{
			size, err := m.MtlsAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RetentionDays != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RetentionDays))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Endpoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GrpcAddress) > 0 {
		i -= len(m.GrpcAddress)
		copy(dAtA[i:], m.GrpcAddress)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.GrpcAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MtlsGrpcAddress) > 0 {
		i -= len(m.MtlsGrpcAddress)
		copy(dAtA[i:], m.MtlsGrpcAddress)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MtlsGrpcAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WebAddress) > 0 {
		i -= len(m.WebAddress)
		copy(dAtA[i:], m.WebAddress)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.WebAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Limits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionsPerSecondLimit != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionsPerSecondLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AWSPrivateLinkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSPrivateLinkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSPrivateLinkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcEndpointServiceNames) > 0 {
		for iNdEx := len(m.VpcEndpointServiceNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VpcEndpointServiceNames[iNdEx])
			copy(dAtA[i:], m.VpcEndpointServiceNames[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.VpcEndpointServiceNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AllowedPrincipalArns) > 0 {
		for iNdEx := len(m.AllowedPrincipalArns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedPrincipalArns[iNdEx])
			copy(dAtA[i:], m.AllowedPrincipalArns[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.AllowedPrincipalArns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PrivateConnectivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivateConnectivity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrivateConnectivity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AwsPrivateLink != nil {
		{
			size, err := m.AwsPrivateLink.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Capacity != nil {
		{
			size, err := m.Capacity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMessage(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.ConnectivityRules) > 0 {
		for iNdEx := len(m.ConnectivityRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectivityRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x68
	}
	if len(m.RegionStatus) > 0 {
		for k := range m.RegionStatus {
			v := m.RegionStatus[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.LastModifiedTime != nil {
		{
			size, err := m.LastModifiedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.PrivateConnectivities) > 0 {
		for iNdEx := len(m.PrivateConnectivities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrivateConnectivities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Limits != nil {
		{
			size, err := m.Limits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ActiveRegion) > 0 {
		i -= len(m.ActiveRegion)
		copy(dAtA[i:], m.ActiveRegion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ActiveRegion)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Endpoints != nil {
		{
			size, err := m.Endpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.AsyncOperationId) > 0 {
		i -= len(m.AsyncOperationId)
		copy(dAtA[i:], m.AsyncOperationId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AsyncOperationId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StateDeprecated) > 0 {
		i -= len(m.StateDeprecated)
		copy(dAtA[i:], m.StateDeprecated)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.StateDeprecated)))
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceRegionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRegionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceRegionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AsyncOperationId) > 0 {
		i -= len(m.AsyncOperationId)
		copy(dAtA[i:], m.AsyncOperationId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AsyncOperationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StateDeprecated) > 0 {
		i -= len(m.StateDeprecated)
		copy(dAtA[i:], m.StateDeprecated)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.StateDeprecated)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportSinkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportSinkSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportSinkSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Gcs != nil {
		{
			size, err := m.Gcs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.S3 != nil {
		{
			size, err := m.S3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportSink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportSink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportSink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastHealthCheckTime != nil {
		{
			size, err := m.LastHealthCheckTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LatestDataExportTime != nil {
		{
			size, err := m.LatestDataExportTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x32
	}
	if m.Health != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Health))
		i--
		dAtA[i] = 0x28
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MigrationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size := m.Spec.Size()
			i -= size
			if _, err := m.Spec.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.MigrationEndpointId) > 0 {
		i -= len(m.MigrationEndpointId)
		copy(dAtA[i:], m.MigrationEndpointId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MigrationEndpointId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MigrationSpec_ToCloudSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationSpec_ToCloudSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ToCloudSpec != nil {
		{
			size, err := m.ToCloudSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MigrationToCloudSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationToCloudSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationToCloudSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TargetNamespace) > 0 {
		i -= len(m.TargetNamespace)
		copy(dAtA[i:], m.TargetNamespace)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TargetNamespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourceNamespace) > 0 {
		i -= len(m.SourceNamespace)
		copy(dAtA[i:], m.SourceNamespace)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.SourceNamespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Migration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Migration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Migration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailureMessage) > 0 {
		i -= len(m.FailureMessage)
		copy(dAtA[i:], m.FailureMessage)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.FailureMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ReplicatedWorkflowsRemaining != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ReplicatedWorkflowsRemaining))
		i--
		dAtA[i] = 0x30
	}
	if m.ReplicatedWorkflows != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ReplicatedWorkflows))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MigrationId) > 0 {
		i -= len(m.MigrationId)
		copy(dAtA[i:], m.MigrationId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MigrationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MigrationReplica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationReplica) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationReplica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CertificateFilterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommonName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.OrganizationalUnit)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.SubjectAlternativeName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *MtlsAuthSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AcceptedClientCaDeprecated)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.CertificateFilters) > 0 {
		for _, e := range m.CertificateFilters {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.AcceptedClientCa)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ApiKeyAuthSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *LifecycleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableDeleteProtection {
		n += 2
	}
	return n
}

func (m *CodecServerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.PassAccessToken {
		n += 2
	}
	if m.IncludeCrossOriginCredentials {
		n += 2
	}
	if m.CustomErrorMessage != nil {
		l = m.CustomErrorMessage.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *CodecServerSpec_CustomErrorMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *HighAvailabilitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableManagedFailover {
		n += 2
	}
	return n
}

func (m *CapacitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		n += m.Spec.Size()
	}
	return n
}

func (m *CapacitySpec_OnDemand_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnDemand != nil {
		l = m.OnDemand.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}
func (m *CapacitySpec_Provisioned_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Provisioned != nil {
		l = m.Provisioned.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}
func (m *CapacitySpec_OnDemand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CapacitySpec_Provisioned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *Capacity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentMode != nil {
		n += m.CurrentMode.Size()
	}
	if m.LatestRequest != nil {
		l = m.LatestRequest.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Capacity_OnDemand_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnDemand != nil {
		l = m.OnDemand.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}
func (m *Capacity_Provisioned_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Provisioned != nil {
		l = m.Provisioned.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}
func (m *Capacity_OnDemand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Capacity_Provisioned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentValue != 0 {
		n += 9
	}
	return n
}

func (m *Capacity_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AsyncOperationId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *NamespaceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.RetentionDays != 0 {
		n += 1 + sovMessage(uint64(m.RetentionDays))
	}
	if m.MtlsAuth != nil {
		l = m.MtlsAuth.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.CustomSearchAttributes) > 0 {
		for k, v := range m.CustomSearchAttributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + len(v) + sovMessage(uint64(len(v)))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.CodecServer != nil {
		l = m.CodecServer.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ApiKeyAuth != nil {
		l = m.ApiKeyAuth.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.SearchAttributes) > 0 {
		for k, v := range m.SearchAttributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + sovMessage(uint64(v))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.Lifecycle != nil {
		l = m.Lifecycle.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.HighAvailability != nil {
		l = m.HighAvailability.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.ConnectivityRuleIds) > 0 {
		for _, s := range m.ConnectivityRuleIds {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.CapacitySpec != nil {
		l = m.CapacitySpec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Endpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WebAddress)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.MtlsGrpcAddress)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.GrpcAddress)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Limits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionsPerSecondLimit != 0 {
		n += 1 + sovMessage(uint64(m.ActionsPerSecondLimit))
	}
	return n
}

func (m *AWSPrivateLinkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowedPrincipalArns) > 0 {
		for _, s := range m.AllowedPrincipalArns {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.VpcEndpointServiceNames) > 0 {
		for _, s := range m.VpcEndpointServiceNames {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *PrivateConnectivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.AwsPrivateLink != nil {
		l = m.AwsPrivateLink.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.StateDeprecated)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AsyncOperationId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Endpoints != nil {
		l = m.Endpoints.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ActiveRegion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Limits != nil {
		l = m.Limits.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.PrivateConnectivities) > 0 {
		for _, e := range m.PrivateConnectivities {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LastModifiedTime != nil {
		l = m.LastModifiedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.RegionStatus) > 0 {
		for k, v := range m.RegionStatus {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	if len(m.ConnectivityRules) > 0 {
		for _, e := range m.ConnectivityRules {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + 1 + len(v) + sovMessage(uint64(len(v)))
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.Capacity != nil {
		l = m.Capacity.Size()
		n += 2 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *NamespaceRegionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateDeprecated)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AsyncOperationId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	return n
}

func (m *ExportSinkSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.S3 != nil {
		l = m.S3.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Gcs != nil {
		l = m.Gcs.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ExportSink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Health != 0 {
		n += 1 + sovMessage(uint64(m.Health))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LatestDataExportTime != nil {
		l = m.LatestDataExportTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LastHealthCheckTime != nil {
		l = m.LastHealthCheckTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *MigrationSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MigrationEndpointId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		n += m.Spec.Size()
	}
	return n
}

func (m *MigrationSpec_ToCloudSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToCloudSpec != nil {
		l = m.ToCloudSpec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}
func (m *MigrationToCloudSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceNamespace)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.TargetNamespace)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Migration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MigrationId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.ReplicatedWorkflows != 0 {
		n += 1 + sovMessage(uint64(m.ReplicatedWorkflows))
	}
	if m.ReplicatedWorkflowsRemaining != 0 {
		n += 1 + sovMessage(uint64(m.ReplicatedWorkflowsRemaining))
	}
	l = len(m.FailureMessage)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *MigrationReplica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CertificateFilterSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CertificateFilterSpec{`,
		`CommonName:` + fmt.Sprintf("%v", this.CommonName) + `,`,
		`Organization:` + fmt.Sprintf("%v", this.Organization) + `,`,
		`OrganizationalUnit:` + fmt.Sprintf("%v", this.OrganizationalUnit) + `,`,
		`SubjectAlternativeName:` + fmt.Sprintf("%v", this.SubjectAlternativeName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MtlsAuthSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCertificateFilters := "[]*CertificateFilterSpec{"
	for _, f := range this.CertificateFilters {
		repeatedStringForCertificateFilters += strings.Replace(f.String(), "CertificateFilterSpec", "CertificateFilterSpec", 1) + ","
	}
	repeatedStringForCertificateFilters += "}"
	s := strings.Join([]string{`&MtlsAuthSpec{`,
		`AcceptedClientCaDeprecated:` + fmt.Sprintf("%v", this.AcceptedClientCaDeprecated) + `,`,
		`CertificateFilters:` + repeatedStringForCertificateFilters + `,`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`AcceptedClientCa:` + fmt.Sprintf("%v", this.AcceptedClientCa) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApiKeyAuthSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApiKeyAuthSpec{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LifecycleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LifecycleSpec{`,
		`EnableDeleteProtection:` + fmt.Sprintf("%v", this.EnableDeleteProtection) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodecServerSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodecServerSpec{`,
		`Endpoint:` + fmt.Sprintf("%v", this.Endpoint) + `,`,
		`PassAccessToken:` + fmt.Sprintf("%v", this.PassAccessToken) + `,`,
		`IncludeCrossOriginCredentials:` + fmt.Sprintf("%v", this.IncludeCrossOriginCredentials) + `,`,
		`CustomErrorMessage:` + strings.Replace(fmt.Sprintf("%v", this.CustomErrorMessage), "CodecServerSpec_CustomErrorMessage", "CodecServerSpec_CustomErrorMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodecServerSpec_CustomErrorMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodecServerSpec_CustomErrorMessage{`,
		`Default:` + strings.Replace(fmt.Sprintf("%v", this.Default), "CodecServerSpec_CustomErrorMessage_ErrorMessage", "CodecServerSpec_CustomErrorMessage_ErrorMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodecServerSpec_CustomErrorMessage_ErrorMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodecServerSpec_CustomErrorMessage_ErrorMessage{`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Link:` + fmt.Sprintf("%v", this.Link) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HighAvailabilitySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HighAvailabilitySpec{`,
		`DisableManagedFailover:` + fmt.Sprintf("%v", this.DisableManagedFailover) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapacitySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapacitySpec{`,
		`Spec:` + fmt.Sprintf("%v", this.Spec) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapacitySpec_OnDemand_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapacitySpec_OnDemand_{`,
		`OnDemand:` + strings.Replace(fmt.Sprintf("%v", this.OnDemand), "CapacitySpec_OnDemand", "CapacitySpec_OnDemand", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapacitySpec_Provisioned_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapacitySpec_Provisioned_{`,
		`Provisioned:` + strings.Replace(fmt.Sprintf("%v", this.Provisioned), "CapacitySpec_Provisioned", "CapacitySpec_Provisioned", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapacitySpec_OnDemand) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapacitySpec_OnDemand{`,
		`}`,
	}, "")
	return s
}
func (this *CapacitySpec_Provisioned) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapacitySpec_Provisioned{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Capacity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Capacity{`,
		`CurrentMode:` + fmt.Sprintf("%v", this.CurrentMode) + `,`,
		`LatestRequest:` + strings.Replace(fmt.Sprintf("%v", this.LatestRequest), "Capacity_Request", "Capacity_Request", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Capacity_OnDemand_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Capacity_OnDemand_{`,
		`OnDemand:` + strings.Replace(fmt.Sprintf("%v", this.OnDemand), "Capacity_OnDemand", "Capacity_OnDemand", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Capacity_Provisioned_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Capacity_Provisioned_{`,
		`Provisioned:` + strings.Replace(fmt.Sprintf("%v", this.Provisioned), "Capacity_Provisioned", "Capacity_Provisioned", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Capacity_OnDemand) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Capacity_OnDemand{`,
		`}`,
	}, "")
	return s
}
func (this *Capacity_Provisioned) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Capacity_Provisioned{`,
		`CurrentValue:` + fmt.Sprintf("%v", this.CurrentValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Capacity_Request) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Capacity_Request{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTime:` + strings.Replace(fmt.Sprintf("%v", this.EndTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`AsyncOperationId:` + fmt.Sprintf("%v", this.AsyncOperationId) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "CapacitySpec", "CapacitySpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForCustomSearchAttributes := make([]string, 0, len(this.CustomSearchAttributes))
	for k, _ := range this.CustomSearchAttributes {
		keysForCustomSearchAttributes = append(keysForCustomSearchAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCustomSearchAttributes)
	mapStringForCustomSearchAttributes := "map[string]string{"
	for _, k := range keysForCustomSearchAttributes {
		mapStringForCustomSearchAttributes += fmt.Sprintf("%v: %v,", k, this.CustomSearchAttributes[k])
	}
	mapStringForCustomSearchAttributes += "}"
	keysForSearchAttributes := make([]string, 0, len(this.SearchAttributes))
	for k, _ := range this.SearchAttributes {
		keysForSearchAttributes = append(keysForSearchAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSearchAttributes)
	mapStringForSearchAttributes := "map[string]NamespaceSpec_SearchAttributeType{"
	for _, k := range keysForSearchAttributes {
		mapStringForSearchAttributes += fmt.Sprintf("%v: %v,", k, this.SearchAttributes[k])
	}
	mapStringForSearchAttributes += "}"
	s := strings.Join([]string{`&NamespaceSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Regions:` + fmt.Sprintf("%v", this.Regions) + `,`,
		`RetentionDays:` + fmt.Sprintf("%v", this.RetentionDays) + `,`,
		`MtlsAuth:` + strings.Replace(this.MtlsAuth.String(), "MtlsAuthSpec", "MtlsAuthSpec", 1) + `,`,
		`CustomSearchAttributes:` + mapStringForCustomSearchAttributes + `,`,
		`CodecServer:` + strings.Replace(this.CodecServer.String(), "CodecServerSpec", "CodecServerSpec", 1) + `,`,
		`ApiKeyAuth:` + strings.Replace(this.ApiKeyAuth.String(), "ApiKeyAuthSpec", "ApiKeyAuthSpec", 1) + `,`,
		`SearchAttributes:` + mapStringForSearchAttributes + `,`,
		`Lifecycle:` + strings.Replace(this.Lifecycle.String(), "LifecycleSpec", "LifecycleSpec", 1) + `,`,
		`HighAvailability:` + strings.Replace(this.HighAvailability.String(), "HighAvailabilitySpec", "HighAvailabilitySpec", 1) + `,`,
		`ConnectivityRuleIds:` + fmt.Sprintf("%v", this.ConnectivityRuleIds) + `,`,
		`CapacitySpec:` + strings.Replace(this.CapacitySpec.String(), "CapacitySpec", "CapacitySpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Endpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Endpoints{`,
		`WebAddress:` + fmt.Sprintf("%v", this.WebAddress) + `,`,
		`MtlsGrpcAddress:` + fmt.Sprintf("%v", this.MtlsGrpcAddress) + `,`,
		`GrpcAddress:` + fmt.Sprintf("%v", this.GrpcAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Limits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Limits{`,
		`ActionsPerSecondLimit:` + fmt.Sprintf("%v", this.ActionsPerSecondLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSPrivateLinkInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSPrivateLinkInfo{`,
		`AllowedPrincipalArns:` + fmt.Sprintf("%v", this.AllowedPrincipalArns) + `,`,
		`VpcEndpointServiceNames:` + fmt.Sprintf("%v", this.VpcEndpointServiceNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrivateConnectivity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrivateConnectivity{`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`AwsPrivateLink:` + strings.Replace(this.AwsPrivateLink.String(), "AWSPrivateLinkInfo", "AWSPrivateLinkInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Namespace) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPrivateConnectivities := "[]*PrivateConnectivity{"
	for _, f := range this.PrivateConnectivities {
		repeatedStringForPrivateConnectivities += strings.Replace(f.String(), "PrivateConnectivity", "PrivateConnectivity", 1) + ","
	}
	repeatedStringForPrivateConnectivities += "}"
	repeatedStringForConnectivityRules := "[]*ConnectivityRule{"
	for _, f := range this.ConnectivityRules {
		repeatedStringForConnectivityRules += strings.Replace(fmt.Sprintf("%v", f), "ConnectivityRule", "v11.ConnectivityRule", 1) + ","
	}
	repeatedStringForConnectivityRules += "}"
	keysForRegionStatus := make([]string, 0, len(this.RegionStatus))
	for k, _ := range this.RegionStatus {
		keysForRegionStatus = append(keysForRegionStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRegionStatus)
	mapStringForRegionStatus := "map[string]*NamespaceRegionStatus{"
	for _, k := range keysForRegionStatus {
		mapStringForRegionStatus += fmt.Sprintf("%v: %v,", k, this.RegionStatus[k])
	}
	mapStringForRegionStatus += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Namespace{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "NamespaceSpec", "NamespaceSpec", 1) + `,`,
		`StateDeprecated:` + fmt.Sprintf("%v", this.StateDeprecated) + `,`,
		`AsyncOperationId:` + fmt.Sprintf("%v", this.AsyncOperationId) + `,`,
		`Endpoints:` + strings.Replace(this.Endpoints.String(), "Endpoints", "Endpoints", 1) + `,`,
		`ActiveRegion:` + fmt.Sprintf("%v", this.ActiveRegion) + `,`,
		`Limits:` + strings.Replace(this.Limits.String(), "Limits", "Limits", 1) + `,`,
		`PrivateConnectivities:` + repeatedStringForPrivateConnectivities + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastModifiedTime:` + strings.Replace(fmt.Sprintf("%v", this.LastModifiedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`RegionStatus:` + mapStringForRegionStatus + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`ConnectivityRules:` + repeatedStringForConnectivityRules + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Capacity:` + strings.Replace(this.Capacity.String(), "Capacity", "Capacity", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRegionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRegionStatus{`,
		`StateDeprecated:` + fmt.Sprintf("%v", this.StateDeprecated) + `,`,
		`AsyncOperationId:` + fmt.Sprintf("%v", this.AsyncOperationId) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExportSinkSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExportSinkSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`S3:` + strings.Replace(fmt.Sprintf("%v", this.S3), "S3Spec", "v12.S3Spec", 1) + `,`,
		`Gcs:` + strings.Replace(fmt.Sprintf("%v", this.Gcs), "GCSSpec", "v12.GCSSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExportSink) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExportSink{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "ExportSinkSpec", "ExportSinkSpec", 1) + `,`,
		`Health:` + fmt.Sprintf("%v", this.Health) + `,`,
		`ErrorMessage:` + fmt.Sprintf("%v", this.ErrorMessage) + `,`,
		`LatestDataExportTime:` + strings.Replace(fmt.Sprintf("%v", this.LatestDataExportTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastHealthCheckTime:` + strings.Replace(fmt.Sprintf("%v", this.LastHealthCheckTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MigrationSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MigrationSpec{`,
		`MigrationEndpointId:` + fmt.Sprintf("%v", this.MigrationEndpointId) + `,`,
		`Spec:` + fmt.Sprintf("%v", this.Spec) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MigrationSpec_ToCloudSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MigrationSpec_ToCloudSpec{`,
		`ToCloudSpec:` + strings.Replace(fmt.Sprintf("%v", this.ToCloudSpec), "MigrationToCloudSpec", "MigrationToCloudSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MigrationToCloudSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MigrationToCloudSpec{`,
		`SourceNamespace:` + fmt.Sprintf("%v", this.SourceNamespace) + `,`,
		`TargetNamespace:` + fmt.Sprintf("%v", this.TargetNamespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Migration) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForReplicas := "[]*MigrationReplica{"
	for _, f := range this.Replicas {
		repeatedStringForReplicas += strings.Replace(f.String(), "MigrationReplica", "MigrationReplica", 1) + ","
	}
	repeatedStringForReplicas += "}"
	s := strings.Join([]string{`&Migration{`,
		`MigrationId:` + fmt.Sprintf("%v", this.MigrationId) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "MigrationSpec", "MigrationSpec", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Replicas:` + repeatedStringForReplicas + `,`,
		`ReplicatedWorkflows:` + fmt.Sprintf("%v", this.ReplicatedWorkflows) + `,`,
		`ReplicatedWorkflowsRemaining:` + fmt.Sprintf("%v", this.ReplicatedWorkflowsRemaining) + `,`,
		`FailureMessage:` + fmt.Sprintf("%v", this.FailureMessage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MigrationReplica) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MigrationReplica{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CertificateFilterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateFilterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateFilterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationalUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationalUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAlternativeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectAlternativeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MtlsAuthSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MtlsAuthSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MtlsAuthSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedClientCaDeprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptedClientCaDeprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateFilters = append(m.CertificateFilters, &CertificateFilterSpec{})
			if err := m.CertificateFilters[len(m.CertificateFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedClientCa", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptedClientCa = append(m.AcceptedClientCa[:0], dAtA[iNdEx:postIndex]...)
			if m.AcceptedClientCa == nil {
				m.AcceptedClientCa = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiKeyAuthSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiKeyAuthSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiKeyAuthSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LifecycleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LifecycleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LifecycleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDeleteProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDeleteProtection = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodecServerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodecServerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodecServerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassAccessToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassAccessToken = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeCrossOriginCredentials", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeCrossOriginCredentials = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrorMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrorMessage == nil {
				m.CustomErrorMessage = &CodecServerSpec_CustomErrorMessage{}
			}
			if err := m.CustomErrorMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodecServerSpec_CustomErrorMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomErrorMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomErrorMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &CodecServerSpec_CustomErrorMessage_ErrorMessage{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodecServerSpec_CustomErrorMessage_ErrorMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HighAvailabilitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HighAvailabilitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HighAvailabilitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableManagedFailover", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableManagedFailover = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapacitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapacitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapacitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDemand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapacitySpec_OnDemand{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Spec = &CapacitySpec_OnDemand_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provisioned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapacitySpec_Provisioned{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Spec = &CapacitySpec_Provisioned_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapacitySpec_OnDemand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnDemand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnDemand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapacitySpec_Provisioned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Provisioned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Provisioned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Capacity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Capacity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Capacity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDemand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Capacity_OnDemand{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CurrentMode = &Capacity_OnDemand_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provisioned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Capacity_Provisioned{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CurrentMode = &Capacity_Provisioned_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestRequest == nil {
				m.LatestRequest = &Capacity_Request{}
			}
			if err := m.LatestRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Capacity_OnDemand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnDemand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnDemand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Capacity_Provisioned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Provisioned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Provisioned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentValue = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Capacity_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Capacity_Request_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &types.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &types.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncOperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsyncOperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CapacitySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionDays", wireType)
			}
			m.RetentionDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetentionDays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtlsAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MtlsAuth == nil {
				m.MtlsAuth = &MtlsAuthSpec{}
			}
			if err := m.MtlsAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomSearchAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomSearchAttributes == nil {
				m.CustomSearchAttributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomSearchAttributes[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodecServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodecServer == nil {
				m.CodecServer = &CodecServerSpec{}
			}
			if err := m.CodecServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKeyAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiKeyAuth == nil {
				m.ApiKeyAuth = &ApiKeyAuthSpec{}
			}
			if err := m.ApiKeyAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchAttributes == nil {
				m.SearchAttributes = make(map[string]NamespaceSpec_SearchAttributeType)
			}
			var mapkey string
			var mapvalue NamespaceSpec_SearchAttributeType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= NamespaceSpec_SearchAttributeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SearchAttributes[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifecycle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifecycle == nil {
				m.Lifecycle = &LifecycleSpec{}
			}
			if err := m.Lifecycle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighAvailability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighAvailability == nil {
				m.HighAvailability = &HighAvailabilitySpec{}
			}
			if err := m.HighAvailability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectivityRuleIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectivityRuleIds = append(m.ConnectivityRuleIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacitySpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CapacitySpec == nil {
				m.CapacitySpec = &CapacitySpec{}
			}
			if err := m.CapacitySpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtlsGrpcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MtlsGrpcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrpcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionsPerSecondLimit", wireType)
			}
			m.ActionsPerSecondLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionsPerSecondLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSPrivateLinkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSPrivateLinkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSPrivateLinkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPrincipalArns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedPrincipalArns = append(m.AllowedPrincipalArns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcEndpointServiceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcEndpointServiceNames = append(m.VpcEndpointServiceNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivateConnectivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivateConnectivity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivateConnectivity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPrivateLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwsPrivateLink == nil {
				m.AwsPrivateLink = &AWSPrivateLinkInfo{}
			}
			if err := m.AwsPrivateLink.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NamespaceSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateDeprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateDeprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncOperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsyncOperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = &Endpoints{}
			}
			if err := m.Endpoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = &Limits{}
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateConnectivities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateConnectivities = append(m.PrivateConnectivities, &PrivateConnectivity{})
			if err := m.PrivateConnectivities[len(m.PrivateConnectivities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifiedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifiedTime == nil {
				m.LastModifiedTime = &types.Timestamp{}
			}
			if err := m.LastModifiedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionStatus == nil {
				m.RegionStatus = make(map[string]*NamespaceRegionStatus)
			}
			var mapkey string
			var mapvalue *NamespaceRegionStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamespaceRegionStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RegionStatus[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= v1.ResourceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectivityRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectivityRules = append(m.ConnectivityRules, &v11.ConnectivityRule{})
			if err := m.ConnectivityRules[len(m.ConnectivityRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capacity == nil {
				m.Capacity = &Capacity{}
			}
			if err := m.Capacity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRegionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRegionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRegionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateDeprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateDeprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncOperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsyncOperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NamespaceRegionStatus_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportSinkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportSinkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportSinkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S3 == nil {
				m.S3 = &v12.S3Spec{}
			}
			if err := m.S3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gcs == nil {
				m.Gcs = &v12.GCSSpec{}
			}
			if err := m.Gcs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportSink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportSink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportSink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= v1.ResourceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ExportSinkSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Health |= ExportSink_Health(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestDataExportTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestDataExportTime == nil {
				m.LatestDataExportTime = &types.Timestamp{}
			}
			if err := m.LatestDataExportTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHealthCheckTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastHealthCheckTime == nil {
				m.LastHealthCheckTime = &types.Timestamp{}
			}
			if err := m.LastHealthCheckTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationEndpointId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigrationEndpointId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToCloudSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MigrationToCloudSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Spec = &MigrationSpec_ToCloudSpec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationToCloudSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationToCloudSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationToCloudSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Migration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Migration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Migration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigrationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MigrationSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Migration_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &MigrationReplica{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedWorkflows", wireType)
			}
			m.ReplicatedWorkflows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicatedWorkflows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedWorkflowsRemaining", wireType)
			}
			m.ReplicatedWorkflowsRemaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicatedWorkflowsRemaining |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationReplica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationReplica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationReplica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MigrationReplica_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
