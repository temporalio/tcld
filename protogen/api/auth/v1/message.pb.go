// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/auth/v1/message.proto

package auth

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	v1 "github.com/temporalio/tcld/protogen/temporal/api/cloud/identity/v1"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UserState int32

const (
	USER_STATE_UNSPECIFIED UserState = 0
	// user is being created by the system
	USER_STATE_CREATING UserState = 1
	// user create operation failed
	USER_STATE_CREATE_FAILED UserState = 2
	// the user exists in the system (includes user with an outstanding invite)
	USER_STATE_ACTIVE UserState = 3
	// user is being udpate
	USER_STATE_UPDATING UserState = 4
	// the last user update failed
	USER_STATE_UPDATE_FAILED UserState = 5
	// the user is being deleted
	USER_STATE_DELETING UserState = 6
	// the user delete opertion failed
	USER_STATE_DELETE_FAILED UserState = 7
	// the user is successfully deleted
	USER_STATE_DELETED UserState = 8
)

var UserState_name = map[int32]string{
	0: "Unspecified",
	1: "Creating",
	2: "CreateFailed",
	3: "Active",
	4: "Updating",
	5: "UpdateFailed",
	6: "Deleting",
	7: "DeleteFailed",
	8: "Deleted",
}

var UserState_value = map[string]int32{
	"Unspecified":  0,
	"Creating":     1,
	"CreateFailed": 2,
	"Active":       3,
	"Updating":     4,
	"UpdateFailed": 5,
	"Deleting":     6,
	"DeleteFailed": 7,
	"Deleted":      8,
}

func (UserState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{0}
}

type RoleType int32

const (
	ROLE_TYPE_UNSPECIFIED RoleType = 0
	// a predefined role
	ROLE_TYPE_PREDEFINED RoleType = 1
)

var RoleType_name = map[int32]string{
	0: "Unspecified",
	1: "Predefined",
}

var RoleType_value = map[string]int32{
	"Unspecified": 0,
	"Predefined":  1,
}

func (RoleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{1}
}

type NamespaceActionGroup int32

const (
	NAMESPACE_ACTION_GROUP_UNSPECIFIED NamespaceActionGroup = 0
	// admin access to the namespace
	NAMESPACE_ACTION_GROUP_ADMIN NamespaceActionGroup = 1
	// write access to the namespace
	NAMESPACE_ACTION_GROUP_WRITE NamespaceActionGroup = 2
	// read-only access to the namesapce
	NAMESPACE_ACTION_GROUP_READ NamespaceActionGroup = 3
)

var NamespaceActionGroup_name = map[int32]string{
	0: "Unspecified",
	1: "Admin",
	2: "Write",
	3: "Read",
}

var NamespaceActionGroup_value = map[string]int32{
	"Unspecified": 0,
	"Admin":       1,
	"Write":       2,
	"Read":        3,
}

func (NamespaceActionGroup) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{2}
}

type AccountActionGroup int32

const (
	ACCOUNT_ACTION_GROUP_UNSPECIFIED AccountActionGroup = 0
	// global admin
	ACCOUNT_ACTION_GROUP_ADMIN AccountActionGroup = 1
	// write access to all namespaces
	ACCOUNT_ACTION_GROUP_DEVELOPER AccountActionGroup = 2
	// read-only access to all namespaces
	ACCOUNT_ACTION_GROUP_READ AccountActionGroup = 3
)

var AccountActionGroup_name = map[int32]string{
	0: "Unspecified",
	1: "Admin",
	2: "Developer",
	3: "Read",
}

var AccountActionGroup_value = map[string]int32{
	"Unspecified": 0,
	"Admin":       1,
	"Developer":   2,
	"Read":        3,
}

func (AccountActionGroup) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{3}
}

type APIKeyAccessType int32

const (
	APIKEY_ACCESS_TYPE_UNSPECIFIED APIKeyAccessType = 0
	// the apikey inherits all of the owners accesses
	APIKEY_ACCESS_TYPE_INHERIT_OWNER_ACCESS APIKeyAccessType = 1
)

var APIKeyAccessType_name = map[int32]string{
	0: "ApikeyAccessTypeUnspecified",
	1: "ApikeyAccessTypeInheritOwnerAccess",
}

var APIKeyAccessType_value = map[string]int32{
	"ApikeyAccessTypeUnspecified":        0,
	"ApikeyAccessTypeInheritOwnerAccess": 1,
}

func (APIKeyAccessType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{4}
}

type APIKeyOwnerType int32

const (
	APIKEY_OWNER_TYPE_UNSPECIFIED APIKeyOwnerType = 0
	// the owner is an user
	APIKEY_OWNER_TYPE_USER APIKeyOwnerType = 1
	// Owner is a service account.
	APIKEY_OWNER_TYPE_SERVICE_ACCOUNT APIKeyOwnerType = 2
)

var APIKeyOwnerType_name = map[int32]string{
	0: "ApikeyOwnerTypeUnspecified",
	1: "ApikeyOwnerTypeUser",
	2: "ApikeyOwnerTypeServiceAccount",
}

var APIKeyOwnerType_value = map[string]int32{
	"ApikeyOwnerTypeUnspecified":    0,
	"ApikeyOwnerTypeUser":           1,
	"ApikeyOwnerTypeServiceAccount": 2,
}

func (APIKeyOwnerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{5}
}

type APIKeyState int32

const (
	APIKEY_STATE_UNSPECIFIED APIKeyState = 0
	// apikey is being created by the system
	APIKEY_STATE_CREATING APIKeyState = 1
	// apikey create operation failed
	APIKEY_STATE_CREATE_FAILED APIKeyState = 2
	// the apikey exists in the system
	APIKEY_STATE_ACTIVE APIKeyState = 3
	// apikey is being updated
	APIKEY_STATE_UPDATING APIKeyState = 4
	// the last apikey update failed
	APIKEY_STATE_UPDATE_FAILED APIKeyState = 5
	// the apikey has expired
	APIKEY_STATE_EXPIRED APIKeyState = 6
	// the apikey is being deleted
	APIKEY_STATE_DELETING APIKeyState = 7
	// the apikey delete operation failed
	APIKEY_STATE_DELETE_FAILED APIKeyState = 8
	// the apikey was successfully deleted
	APIKEY_STATE_DELETED APIKeyState = 9
)

var APIKeyState_name = map[int32]string{
	0: "ApikeyStateUnspecified",
	1: "ApikeyStateCreating",
	2: "ApikeyStateCreateFailed",
	3: "ApikeyStateActive",
	4: "ApikeyStateUpdating",
	5: "ApikeyStateUpdateFailed",
	6: "ApikeyStateExpired",
	7: "ApikeyStateDeleting",
	8: "ApikeyStateDeleteFailed",
	9: "ApikeyStateDeleted",
}

var APIKeyState_value = map[string]int32{
	"ApikeyStateUnspecified":  0,
	"ApikeyStateCreating":     1,
	"ApikeyStateCreateFailed": 2,
	"ApikeyStateActive":       3,
	"ApikeyStateUpdating":     4,
	"ApikeyStateUpdateFailed": 5,
	"ApikeyStateExpired":      6,
	"ApikeyStateDeleting":     7,
	"ApikeyStateDeleteFailed": 8,
	"ApikeyStateDeleted":      9,
}

func (APIKeyState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{6}
}

type UserSpec struct {
	// the email address associated to the user
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// the roles assigned to the user
	Roles []string `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *UserSpec) Reset()      { *m = UserSpec{} }
func (*UserSpec) ProtoMessage() {}
func (*UserSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{0}
}
func (m *UserSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSpec.Merge(m, src)
}
func (m *UserSpec) XXX_Size() int {
	return m.Size()
}
func (m *UserSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UserSpec proto.InternalMessageInfo

func (m *UserSpec) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserSpec) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// should be used along side namespace_id to determine permissions set for a user
type UserNamespacePermissions struct {
	// the user to set namespace permissions for
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// the namespace action group to set for the user
	ActionGroup NamespaceActionGroup `protobuf:"varint,2,opt,name=action_group,json=actionGroup,proto3,enum=api.auth.v1.NamespaceActionGroup" json:"action_group,omitempty"`
}

func (m *UserNamespacePermissions) Reset()      { *m = UserNamespacePermissions{} }
func (*UserNamespacePermissions) ProtoMessage() {}
func (*UserNamespacePermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{1}
}
func (m *UserNamespacePermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserNamespacePermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserNamespacePermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserNamespacePermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserNamespacePermissions.Merge(m, src)
}
func (m *UserNamespacePermissions) XXX_Size() int {
	return m.Size()
}
func (m *UserNamespacePermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_UserNamespacePermissions.DiscardUnknown(m)
}

var xxx_messageInfo_UserNamespacePermissions proto.InternalMessageInfo

func (m *UserNamespacePermissions) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *UserNamespacePermissions) GetActionGroup() NamespaceActionGroup {
	if m != nil {
		return m.ActionGroup
	}
	return NAMESPACE_ACTION_GROUP_UNSPECIFIED
}

type Invitation struct {
	// the uri of the invitation sent to the user
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// the date and time when the user was created
	CreatedTime *types.Timestamp `protobuf:"bytes,2,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// the date and time when the invitation expires or has expired
	ExpiryTime *types.Timestamp `protobuf:"bytes,3,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
}

func (m *Invitation) Reset()      { *m = Invitation{} }
func (*Invitation) ProtoMessage() {}
func (*Invitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{2}
}
func (m *Invitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Invitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Invitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Invitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Invitation.Merge(m, src)
}
func (m *Invitation) XXX_Size() int {
	return m.Size()
}
func (m *Invitation) XXX_DiscardUnknown() {
	xxx_messageInfo_Invitation.DiscardUnknown(m)
}

var xxx_messageInfo_Invitation proto.InternalMessageInfo

func (m *Invitation) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Invitation) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *Invitation) GetExpiryTime() *types.Timestamp {
	if m != nil {
		return m.ExpiryTime
	}
	return nil
}

type User struct {
	// the id of the user
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the current version of the user specification
	// the next update request will have to include this version
	ResourceVersion string `protobuf:"bytes,2,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// the user specification
	Spec *UserSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	// the current state of the user
	State UserState `protobuf:"varint,4,opt,name=state,proto3,enum=api.auth.v1.UserState" json:"state,omitempty"`
	// the id of the request that is creating/updating/deleting the user, if any
	RequestId string `protobuf:"bytes,5,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// the details of the open invitation sent to the user, if any
	Invitation *Invitation `protobuf:"bytes,6,opt,name=invitation,proto3" json:"invitation,omitempty"`
	// the date and time when the user was created
	CreatedTime *types.Timestamp `protobuf:"bytes,7,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// the date and time when the user was last modified
	LastModifiedTime *types.Timestamp `protobuf:"bytes,8,opt,name=last_modified_time,json=lastModifiedTime,proto3" json:"last_modified_time,omitempty"`
}

func (m *User) Reset()      { *m = User{} }
func (*User) ProtoMessage() {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{3}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *User) GetSpec() *UserSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *User) GetState() UserState {
	if m != nil {
		return m.State
	}
	return USER_STATE_UNSPECIFIED
}

func (m *User) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *User) GetInvitation() *Invitation {
	if m != nil {
		return m.Invitation
	}
	return nil
}

func (m *User) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *User) GetLastModifiedTime() *types.Timestamp {
	if m != nil {
		return m.LastModifiedTime
	}
	return nil
}

type NamespaceRoleSpec struct {
	// the namespace the role is defined for
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// the action group to enable for the namepspace
	ActionGroup NamespaceActionGroup `protobuf:"varint,2,opt,name=action_group,json=actionGroup,proto3,enum=api.auth.v1.NamespaceActionGroup" json:"action_group,omitempty"`
}

func (m *NamespaceRoleSpec) Reset()      { *m = NamespaceRoleSpec{} }
func (*NamespaceRoleSpec) ProtoMessage() {}
func (*NamespaceRoleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{4}
}
func (m *NamespaceRoleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceRoleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceRoleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceRoleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceRoleSpec.Merge(m, src)
}
func (m *NamespaceRoleSpec) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceRoleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceRoleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceRoleSpec proto.InternalMessageInfo

func (m *NamespaceRoleSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NamespaceRoleSpec) GetActionGroup() NamespaceActionGroup {
	if m != nil {
		return m.ActionGroup
	}
	return NAMESPACE_ACTION_GROUP_UNSPECIFIED
}

type AccountRoleSpec struct {
	// the action group to enable for the account
	ActionGroup AccountActionGroup `protobuf:"varint,1,opt,name=action_group,json=actionGroup,proto3,enum=api.auth.v1.AccountActionGroup" json:"action_group,omitempty"`
}

func (m *AccountRoleSpec) Reset()      { *m = AccountRoleSpec{} }
func (*AccountRoleSpec) ProtoMessage() {}
func (*AccountRoleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{5}
}
func (m *AccountRoleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRoleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRoleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRoleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRoleSpec.Merge(m, src)
}
func (m *AccountRoleSpec) XXX_Size() int {
	return m.Size()
}
func (m *AccountRoleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRoleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRoleSpec proto.InternalMessageInfo

func (m *AccountRoleSpec) GetActionGroup() AccountActionGroup {
	if m != nil {
		return m.ActionGroup
	}
	return ACCOUNT_ACTION_GROUP_UNSPECIFIED
}

type RoleSpec struct {
	// the global account role
	AccountRole *AccountRoleSpec `protobuf:"bytes,1,opt,name=account_role,json=accountRole,proto3" json:"account_role,omitempty"`
	// the list of namespace roles
	NamespaceRoles []*NamespaceRoleSpec `protobuf:"bytes,2,rep,name=namespace_roles,json=namespaceRoles,proto3" json:"namespace_roles,omitempty"`
}

func (m *RoleSpec) Reset()      { *m = RoleSpec{} }
func (*RoleSpec) ProtoMessage() {}
func (*RoleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{6}
}
func (m *RoleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleSpec.Merge(m, src)
}
func (m *RoleSpec) XXX_Size() int {
	return m.Size()
}
func (m *RoleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RoleSpec proto.InternalMessageInfo

func (m *RoleSpec) GetAccountRole() *AccountRoleSpec {
	if m != nil {
		return m.AccountRole
	}
	return nil
}

func (m *RoleSpec) GetNamespaceRoles() []*NamespaceRoleSpec {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

type Role struct {
	// the id of the role
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the role type
	Type RoleType `protobuf:"varint,2,opt,name=type,proto3,enum=api.auth.v1.RoleType" json:"type,omitempty"`
	// the specification of the role
	Spec *RoleSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Role) Reset()      { *m = Role{} }
func (*Role) ProtoMessage() {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{7}
}
func (m *Role) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Role.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return m.Size()
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Role) GetType() RoleType {
	if m != nil {
		return m.Type
	}
	return ROLE_TYPE_UNSPECIFIED
}

func (m *Role) GetSpec() *RoleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type APIKeySpec struct {
	// the access type of the apikey
	AccessType APIKeyAccessType `protobuf:"varint,1,opt,name=access_type,json=accessType,proto3,enum=api.auth.v1.APIKeyAccessType" json:"access_type,omitempty"`
	// the user friendly name for the apikey
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// the more comprehensive description for the apikey
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// expiry timestamp of the apikey
	ExpiryTime *types.Timestamp `protobuf:"bytes,4,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	// whether the apikey is disabled
	Disabled bool `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
}

func (m *APIKeySpec) Reset()      { *m = APIKeySpec{} }
func (*APIKeySpec) ProtoMessage() {}
func (*APIKeySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{8}
}
func (m *APIKeySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *APIKeySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_APIKeySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *APIKeySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_APIKeySpec.Merge(m, src)
}
func (m *APIKeySpec) XXX_Size() int {
	return m.Size()
}
func (m *APIKeySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_APIKeySpec.DiscardUnknown(m)
}

var xxx_messageInfo_APIKeySpec proto.InternalMessageInfo

func (m *APIKeySpec) GetAccessType() APIKeyAccessType {
	if m != nil {
		return m.AccessType
	}
	return APIKEY_ACCESS_TYPE_UNSPECIFIED
}

func (m *APIKeySpec) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *APIKeySpec) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *APIKeySpec) GetExpiryTime() *types.Timestamp {
	if m != nil {
		return m.ExpiryTime
	}
	return nil
}

func (m *APIKeySpec) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

type Owner struct {
	// the id of the owner
	// if the owner is an user, this is the id of the user.
	OwnerId string `protobuf:"bytes,1,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// the type of the owner.
	OwnerType APIKeyOwnerType `protobuf:"varint,2,opt,name=owner_type,json=ownerType,proto3,enum=api.auth.v1.APIKeyOwnerType" json:"owner_type,omitempty"`
}

func (m *Owner) Reset()      { *m = Owner{} }
func (*Owner) ProtoMessage() {}
func (*Owner) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{9}
}
func (m *Owner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Owner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Owner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Owner.Merge(m, src)
}
func (m *Owner) XXX_Size() int {
	return m.Size()
}
func (m *Owner) XXX_DiscardUnknown() {
	xxx_messageInfo_Owner.DiscardUnknown(m)
}

var xxx_messageInfo_Owner proto.InternalMessageInfo

func (m *Owner) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *Owner) GetOwnerType() APIKeyOwnerType {
	if m != nil {
		return m.OwnerType
	}
	return APIKEY_OWNER_TYPE_UNSPECIFIED
}

type APIKey struct {
	// the id of the apikey
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the owner of the apikey
	Owner *Owner `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// the apikey specification
	Spec *APIKeySpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	// the current version of the apikey specification
	// the next update request will have to include this version
	ResourceVersion string `protobuf:"bytes,4,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// the current state of the apikey
	State APIKeyState `protobuf:"varint,5,opt,name=state,proto3,enum=api.auth.v1.APIKeyState" json:"state,omitempty"`
	// the id of the request that is creating/updating/deleting the apikey, if any
	RequestId string `protobuf:"bytes,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// the date and time when the apikey was created
	CreatedTime *types.Timestamp `protobuf:"bytes,7,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// the date and time when the apikey was last modified
	LastModifiedTime *types.Timestamp `protobuf:"bytes,8,opt,name=last_modified_time,json=lastModifiedTime,proto3" json:"last_modified_time,omitempty"`
}

func (m *APIKey) Reset()      { *m = APIKey{} }
func (*APIKey) ProtoMessage() {}
func (*APIKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{10}
}
func (m *APIKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *APIKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_APIKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *APIKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_APIKey.Merge(m, src)
}
func (m *APIKey) XXX_Size() int {
	return m.Size()
}
func (m *APIKey) XXX_DiscardUnknown() {
	xxx_messageInfo_APIKey.DiscardUnknown(m)
}

var xxx_messageInfo_APIKey proto.InternalMessageInfo

func (m *APIKey) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *APIKey) GetOwner() *Owner {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *APIKey) GetSpec() *APIKeySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *APIKey) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *APIKey) GetState() APIKeyState {
	if m != nil {
		return m.State
	}
	return APIKEY_STATE_UNSPECIFIED
}

func (m *APIKey) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *APIKey) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *APIKey) GetLastModifiedTime() *types.Timestamp {
	if m != nil {
		return m.LastModifiedTime
	}
	return nil
}

type ServiceAccount struct {
	// The id of the service account.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The current version of the service account specification.
	// The next update operation will have to include this version.
	ResourceVersion string `protobuf:"bytes,2,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// The service account specification.
	Spec *ServiceAccountSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	// The current state of the service account.
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	// The id of the async operation that is creating/updating/deleting the service account, if any.
	AsyncOperationId string `protobuf:"bytes,5,opt,name=async_operation_id,json=asyncOperationId,proto3" json:"async_operation_id,omitempty"`
	// The date and time when the service account was created
	CreatedTime *types.Timestamp `protobuf:"bytes,6,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// The date and time when the service account was last modified
	// Will not be set if the service account has never been modified.
	LastModifiedTime *types.Timestamp `protobuf:"bytes,7,opt,name=last_modified_time,json=lastModifiedTime,proto3" json:"last_modified_time,omitempty"`
}

func (m *ServiceAccount) Reset()      { *m = ServiceAccount{} }
func (*ServiceAccount) ProtoMessage() {}
func (*ServiceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{11}
}
func (m *ServiceAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceAccount.Merge(m, src)
}
func (m *ServiceAccount) XXX_Size() int {
	return m.Size()
}
func (m *ServiceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceAccount proto.InternalMessageInfo

func (m *ServiceAccount) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ServiceAccount) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *ServiceAccount) GetSpec() *ServiceAccountSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ServiceAccount) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *ServiceAccount) GetAsyncOperationId() string {
	if m != nil {
		return m.AsyncOperationId
	}
	return ""
}

func (m *ServiceAccount) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *ServiceAccount) GetLastModifiedTime() *types.Timestamp {
	if m != nil {
		return m.LastModifiedTime
	}
	return nil
}

type ServiceAccountSpec struct {
	// The name associated with the service account.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The access assigned to the service account.
	Access *v1.Access `protobuf:"bytes,2,opt,name=access,proto3" json:"access,omitempty"`
	// The description associated with the service account - optional.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Set to true if the service account is disabled.
	// Used as a half-way step for deleting a service account.
	Disabled bool `protobuf:"varint,4,opt,name=disabled,proto3" json:"disabled,omitempty"`
}

func (m *ServiceAccountSpec) Reset()      { *m = ServiceAccountSpec{} }
func (*ServiceAccountSpec) ProtoMessage() {}
func (*ServiceAccountSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{12}
}
func (m *ServiceAccountSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceAccountSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceAccountSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceAccountSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceAccountSpec.Merge(m, src)
}
func (m *ServiceAccountSpec) XXX_Size() int {
	return m.Size()
}
func (m *ServiceAccountSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceAccountSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceAccountSpec proto.InternalMessageInfo

func (m *ServiceAccountSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServiceAccountSpec) GetAccess() *v1.Access {
	if m != nil {
		return m.Access
	}
	return nil
}

func (m *ServiceAccountSpec) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ServiceAccountSpec) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func init() {
	proto.RegisterEnum("api.auth.v1.UserState", UserState_name, UserState_value)
	proto.RegisterEnum("api.auth.v1.RoleType", RoleType_name, RoleType_value)
	proto.RegisterEnum("api.auth.v1.NamespaceActionGroup", NamespaceActionGroup_name, NamespaceActionGroup_value)
	proto.RegisterEnum("api.auth.v1.AccountActionGroup", AccountActionGroup_name, AccountActionGroup_value)
	proto.RegisterEnum("api.auth.v1.APIKeyAccessType", APIKeyAccessType_name, APIKeyAccessType_value)
	proto.RegisterEnum("api.auth.v1.APIKeyOwnerType", APIKeyOwnerType_name, APIKeyOwnerType_value)
	proto.RegisterEnum("api.auth.v1.APIKeyState", APIKeyState_name, APIKeyState_value)
	proto.RegisterType((*UserSpec)(nil), "api.auth.v1.UserSpec")
	proto.RegisterType((*UserNamespacePermissions)(nil), "api.auth.v1.UserNamespacePermissions")
	proto.RegisterType((*Invitation)(nil), "api.auth.v1.Invitation")
	proto.RegisterType((*User)(nil), "api.auth.v1.User")
	proto.RegisterType((*NamespaceRoleSpec)(nil), "api.auth.v1.NamespaceRoleSpec")
	proto.RegisterType((*AccountRoleSpec)(nil), "api.auth.v1.AccountRoleSpec")
	proto.RegisterType((*RoleSpec)(nil), "api.auth.v1.RoleSpec")
	proto.RegisterType((*Role)(nil), "api.auth.v1.Role")
	proto.RegisterType((*APIKeySpec)(nil), "api.auth.v1.APIKeySpec")
	proto.RegisterType((*Owner)(nil), "api.auth.v1.Owner")
	proto.RegisterType((*APIKey)(nil), "api.auth.v1.APIKey")
	proto.RegisterType((*ServiceAccount)(nil), "api.auth.v1.ServiceAccount")
	proto.RegisterType((*ServiceAccountSpec)(nil), "api.auth.v1.ServiceAccountSpec")
}

func init() { proto.RegisterFile("api/auth/v1/message.proto", fileDescriptor_bea184b0c3eae56b) }

var fileDescriptor_bea184b0c3eae56b = []byte{
	// 1356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0x13, 0x47,
	0x14, 0xf6, 0x3a, 0xb6, 0x63, 0x3f, 0xa3, 0x64, 0x19, 0xf2, 0xc3, 0x71, 0x93, 0x25, 0xb1, 0x5a,
	0x0a, 0x01, 0xd9, 0x22, 0x48, 0xed, 0x01, 0x15, 0xb4, 0xd8, 0x43, 0x58, 0x11, 0x6c, 0x6b, 0x6c,
	0x87, 0xd2, 0xcb, 0x6a, 0xb1, 0x87, 0x74, 0x25, 0xdb, 0xbb, 0xdd, 0x5d, 0x87, 0xfa, 0xd6, 0x3f,
	0xa1, 0x87, 0x9e, 0x2a, 0xf5, 0x54, 0xa9, 0x6a, 0xff, 0x93, 0x5e, 0x2a, 0x71, 0xe4, 0x58, 0xcc,
	0xa5, 0xea, 0x09, 0xf5, 0xca, 0xa5, 0x9a, 0xd9, 0x1f, 0xde, 0x5d, 0x6f, 0xa0, 0xb4, 0x1c, 0x7a,
	0xca, 0xcc, 0x7b, 0xdf, 0xfb, 0xde, 0xbe, 0x6f, 0xe6, 0xbd, 0x71, 0x60, 0x4b, 0x33, 0xf5, 0x9a,
	0x36, 0x71, 0xbe, 0xac, 0x9d, 0x5e, 0xaf, 0x8d, 0xa8, 0x6d, 0x6b, 0x27, 0xb4, 0x6a, 0x5a, 0x86,
	0x63, 0xa0, 0xa2, 0x66, 0xea, 0x55, 0xe6, 0xaa, 0x9e, 0x5e, 0x2f, 0x5f, 0x3c, 0x31, 0x8c, 0x93,
	0x21, 0xad, 0x71, 0xd7, 0xe3, 0xc9, 0x93, 0x9a, 0xa3, 0x8f, 0xa8, 0xed, 0x68, 0x23, 0xd3, 0x45,
	0x97, 0xaf, 0x39, 0x74, 0x64, 0x1a, 0x96, 0x36, 0xac, 0x31, 0xc6, 0xfe, 0xd0, 0x98, 0x0c, 0x6a,
	0xfa, 0x80, 0x8e, 0x1d, 0xdd, 0x99, 0x2e, 0x70, 0x57, 0x3e, 0x81, 0x7c, 0xcf, 0xa6, 0x56, 0xc7,
	0xa4, 0x7d, 0xb4, 0x06, 0x59, 0x3a, 0xd2, 0xf4, 0x61, 0x49, 0xd8, 0x15, 0x2e, 0x17, 0x88, 0xbb,
	0x61, 0x56, 0xcb, 0x18, 0x52, 0xbb, 0x94, 0xde, 0x5d, 0x62, 0x56, 0xbe, 0xa9, 0x4c, 0xa1, 0xc4,
	0xe2, 0x9a, 0xda, 0x88, 0xda, 0xa6, 0xd6, 0xa7, 0x6d, 0x6a, 0x8d, 0x74, 0xdb, 0xd6, 0x8d, 0xb1,
	0x8d, 0x36, 0x61, 0x79, 0x62, 0x53, 0x4b, 0xd5, 0x07, 0x1e, 0x53, 0x8e, 0x6d, 0x95, 0x01, 0x6a,
	0xc0, 0x39, 0xad, 0xef, 0xe8, 0xc6, 0x58, 0x3d, 0xb1, 0x8c, 0x89, 0x59, 0x4a, 0xef, 0x0a, 0x97,
	0x57, 0x0e, 0xf6, 0xaa, 0xa1, 0xfa, 0xaa, 0x01, 0xa3, 0xcc, 0x91, 0x87, 0x0c, 0x48, 0x8a, 0xda,
	0x7c, 0x53, 0xf9, 0x5e, 0x00, 0x50, 0xc6, 0xa7, 0xba, 0xa3, 0x31, 0x1b, 0x12, 0x61, 0x69, 0x62,
	0xe9, 0x5e, 0x26, 0xb6, 0x44, 0x9f, 0xc1, 0xb9, 0xbe, 0x45, 0x35, 0x87, 0x0e, 0x54, 0x26, 0x0e,
	0x4f, 0x53, 0x3c, 0x28, 0x57, 0x5d, 0xe5, 0xaa, 0xbe, 0x72, 0xd5, 0xae, 0xaf, 0x1c, 0x29, 0x7a,
	0x78, 0x66, 0x41, 0x37, 0xa1, 0x48, 0xbf, 0x36, 0x75, 0x6b, 0xea, 0x46, 0x2f, 0xbd, 0x35, 0x1a,
	0x5c, 0x38, 0x33, 0x54, 0x5e, 0xa7, 0x21, 0xc3, 0x84, 0x41, 0x2b, 0x90, 0x0e, 0xea, 0x4f, 0xeb,
	0x03, 0x74, 0x05, 0x44, 0x8b, 0xda, 0xc6, 0xc4, 0xea, 0x53, 0xf5, 0x94, 0x5a, 0x4c, 0x29, 0xfe,
	0x61, 0x05, 0xb2, 0xea, 0xdb, 0x8f, 0x5d, 0x33, 0xba, 0x02, 0x19, 0xdb, 0xa4, 0x7d, 0x2f, 0xf3,
	0x7a, 0x44, 0x1e, 0xff, 0xb0, 0x08, 0x87, 0xa0, 0x6b, 0x90, 0xb5, 0x1d, 0xcd, 0xa1, 0xa5, 0x0c,
	0x97, 0x72, 0x63, 0x11, 0xcb, 0xbc, 0xc4, 0x05, 0xa1, 0x1d, 0x00, 0x8b, 0x7e, 0x35, 0xa1, 0xb6,
	0xc3, 0xce, 0x26, 0xcb, 0xb3, 0x17, 0x3c, 0x8b, 0x32, 0x40, 0x9f, 0x02, 0xe8, 0x81, 0xae, 0xa5,
	0x1c, 0xcf, 0xbe, 0x19, 0x61, 0x9c, 0xcb, 0x4e, 0x42, 0xd0, 0x05, 0xc1, 0x97, 0xdf, 0x4d, 0xf0,
	0x7b, 0x80, 0x86, 0x9a, 0xed, 0xa8, 0x23, 0x63, 0xa0, 0x3f, 0xd1, 0x7d, 0x92, 0xfc, 0x5b, 0x49,
	0x44, 0x16, 0xf5, 0xc0, 0x0b, 0xe2, 0xea, 0x3f, 0x85, 0xf3, 0xc1, 0xfd, 0x21, 0xc6, 0x90, 0xf2,
	0x6b, 0xbd, 0x0d, 0x85, 0xb1, 0x6f, 0xf4, 0x0e, 0x64, 0x6e, 0x78, 0x4f, 0x77, 0xb2, 0x07, 0xab,
	0x72, 0xbf, 0x6f, 0x4c, 0xc6, 0x4e, 0x90, 0xf6, 0x4e, 0x8c, 0x58, 0xe0, 0xc4, 0x17, 0x23, 0xc4,
	0x5e, 0xcc, 0x99, 0xb4, 0xdf, 0x09, 0x90, 0x0f, 0x08, 0x6f, 0x33, 0x42, 0x8e, 0x57, 0x59, 0x0f,
	0x72, 0xc2, 0xe2, 0xc1, 0x76, 0x12, 0xa1, 0x1f, 0xc3, 0xd8, 0x02, 0x03, 0x3a, 0x84, 0xd5, 0xa0,
	0x6e, 0x75, 0xde, 0xd3, 0xc5, 0x03, 0x29, 0xb9, 0xda, 0x80, 0x65, 0x65, 0x1c, 0x36, 0xd9, 0x95,
	0x21, 0x64, 0x38, 0xe1, 0xe2, 0x1d, 0xcf, 0x38, 0x53, 0x93, 0x7a, 0x1a, 0x46, 0x2f, 0x2e, 0x0b,
	0xe8, 0x4e, 0x4d, 0x4a, 0x38, 0xe4, 0x8d, 0x77, 0x3c, 0xc8, 0xcb, 0x21, 0x95, 0x3f, 0x05, 0x00,
	0xb9, 0xad, 0xdc, 0xa7, 0x53, 0x2e, 0xc3, 0x2d, 0x60, 0x45, 0x51, 0xdb, 0x56, 0x79, 0x2e, 0x57,
	0xd6, 0x9d, 0xa8, 0x0a, 0x1c, 0x2d, 0x73, 0x14, 0xcf, 0x09, 0x5a, 0xb0, 0x46, 0x7b, 0x70, 0x6e,
	0xa0, 0xdb, 0xe6, 0x50, 0x9b, 0xaa, 0xac, 0x2c, 0xaf, 0x09, 0x8b, 0x9e, 0x8d, 0x15, 0x8f, 0x76,
	0xa1, 0x38, 0xa0, 0x76, 0xdf, 0xd2, 0x4d, 0xde, 0x09, 0x4b, 0x1e, 0x62, 0x6e, 0x8a, 0xcf, 0x88,
	0xcc, 0xbb, 0xcc, 0x08, 0x54, 0x86, 0xfc, 0x40, 0xb7, 0xb5, 0xc7, 0x43, 0xea, 0x36, 0x61, 0x9e,
	0x04, 0xfb, 0x8a, 0x0a, 0xd9, 0xd6, 0xd3, 0x31, 0xb5, 0xd0, 0x16, 0xe4, 0x0d, 0xb6, 0x98, 0x4f,
	0xd1, 0x65, 0xbe, 0x57, 0x06, 0xe8, 0x26, 0x80, 0xeb, 0x0a, 0x89, 0xbd, 0x9d, 0x20, 0x00, 0x27,
	0xe2, 0xf5, 0x17, 0x0c, 0x7f, 0x59, 0xf9, 0x2b, 0x0d, 0x39, 0xd7, 0xbd, 0x70, 0x7c, 0x97, 0x21,
	0xcb, 0x71, 0xde, 0xc0, 0x44, 0x11, 0x4a, 0x4e, 0x46, 0x5c, 0x00, 0xba, 0x1a, 0x39, 0xbd, 0xcd,
	0x84, 0xdc, 0xa1, 0x19, 0x95, 0x34, 0xf9, 0x32, 0xc9, 0x93, 0xaf, 0xea, 0x8f, 0xb3, 0x2c, 0x2f,
	0xaa, 0x94, 0x44, 0x7c, 0xf6, 0x40, 0xcb, 0xc5, 0x07, 0xda, 0xff, 0x66, 0x2e, 0xfd, 0x96, 0x86,
	0x95, 0x0e, 0xb5, 0x4e, 0x75, 0x36, 0x42, 0x78, 0x43, 0xfe, 0x97, 0xf7, 0xe1, 0x46, 0x44, 0xfd,
	0xe8, 0x44, 0x89, 0x66, 0x09, 0x9d, 0xc2, 0x5a, 0xf8, 0xa5, 0x28, 0xf8, 0x02, 0x5e, 0x03, 0xa4,
	0xd9, 0xd3, 0x71, 0x5f, 0x35, 0x4c, 0x6a, 0xf1, 0x61, 0x3e, 0x7f, 0x19, 0x44, 0xee, 0x69, 0xf9,
	0x8e, 0x04, 0x3d, 0x73, 0xef, 0x43, 0xcf, 0xe5, 0x7f, 0xa1, 0xe7, 0x4f, 0x02, 0xa0, 0xc5, 0x4a,
	0x11, 0x82, 0x0c, 0x6f, 0x69, 0x57, 0x55, 0xbe, 0x46, 0xb7, 0x20, 0xe7, 0x36, 0xbf, 0x77, 0xab,
	0x2f, 0x55, 0xfd, 0xdf, 0x47, 0x5c, 0x37, 0xfe, 0xfb, 0xa8, 0xea, 0xff, 0x3e, 0xf2, 0x46, 0x28,
	0xb5, 0x6d, 0xe2, 0x45, 0xfd, 0x83, 0x59, 0x10, 0x6e, 0xe7, 0x4c, 0xb4, 0x9d, 0xf7, 0x5f, 0x0b,
	0x50, 0x08, 0x9e, 0x61, 0x54, 0x86, 0x8d, 0x5e, 0x07, 0x13, 0xb5, 0xd3, 0x95, 0xbb, 0x58, 0xed,
	0x35, 0x3b, 0x6d, 0x5c, 0x57, 0xee, 0x2a, 0xb8, 0x21, 0xa6, 0xd0, 0x26, 0x5c, 0x08, 0xf9, 0xea,
	0x04, 0xcb, 0x5d, 0xa5, 0x79, 0x28, 0x0a, 0x68, 0x1b, 0x4a, 0x71, 0x07, 0x56, 0xef, 0xca, 0xca,
	0x11, 0x6e, 0x88, 0x69, 0xb4, 0x0e, 0xe7, 0x43, 0x5e, 0xb9, 0xde, 0x55, 0x8e, 0xb1, 0xb8, 0x14,
	0x63, 0xeb, 0xb5, 0x1b, 0x2e, 0x5b, 0x26, 0xc6, 0xc6, 0x1d, 0x01, 0x5b, 0x36, 0x16, 0xd6, 0xc0,
	0x47, 0x98, 0x87, 0xe5, 0x62, 0x61, 0xdc, 0x11, 0x84, 0x2d, 0xa3, 0x0d, 0x40, 0x0b, 0xde, 0x86,
	0x98, 0xdf, 0xbf, 0xed, 0xbe, 0x5e, 0x7c, 0xec, 0x6e, 0xc1, 0x3a, 0x69, 0x1d, 0x61, 0xb5, 0xfb,
	0xa8, 0x1d, 0x2f, 0xbd, 0x04, 0x6b, 0x73, 0x57, 0x9b, 0xe0, 0x06, 0xbe, 0xab, 0x34, 0x71, 0x43,
	0x14, 0xf6, 0x7f, 0x14, 0x60, 0x2d, 0xe9, 0xf1, 0x45, 0x97, 0xa0, 0xd2, 0x94, 0x1f, 0xe0, 0x4e,
	0x5b, 0xae, 0xbb, 0x55, 0xb7, 0x9a, 0xea, 0x21, 0x69, 0xf5, 0xda, 0x31, 0xea, 0x5d, 0xd8, 0x3e,
	0x03, 0x27, 0x37, 0x1e, 0x28, 0x4d, 0x51, 0x78, 0x03, 0xe2, 0x21, 0x51, 0xba, 0x58, 0x4c, 0xa3,
	0x8b, 0xf0, 0xc1, 0x19, 0x08, 0x82, 0xe5, 0x86, 0xb8, 0xb4, 0xff, 0x83, 0x00, 0x68, 0xf1, 0x25,
	0x47, 0x1f, 0xc2, 0xae, 0x5c, 0xaf, 0xb7, 0x7a, 0xcd, 0xee, 0x9b, 0xbe, 0x50, 0x82, 0x72, 0x22,
	0xca, 0xff, 0xbe, 0x0a, 0x48, 0x89, 0xfe, 0x06, 0x3e, 0xc6, 0x47, 0xad, 0x36, 0x26, 0x62, 0x1a,
	0xed, 0xc0, 0x56, 0x22, 0xc6, 0xfb, 0xbe, 0x3e, 0x88, 0xf1, 0x17, 0x91, 0xd3, 0xb6, 0x95, 0xfb,
	0xf8, 0x91, 0x2a, 0xd7, 0xeb, 0xb8, 0xd3, 0x49, 0x3a, 0x97, 0xab, 0xf0, 0x71, 0x02, 0x46, 0x69,
	0xde, 0xc3, 0x44, 0xe9, 0xaa, 0xad, 0x87, 0x4d, 0x4c, 0x3c, 0x8f, 0x28, 0xec, 0x3f, 0x85, 0xd5,
	0xd8, 0xab, 0x83, 0xf6, 0x60, 0xc7, 0x8b, 0x77, 0xb1, 0x09, 0x29, 0xca, 0xb0, 0x91, 0x00, 0xe9,
	0x60, 0x22, 0x0a, 0xe8, 0x23, 0xd8, 0x5b, 0xf4, 0x75, 0x30, 0x39, 0x56, 0xf8, 0x39, 0xf0, 0x7a,
	0xc5, 0xf4, 0xfe, 0x2f, 0x69, 0x28, 0x86, 0x9e, 0x06, 0x76, 0x55, 0xbd, 0xb0, 0xa4, 0x36, 0xdb,
	0x82, 0xf5, 0x88, 0x37, 0xd4, 0x68, 0xec, 0x24, 0x16, 0x5c, 0xa1, 0x56, 0xdb, 0x84, 0x0b, 0x11,
	0x7f, 0xd0, 0x6c, 0x71, 0xce, 0x50, 0xbb, 0xc5, 0x39, 0xe3, 0x0d, 0x57, 0x82, 0xb5, 0x88, 0x1f,
	0x7f, 0xde, 0x56, 0x08, 0x6e, 0x88, 0xb9, 0x05, 0xd2, 0xa0, 0x19, 0x97, 0x17, 0x48, 0xa3, 0xed,
	0x98, 0x5f, 0x20, 0xf5, 0x1b, 0xb2, 0x70, 0x87, 0x3c, 0x7b, 0x21, 0xa5, 0x9e, 0xbf, 0x90, 0x52,
	0xaf, 0x5e, 0x48, 0xc2, 0x37, 0x33, 0x49, 0xf8, 0x79, 0x26, 0x09, 0xbf, 0xce, 0x24, 0xe1, 0xd9,
	0x4c, 0x12, 0x7e, 0x9f, 0x49, 0xc2, 0x1f, 0x33, 0x29, 0xf5, 0x6a, 0x26, 0x09, 0xdf, 0xbe, 0x94,
	0x52, 0xcf, 0x5e, 0x4a, 0xa9, 0xe7, 0x2f, 0xa5, 0xd4, 0x17, 0xdb, 0xce, 0xc8, 0xb4, 0x86, 0xee,
	0xa8, 0xac, 0x85, 0xfe, 0x4d, 0xbd, 0xc9, 0xfe, 0x3e, 0xce, 0xf1, 0x89, 0x7d, 0xe3, 0xef, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xa9, 0xba, 0x01, 0x99, 0xc1, 0x0e, 0x00, 0x00,
}

func (x UserState) String() string {
	s, ok := UserState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RoleType) String() string {
	s, ok := RoleType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NamespaceActionGroup) String() string {
	s, ok := NamespaceActionGroup_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AccountActionGroup) String() string {
	s, ok := AccountActionGroup_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x APIKeyAccessType) String() string {
	s, ok := APIKeyAccessType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x APIKeyOwnerType) String() string {
	s, ok := APIKeyOwnerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x APIKeyState) String() string {
	s, ok := APIKeyState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *UserSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserSpec)
	if !ok {
		that2, ok := that.(UserSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return false
		}
	}
	return true
}
func (this *UserNamespacePermissions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserNamespacePermissions)
	if !ok {
		that2, ok := that.(UserNamespacePermissions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.ActionGroup != that1.ActionGroup {
		return false
	}
	return true
}
func (this *Invitation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Invitation)
	if !ok {
		that2, ok := that.(Invitation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uri != that1.Uri {
		return false
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.ExpiryTime.Equal(that1.ExpiryTime) {
		return false
	}
	return true
}
func (this *User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*User)
	if !ok {
		that2, ok := that.(User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.RequestId != that1.RequestId {
		return false
	}
	if !this.Invitation.Equal(that1.Invitation) {
		return false
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.LastModifiedTime.Equal(that1.LastModifiedTime) {
		return false
	}
	return true
}
func (this *NamespaceRoleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRoleSpec)
	if !ok {
		that2, ok := that.(NamespaceRoleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ActionGroup != that1.ActionGroup {
		return false
	}
	return true
}
func (this *AccountRoleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountRoleSpec)
	if !ok {
		that2, ok := that.(AccountRoleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActionGroup != that1.ActionGroup {
		return false
	}
	return true
}
func (this *RoleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleSpec)
	if !ok {
		that2, ok := that.(RoleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccountRole.Equal(that1.AccountRole) {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	return true
}
func (this *Role) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Role)
	if !ok {
		that2, ok := that.(Role)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *APIKeySpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*APIKeySpec)
	if !ok {
		that2, ok := that.(APIKeySpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccessType != that1.AccessType {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.ExpiryTime.Equal(that1.ExpiryTime) {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	return true
}
func (this *Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Owner)
	if !ok {
		that2, ok := that.(Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OwnerId != that1.OwnerId {
		return false
	}
	if this.OwnerType != that1.OwnerType {
		return false
	}
	return true
}
func (this *APIKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*APIKey)
	if !ok {
		that2, ok := that.(APIKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Owner.Equal(that1.Owner) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.RequestId != that1.RequestId {
		return false
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.LastModifiedTime.Equal(that1.LastModifiedTime) {
		return false
	}
	return true
}
func (this *ServiceAccount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceAccount)
	if !ok {
		that2, ok := that.(ServiceAccount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.AsyncOperationId != that1.AsyncOperationId {
		return false
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.LastModifiedTime.Equal(that1.LastModifiedTime) {
		return false
	}
	return true
}
func (this *ServiceAccountSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceAccountSpec)
	if !ok {
		that2, ok := that.(ServiceAccountSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Access.Equal(that1.Access) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	return true
}
func (this *UserSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.UserSpec{")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Roles: "+fmt.Sprintf("%#v", this.Roles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserNamespacePermissions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.UserNamespacePermissions{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ActionGroup: "+fmt.Sprintf("%#v", this.ActionGroup)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Invitation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&auth.Invitation{")
	s = append(s, "Uri: "+fmt.Sprintf("%#v", this.Uri)+",\n")
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.ExpiryTime != nil {
		s = append(s, "ExpiryTime: "+fmt.Sprintf("%#v", this.ExpiryTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *User) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&auth.User{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "RequestId: "+fmt.Sprintf("%#v", this.RequestId)+",\n")
	if this.Invitation != nil {
		s = append(s, "Invitation: "+fmt.Sprintf("%#v", this.Invitation)+",\n")
	}
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.LastModifiedTime != nil {
		s = append(s, "LastModifiedTime: "+fmt.Sprintf("%#v", this.LastModifiedTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRoleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.NamespaceRoleSpec{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ActionGroup: "+fmt.Sprintf("%#v", this.ActionGroup)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountRoleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&auth.AccountRoleSpec{")
	s = append(s, "ActionGroup: "+fmt.Sprintf("%#v", this.ActionGroup)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.RoleSpec{")
	if this.AccountRole != nil {
		s = append(s, "AccountRole: "+fmt.Sprintf("%#v", this.AccountRole)+",\n")
	}
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Role) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&auth.Role{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *APIKeySpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&auth.APIKeySpec{")
	s = append(s, "AccessType: "+fmt.Sprintf("%#v", this.AccessType)+",\n")
	s = append(s, "DisplayName: "+fmt.Sprintf("%#v", this.DisplayName)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.ExpiryTime != nil {
		s = append(s, "ExpiryTime: "+fmt.Sprintf("%#v", this.ExpiryTime)+",\n")
	}
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Owner) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.Owner{")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	s = append(s, "OwnerType: "+fmt.Sprintf("%#v", this.OwnerType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *APIKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&auth.APIKey{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Owner != nil {
		s = append(s, "Owner: "+fmt.Sprintf("%#v", this.Owner)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "RequestId: "+fmt.Sprintf("%#v", this.RequestId)+",\n")
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.LastModifiedTime != nil {
		s = append(s, "LastModifiedTime: "+fmt.Sprintf("%#v", this.LastModifiedTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceAccount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&auth.ServiceAccount{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "AsyncOperationId: "+fmt.Sprintf("%#v", this.AsyncOperationId)+",\n")
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.LastModifiedTime != nil {
		s = append(s, "LastModifiedTime: "+fmt.Sprintf("%#v", this.LastModifiedTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceAccountSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&auth.ServiceAccountSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Access != nil {
		s = append(s, "Access: "+fmt.Sprintf("%#v", this.Access)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *UserSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserNamespacePermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserNamespacePermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserNamespacePermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionGroup != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionGroup))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Invitation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Invitation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Invitation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryTime != nil {
		{
			size, err := m.ExpiryTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModifiedTime != nil {
		{
			size, err := m.LastModifiedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Invitation != nil {
		{
			size, err := m.Invitation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceRoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRoleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceRoleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionGroup != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionGroup))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountRoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRoleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRoleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionGroup != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionGroup))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NamespaceRoles) > 0 {
		for iNdEx := len(m.NamespaceRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AccountRole != nil {
		{
			size, err := m.AccountRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Role) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *APIKeySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *APIKeySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *APIKeySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ExpiryTime != nil {
		{
			size, err := m.ExpiryTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	if m.AccessType != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.AccessType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Owner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OwnerType != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.OwnerType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.OwnerId) > 0 {
		i -= len(m.OwnerId)
		copy(dAtA[i:], m.OwnerId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.OwnerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *APIKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *APIKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *APIKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModifiedTime != nil {
		{
			size, err := m.LastModifiedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x32
	}
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModifiedTime != nil {
		{
			size, err := m.LastModifiedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.AsyncOperationId) > 0 {
		i -= len(m.AsyncOperationId)
		copy(dAtA[i:], m.AsyncOperationId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AsyncOperationId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceAccountSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceAccountSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceAccountSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Access != nil {
		{
			size, err := m.Access.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *UserNamespacePermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ActionGroup != 0 {
		n += 1 + sovMessage(uint64(m.ActionGroup))
	}
	return n
}

func (m *Invitation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ExpiryTime != nil {
		l = m.ExpiryTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Invitation != nil {
		l = m.Invitation.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LastModifiedTime != nil {
		l = m.LastModifiedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *NamespaceRoleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ActionGroup != 0 {
		n += 1 + sovMessage(uint64(m.ActionGroup))
	}
	return n
}

func (m *AccountRoleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionGroup != 0 {
		n += 1 + sovMessage(uint64(m.ActionGroup))
	}
	return n
}

func (m *RoleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountRole != nil {
		l = m.AccountRole.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *Role) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *APIKeySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessType != 0 {
		n += 1 + sovMessage(uint64(m.AccessType))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ExpiryTime != nil {
		l = m.ExpiryTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	return n
}

func (m *Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OwnerId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.OwnerType != 0 {
		n += 1 + sovMessage(uint64(m.OwnerType))
	}
	return n
}

func (m *APIKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LastModifiedTime != nil {
		l = m.LastModifiedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ServiceAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AsyncOperationId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LastModifiedTime != nil {
		l = m.LastModifiedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *ServiceAccountSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Access != nil {
		l = m.Access.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UserSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserSpec{`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Roles:` + fmt.Sprintf("%v", this.Roles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserNamespacePermissions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserNamespacePermissions{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`ActionGroup:` + fmt.Sprintf("%v", this.ActionGroup) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Invitation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Invitation{`,
		`Uri:` + fmt.Sprintf("%v", this.Uri) + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`ExpiryTime:` + strings.Replace(fmt.Sprintf("%v", this.ExpiryTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *User) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&User{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "UserSpec", "UserSpec", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`RequestId:` + fmt.Sprintf("%v", this.RequestId) + `,`,
		`Invitation:` + strings.Replace(this.Invitation.String(), "Invitation", "Invitation", 1) + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastModifiedTime:` + strings.Replace(fmt.Sprintf("%v", this.LastModifiedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRoleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRoleSpec{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ActionGroup:` + fmt.Sprintf("%v", this.ActionGroup) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountRoleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccountRoleSpec{`,
		`ActionGroup:` + fmt.Sprintf("%v", this.ActionGroup) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoleSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRoles := "[]*NamespaceRoleSpec{"
	for _, f := range this.NamespaceRoles {
		repeatedStringForNamespaceRoles += strings.Replace(f.String(), "NamespaceRoleSpec", "NamespaceRoleSpec", 1) + ","
	}
	repeatedStringForNamespaceRoles += "}"
	s := strings.Join([]string{`&RoleSpec{`,
		`AccountRole:` + strings.Replace(this.AccountRole.String(), "AccountRoleSpec", "AccountRoleSpec", 1) + `,`,
		`NamespaceRoles:` + repeatedStringForNamespaceRoles + `,`,
		`}`,
	}, "")
	return s
}
func (this *Role) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Role{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "RoleSpec", "RoleSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *APIKeySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&APIKeySpec{`,
		`AccessType:` + fmt.Sprintf("%v", this.AccessType) + `,`,
		`DisplayName:` + fmt.Sprintf("%v", this.DisplayName) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`ExpiryTime:` + strings.Replace(fmt.Sprintf("%v", this.ExpiryTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Owner) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Owner{`,
		`OwnerId:` + fmt.Sprintf("%v", this.OwnerId) + `,`,
		`OwnerType:` + fmt.Sprintf("%v", this.OwnerType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *APIKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&APIKey{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Owner:` + strings.Replace(this.Owner.String(), "Owner", "Owner", 1) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "APIKeySpec", "APIKeySpec", 1) + `,`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`RequestId:` + fmt.Sprintf("%v", this.RequestId) + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastModifiedTime:` + strings.Replace(fmt.Sprintf("%v", this.LastModifiedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceAccount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceAccount{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "ServiceAccountSpec", "ServiceAccountSpec", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`AsyncOperationId:` + fmt.Sprintf("%v", this.AsyncOperationId) + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastModifiedTime:` + strings.Replace(fmt.Sprintf("%v", this.LastModifiedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceAccountSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceAccountSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Access:` + strings.Replace(fmt.Sprintf("%v", this.Access), "Access", "v1.Access", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UserSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserNamespacePermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserNamespacePermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserNamespacePermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionGroup", wireType)
			}
			m.ActionGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionGroup |= NamespaceActionGroup(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Invitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryTime == nil {
				m.ExpiryTime = &types.Timestamp{}
			}
			if err := m.ExpiryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &UserSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= UserState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invitation == nil {
				m.Invitation = &Invitation{}
			}
			if err := m.Invitation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifiedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifiedTime == nil {
				m.LastModifiedTime = &types.Timestamp{}
			}
			if err := m.LastModifiedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionGroup", wireType)
			}
			m.ActionGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionGroup |= NamespaceActionGroup(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountRoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionGroup", wireType)
			}
			m.ActionGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionGroup |= AccountActionGroup(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountRole == nil {
				m.AccountRole = &AccountRoleSpec{}
			}
			if err := m.AccountRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &NamespaceRoleSpec{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RoleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &RoleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *APIKeySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: APIKeySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: APIKeySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessType", wireType)
			}
			m.AccessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessType |= APIKeyAccessType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryTime == nil {
				m.ExpiryTime = &types.Timestamp{}
			}
			if err := m.ExpiryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Owner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Owner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Owner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerType", wireType)
			}
			m.OwnerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerType |= APIKeyOwnerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *APIKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: APIKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: APIKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &Owner{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &APIKeySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= APIKeyState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifiedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifiedTime == nil {
				m.LastModifiedTime = &types.Timestamp{}
			}
			if err := m.LastModifiedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ServiceAccountSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncOperationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsyncOperationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifiedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifiedTime == nil {
				m.LastModifiedTime = &types.Timestamp{}
			}
			if err := m.LastModifiedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAccountSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAccountSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAccountSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Access == nil {
				m.Access = &v1.Access{}
			}
			if err := m.Access.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
