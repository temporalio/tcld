// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/auth/v1/message.proto

package auth

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"

	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UserState int32

const (
	USER_STATE_UNSPECIFIED UserState = 0
	// user is being created by the system
	USER_STATE_CREATING UserState = 1
	// user create operation failed
	USER_STATE_CREATE_FAILED UserState = 2
	// the user exists in the system (includes user with an outstanding invite)
	USER_STATE_ACTIVE UserState = 3
	// user is being udpate
	USER_STATE_UPDATING UserState = 4
	// the last user update failed
	USER_STATE_UPDATE_FAILED UserState = 5
	// the user is being deleted
	USER_STATE_DELETING UserState = 6
	// the user delete opertion failed
	USER_STATE_DELETE_FAILED UserState = 7
	// the user is successfully deleted
	USER_STATE_DELETED UserState = 8
)

var UserState_name = map[int32]string{
	0: "Unspecified",
	1: "Creating",
	2: "CreateFailed",
	3: "Active",
	4: "Updating",
	5: "UpdateFailed",
	6: "Deleting",
	7: "DeleteFailed",
	8: "Deleted",
}

var UserState_value = map[string]int32{
	"Unspecified":  0,
	"Creating":     1,
	"CreateFailed": 2,
	"Active":       3,
	"Updating":     4,
	"UpdateFailed": 5,
	"Deleting":     6,
	"DeleteFailed": 7,
	"Deleted":      8,
}

func (UserState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{0}
}

type RoleType int32

const (
	ROLE_TYPE_UNSPECIFIED RoleType = 0
	// a predefined role
	ROLE_TYPE_PREDEFINED RoleType = 1
)

var RoleType_name = map[int32]string{
	0: "Unspecified",
	1: "Predefined",
}

var RoleType_value = map[string]int32{
	"Unspecified": 0,
	"Predefined":  1,
}

func (RoleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{1}
}

type NamespaceActionGroup int32

const (
	NAMESPACE_ACTION_GROUP_UNSPECIFIED NamespaceActionGroup = 0
	// admin access to the namespace
	NAMESPACE_ACTION_GROUP_ADMIN NamespaceActionGroup = 1
	// write access to the namespace
	NAMESPACE_ACTION_GROUP_WRITE NamespaceActionGroup = 2
	// read-only access to the namesapce
	NAMESPACE_ACTION_GROUP_READ NamespaceActionGroup = 3
)

var NamespaceActionGroup_name = map[int32]string{
	0: "Unspecified",
	1: "Admin",
	2: "Write",
	3: "Read",
}

var NamespaceActionGroup_value = map[string]int32{
	"Unspecified": 0,
	"Admin":       1,
	"Write":       2,
	"Read":        3,
}

func (NamespaceActionGroup) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{2}
}

type AccountActionGroup int32

const (
	ACCOUNT_ACTION_GROUP_UNSPECIFIED AccountActionGroup = 0
	// global admin
	ACCOUNT_ACTION_GROUP_ADMIN AccountActionGroup = 1
	// write access to all namespaces
	ACCOUNT_ACTION_GROUP_DEVELOPER AccountActionGroup = 2
	// read-only access to all namespaces
	ACCOUNT_ACTION_GROUP_READ AccountActionGroup = 3
)

var AccountActionGroup_name = map[int32]string{
	0: "Unspecified",
	1: "Admin",
	2: "Developer",
	3: "Read",
}

var AccountActionGroup_value = map[string]int32{
	"Unspecified": 0,
	"Admin":       1,
	"Developer":   2,
	"Read":        3,
}

func (AccountActionGroup) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{3}
}

type UserSpec struct {
	// the email address associated to the user
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// the roles assigned to the user
	Roles []string `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *UserSpec) Reset()      { *m = UserSpec{} }
func (*UserSpec) ProtoMessage() {}
func (*UserSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{0}
}
func (m *UserSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSpec.Merge(m, src)
}
func (m *UserSpec) XXX_Size() int {
	return m.Size()
}
func (m *UserSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSpec.DiscardUnknown(m)
}

var xxx_messageInfo_UserSpec proto.InternalMessageInfo

func (m *UserSpec) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserSpec) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// should be used along side namespace_id to determine permissions set for a user
type UserNamespacePermissions struct {
	// the user to set namespace permissions for
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// the namespace action groups to set for the user
	ActionGroups []NamespaceActionGroup `protobuf:"varint,2,rep,packed,name=action_groups,json=actionGroups,proto3,enum=api.auth.v1.NamespaceActionGroup" json:"action_groups,omitempty"`
}

func (m *UserNamespacePermissions) Reset()      { *m = UserNamespacePermissions{} }
func (*UserNamespacePermissions) ProtoMessage() {}
func (*UserNamespacePermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{1}
}
func (m *UserNamespacePermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserNamespacePermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserNamespacePermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserNamespacePermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserNamespacePermissions.Merge(m, src)
}
func (m *UserNamespacePermissions) XXX_Size() int {
	return m.Size()
}
func (m *UserNamespacePermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_UserNamespacePermissions.DiscardUnknown(m)
}

var xxx_messageInfo_UserNamespacePermissions proto.InternalMessageInfo

func (m *UserNamespacePermissions) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *UserNamespacePermissions) GetActionGroups() []NamespaceActionGroup {
	if m != nil {
		return m.ActionGroups
	}
	return nil
}

type Invitation struct {
	// the uri of the invitation sent to the user
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// the date and time when the user was created
	CreatedTime *types.Timestamp `protobuf:"bytes,2,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// the date and time when the invitation expires or has expired
	ExpiryTime *types.Timestamp `protobuf:"bytes,3,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
}

func (m *Invitation) Reset()      { *m = Invitation{} }
func (*Invitation) ProtoMessage() {}
func (*Invitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{2}
}
func (m *Invitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Invitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Invitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Invitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Invitation.Merge(m, src)
}
func (m *Invitation) XXX_Size() int {
	return m.Size()
}
func (m *Invitation) XXX_DiscardUnknown() {
	xxx_messageInfo_Invitation.DiscardUnknown(m)
}

var xxx_messageInfo_Invitation proto.InternalMessageInfo

func (m *Invitation) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Invitation) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *Invitation) GetExpiryTime() *types.Timestamp {
	if m != nil {
		return m.ExpiryTime
	}
	return nil
}

type User struct {
	// the id of the user
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the current version of the user specification
	// the next update request will have to include this version
	ResourceVersion string `protobuf:"bytes,2,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// the user specification
	Spec *UserSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	// the current state of the user
	State UserState `protobuf:"varint,4,opt,name=state,proto3,enum=api.auth.v1.UserState" json:"state,omitempty"`
	// the id of the request that is creating/updating/deleting the user, if any
	RequestId string `protobuf:"bytes,5,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// the details of the open invitation sent to the user, if any
	Invitation *Invitation `protobuf:"bytes,6,opt,name=invitation,proto3" json:"invitation,omitempty"`
	// the date and time when the user was created
	CreatedTime *types.Timestamp `protobuf:"bytes,7,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// the date and time when the user was last modified
	LastModifiedTime *types.Timestamp `protobuf:"bytes,8,opt,name=last_modified_time,json=lastModifiedTime,proto3" json:"last_modified_time,omitempty"`
}

func (m *User) Reset()      { *m = User{} }
func (*User) ProtoMessage() {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{3}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *User) GetSpec() *UserSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *User) GetState() UserState {
	if m != nil {
		return m.State
	}
	return USER_STATE_UNSPECIFIED
}

func (m *User) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *User) GetInvitation() *Invitation {
	if m != nil {
		return m.Invitation
	}
	return nil
}

func (m *User) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *User) GetLastModifiedTime() *types.Timestamp {
	if m != nil {
		return m.LastModifiedTime
	}
	return nil
}

type NamespaceRoleSpec struct {
	// the namespace the role is defined for
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// the action group to enable for the namepspace
	ActionGroup NamespaceActionGroup `protobuf:"varint,2,opt,name=action_group,json=actionGroup,proto3,enum=api.auth.v1.NamespaceActionGroup" json:"action_group,omitempty"`
}

func (m *NamespaceRoleSpec) Reset()      { *m = NamespaceRoleSpec{} }
func (*NamespaceRoleSpec) ProtoMessage() {}
func (*NamespaceRoleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{4}
}
func (m *NamespaceRoleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceRoleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceRoleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceRoleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceRoleSpec.Merge(m, src)
}
func (m *NamespaceRoleSpec) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceRoleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceRoleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceRoleSpec proto.InternalMessageInfo

func (m *NamespaceRoleSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NamespaceRoleSpec) GetActionGroup() NamespaceActionGroup {
	if m != nil {
		return m.ActionGroup
	}
	return NAMESPACE_ACTION_GROUP_UNSPECIFIED
}

type AccountRoleSpec struct {
	// the action group to enable for the account
	ActionGroup AccountActionGroup `protobuf:"varint,1,opt,name=action_group,json=actionGroup,proto3,enum=api.auth.v1.AccountActionGroup" json:"action_group,omitempty"`
}

func (m *AccountRoleSpec) Reset()      { *m = AccountRoleSpec{} }
func (*AccountRoleSpec) ProtoMessage() {}
func (*AccountRoleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{5}
}
func (m *AccountRoleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRoleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRoleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRoleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRoleSpec.Merge(m, src)
}
func (m *AccountRoleSpec) XXX_Size() int {
	return m.Size()
}
func (m *AccountRoleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRoleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRoleSpec proto.InternalMessageInfo

func (m *AccountRoleSpec) GetActionGroup() AccountActionGroup {
	if m != nil {
		return m.ActionGroup
	}
	return ACCOUNT_ACTION_GROUP_UNSPECIFIED
}

type RoleSpec struct {
	// the global account role
	AccountRole *AccountRoleSpec `protobuf:"bytes,1,opt,name=account_role,json=accountRole,proto3" json:"account_role,omitempty"`
	// the list of namespace roles
	NamespaceRole []*NamespaceRoleSpec `protobuf:"bytes,2,rep,name=namespace_role,json=namespaceRole,proto3" json:"namespace_role,omitempty"`
}

func (m *RoleSpec) Reset()      { *m = RoleSpec{} }
func (*RoleSpec) ProtoMessage() {}
func (*RoleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{6}
}
func (m *RoleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleSpec.Merge(m, src)
}
func (m *RoleSpec) XXX_Size() int {
	return m.Size()
}
func (m *RoleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RoleSpec proto.InternalMessageInfo

func (m *RoleSpec) GetAccountRole() *AccountRoleSpec {
	if m != nil {
		return m.AccountRole
	}
	return nil
}

func (m *RoleSpec) GetNamespaceRole() []*NamespaceRoleSpec {
	if m != nil {
		return m.NamespaceRole
	}
	return nil
}

type Role struct {
	// the id of the role
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the role type
	Type RoleType `protobuf:"varint,2,opt,name=type,proto3,enum=api.auth.v1.RoleType" json:"type,omitempty"`
	// the specification of the role
	Spec *RoleSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Role) Reset()      { *m = Role{} }
func (*Role) ProtoMessage() {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_bea184b0c3eae56b, []int{7}
}
func (m *Role) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Role.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return m.Size()
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Role) GetType() RoleType {
	if m != nil {
		return m.Type
	}
	return ROLE_TYPE_UNSPECIFIED
}

func (m *Role) GetSpec() *RoleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func init() {
	proto.RegisterEnum("api.auth.v1.UserState", UserState_name, UserState_value)
	proto.RegisterEnum("api.auth.v1.RoleType", RoleType_name, RoleType_value)
	proto.RegisterEnum("api.auth.v1.NamespaceActionGroup", NamespaceActionGroup_name, NamespaceActionGroup_value)
	proto.RegisterEnum("api.auth.v1.AccountActionGroup", AccountActionGroup_name, AccountActionGroup_value)
	proto.RegisterType((*UserSpec)(nil), "api.auth.v1.UserSpec")
	proto.RegisterType((*UserNamespacePermissions)(nil), "api.auth.v1.UserNamespacePermissions")
	proto.RegisterType((*Invitation)(nil), "api.auth.v1.Invitation")
	proto.RegisterType((*User)(nil), "api.auth.v1.User")
	proto.RegisterType((*NamespaceRoleSpec)(nil), "api.auth.v1.NamespaceRoleSpec")
	proto.RegisterType((*AccountRoleSpec)(nil), "api.auth.v1.AccountRoleSpec")
	proto.RegisterType((*RoleSpec)(nil), "api.auth.v1.RoleSpec")
	proto.RegisterType((*Role)(nil), "api.auth.v1.Role")
}

func init() { proto.RegisterFile("api/auth/v1/message.proto", fileDescriptor_bea184b0c3eae56b) }

var fileDescriptor_bea184b0c3eae56b = []byte{
	// 901 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xcf, 0x6f, 0xe3, 0x44,
	0x18, 0xcd, 0x24, 0xe9, 0x8f, 0x7c, 0xe9, 0x76, 0xbd, 0x43, 0x7f, 0xa4, 0x25, 0xeb, 0x86, 0x08,
	0xa1, 0x6e, 0x85, 0x1c, 0x6d, 0x90, 0xe0, 0xb0, 0x42, 0x2b, 0x6f, 0x3c, 0x2d, 0x96, 0xda, 0x24,
	0x9a, 0x38, 0x45, 0x70, 0xb1, 0xbc, 0xce, 0x6c, 0xb1, 0x94, 0xc4, 0xc6, 0x3f, 0x0a, 0x15, 0x17,
	0xfe, 0x04, 0xc4, 0x11, 0x89, 0x13, 0x17, 0xfe, 0x14, 0x8e, 0x3d, 0xee, 0x91, 0xa6, 0x17, 0x8e,
	0x7b, 0xdf, 0x0b, 0x9a, 0xb1, 0xe3, 0xa6, 0x4e, 0xda, 0xc2, 0x29, 0x99, 0xf7, 0xbd, 0xf7, 0xbe,
	0x99, 0x37, 0xdf, 0x24, 0xb0, 0x63, 0x79, 0x4e, 0xc3, 0x8a, 0xc2, 0xef, 0x1a, 0xe7, 0xcf, 0x1b,
	0x23, 0x16, 0x04, 0xd6, 0x19, 0x53, 0x3c, 0xdf, 0x0d, 0x5d, 0x5c, 0xb6, 0x3c, 0x47, 0xe1, 0x25,
	0xe5, 0xfc, 0xf9, 0xee, 0xde, 0x99, 0xeb, 0x9e, 0x0d, 0x59, 0x43, 0x94, 0x5e, 0x47, 0x6f, 0x1a,
	0xa1, 0x33, 0x62, 0x41, 0x68, 0x8d, 0xbc, 0x98, 0x5d, 0xff, 0x1c, 0x56, 0xfb, 0x01, 0xf3, 0x7b,
	0x1e, 0xb3, 0xf1, 0x06, 0x2c, 0xb1, 0x91, 0xe5, 0x0c, 0x2b, 0xa8, 0x86, 0xf6, 0x4b, 0x34, 0x5e,
	0x70, 0xd4, 0x77, 0x87, 0x2c, 0xa8, 0xe4, 0x6b, 0x05, 0x8e, 0x8a, 0x45, 0xfd, 0x27, 0xa8, 0x70,
	0x5d, 0xdb, 0x1a, 0xb1, 0xc0, 0xb3, 0x6c, 0xd6, 0x65, 0xfe, 0xc8, 0x09, 0x02, 0xc7, 0x1d, 0x07,
	0x78, 0x1b, 0x56, 0xa2, 0x80, 0xf9, 0xa6, 0x33, 0x48, 0x9c, 0x96, 0xf9, 0x52, 0x1f, 0xe0, 0x43,
	0x78, 0x64, 0xd9, 0xa1, 0xe3, 0x8e, 0xcd, 0x33, 0xdf, 0x8d, 0xbc, 0xd8, 0x72, 0xbd, 0xf9, 0x91,
	0x32, 0xb3, 0x65, 0x25, 0xb5, 0x54, 0x05, 0xf5, 0x88, 0x33, 0xe9, 0x9a, 0x75, 0xb3, 0x08, 0xea,
	0xbf, 0x21, 0x00, 0x7d, 0x7c, 0xee, 0x84, 0x16, 0x07, 0xb1, 0x04, 0x85, 0xc8, 0x77, 0x92, 0x5e,
	0xfc, 0x2b, 0xfe, 0x12, 0xd6, 0x6c, 0x9f, 0x59, 0x21, 0x1b, 0x98, 0xfc, 0xc0, 0x95, 0x7c, 0x0d,
	0xed, 0x97, 0x9b, 0xbb, 0x4a, 0x9c, 0x86, 0x32, 0x4d, 0x43, 0x31, 0xa6, 0x69, 0xd0, 0x72, 0xc2,
	0xe7, 0x08, 0x7e, 0x01, 0x65, 0xf6, 0xa3, 0xe7, 0xf8, 0x17, 0xb1, 0xba, 0xf0, 0xa0, 0x1a, 0x62,
	0x3a, 0x07, 0xea, 0xef, 0xf3, 0x50, 0xe4, 0xd1, 0xe0, 0x75, 0xc8, 0xa7, 0x09, 0xe4, 0x9d, 0x01,
	0x7e, 0x06, 0x92, 0xcf, 0x02, 0x37, 0xf2, 0x6d, 0x66, 0x9e, 0x33, 0x9f, 0x67, 0x25, 0x36, 0x56,
	0xa2, 0x8f, 0xa7, 0xf8, 0x69, 0x0c, 0xe3, 0x67, 0x50, 0x0c, 0x3c, 0x66, 0x27, 0x9d, 0x37, 0x6f,
	0xe5, 0x33, 0xbd, 0x2e, 0x2a, 0x28, 0xf8, 0x53, 0x58, 0x0a, 0x42, 0x2b, 0x64, 0x95, 0x62, 0x0d,
	0xed, 0xaf, 0x37, 0xb7, 0xe6, 0xb9, 0xbc, 0x4a, 0x63, 0x12, 0x7e, 0x0a, 0xe0, 0xb3, 0xef, 0x23,
	0x16, 0x84, 0xfc, 0x76, 0x96, 0x44, 0xf7, 0x52, 0x82, 0xe8, 0x03, 0xfc, 0x05, 0x80, 0x93, 0xe6,
	0x5a, 0x59, 0x16, 0xdd, 0xb7, 0x6f, 0x39, 0xde, 0xc4, 0x4e, 0x67, 0xa8, 0x73, 0x81, 0xaf, 0xfc,
	0xbf, 0xc0, 0xbf, 0x02, 0x3c, 0xb4, 0x82, 0xd0, 0x1c, 0xb9, 0x03, 0xe7, 0x8d, 0x33, 0x35, 0x59,
	0x7d, 0xd0, 0x44, 0xe2, 0xaa, 0x93, 0x44, 0x24, 0xd2, 0xff, 0x01, 0x9e, 0xa4, 0x03, 0x44, 0xdd,
	0x21, 0x13, 0x83, 0x5d, 0x85, 0xd2, 0x78, 0x0a, 0x26, 0x17, 0x72, 0x03, 0x60, 0x0d, 0xd6, 0x66,
	0xa7, 0x52, 0xdc, 0xc9, 0x7f, 0x1a, 0xca, 0xf2, 0xcc, 0x50, 0xd6, 0xfb, 0xf0, 0x58, 0xb5, 0x6d,
	0x37, 0x1a, 0x87, 0x69, 0xdb, 0x57, 0x19, 0x63, 0x24, 0x8c, 0xf7, 0x6e, 0x19, 0x27, 0x9a, 0x3b,
	0x6d, 0x7f, 0x45, 0xb0, 0x9a, 0x1a, 0xbe, 0xe4, 0x86, 0x82, 0x6f, 0xf2, 0x57, 0x28, 0x0c, 0xcb,
	0xcd, 0xea, 0x22, 0xc3, 0xa9, 0x86, 0xbb, 0xa5, 0x00, 0x26, 0xb0, 0x9e, 0x9e, 0x3b, 0xb6, 0xe0,
	0x2f, 0xb0, 0xdc, 0x94, 0x17, 0x1f, 0x36, 0x35, 0x79, 0x34, 0x9e, 0x85, 0xea, 0x43, 0x28, 0x0a,
	0xbb, 0xf9, 0x09, 0x2f, 0x86, 0x17, 0x1e, 0x4b, 0x12, 0xbc, 0x3d, 0xb6, 0x5c, 0x60, 0x5c, 0x78,
	0x8c, 0x0a, 0xca, 0xbd, 0x13, 0x9e, 0xb6, 0x15, 0x94, 0x83, 0xf7, 0x08, 0x4a, 0xe9, 0x20, 0xe3,
	0x5d, 0xd8, 0xea, 0xf7, 0x08, 0x35, 0x7b, 0x86, 0x6a, 0x10, 0xb3, 0xdf, 0xee, 0x75, 0x49, 0x4b,
	0x3f, 0xd4, 0x89, 0x26, 0xe5, 0xf0, 0x36, 0x7c, 0x30, 0x53, 0x6b, 0x51, 0xa2, 0x1a, 0x7a, 0xfb,
	0x48, 0x42, 0xb8, 0x0a, 0x95, 0x6c, 0x81, 0x98, 0x87, 0xaa, 0x7e, 0x4c, 0x34, 0x29, 0x8f, 0x37,
	0xe1, 0xc9, 0x4c, 0x55, 0x6d, 0x19, 0xfa, 0x29, 0x91, 0x0a, 0x19, 0xb7, 0x7e, 0x57, 0x8b, 0xdd,
	0x8a, 0x19, 0x37, 0x51, 0x48, 0xdd, 0x96, 0x32, 0x32, 0x8d, 0x1c, 0x13, 0x21, 0x5b, 0xce, 0xc8,
	0x44, 0x21, 0x95, 0xad, 0xe0, 0x2d, 0xc0, 0x73, 0x55, 0x4d, 0x5a, 0x3d, 0x78, 0x19, 0xdf, 0x3f,
	0x8f, 0x0e, 0xef, 0xc0, 0x26, 0xed, 0x1c, 0x13, 0xd3, 0xf8, 0xa6, 0x9b, 0x3d, 0x7a, 0x05, 0x36,
	0x6e, 0x4a, 0x5d, 0x4a, 0x34, 0x72, 0xa8, 0xb7, 0x89, 0x26, 0xa1, 0x83, 0x3f, 0x10, 0x6c, 0x2c,
	0x1a, 0x5f, 0xfc, 0x09, 0xd4, 0xdb, 0xea, 0x09, 0xe9, 0x75, 0xd5, 0x56, 0x7c, 0xea, 0x4e, 0xdb,
	0x3c, 0xa2, 0x9d, 0x7e, 0x37, 0x63, 0x5d, 0x83, 0xea, 0x1d, 0x3c, 0x55, 0x3b, 0xd1, 0xdb, 0x12,
	0xba, 0x87, 0xf1, 0x35, 0xd5, 0x0d, 0x22, 0xe5, 0xf1, 0x1e, 0x7c, 0x78, 0x07, 0x83, 0x12, 0x55,
	0x93, 0x0a, 0x07, 0xbf, 0x23, 0xc0, 0xf3, 0x6f, 0x01, 0x7f, 0x0c, 0x35, 0xb5, 0xd5, 0xea, 0xf4,
	0xdb, 0xc6, 0x7d, 0x3b, 0x94, 0x61, 0x77, 0x21, 0x6b, 0xba, 0xbf, 0x3a, 0xc8, 0x0b, 0xeb, 0x1a,
	0x39, 0x25, 0xc7, 0x9d, 0x2e, 0xa1, 0x52, 0x1e, 0x3f, 0x85, 0x9d, 0x85, 0x9c, 0x78, 0x7f, 0xaf,
	0xe8, 0xe5, 0x95, 0x9c, 0x7b, 0x7b, 0x25, 0xe7, 0xde, 0x5d, 0xc9, 0xe8, 0xe7, 0x89, 0x8c, 0xfe,
	0x9c, 0xc8, 0xe8, 0xaf, 0x89, 0x8c, 0x2e, 0x27, 0x32, 0xfa, 0x7b, 0x22, 0xa3, 0x7f, 0x26, 0x72,
	0xee, 0xdd, 0x44, 0x46, 0xbf, 0x5c, 0xcb, 0xb9, 0xcb, 0x6b, 0x39, 0xf7, 0xf6, 0x5a, 0xce, 0x7d,
	0x5b, 0x0d, 0x47, 0x9e, 0x3f, 0x54, 0xec, 0xa1, 0x1b, 0x0d, 0x1a, 0x33, 0x7f, 0xd9, 0x2f, 0xf8,
	0xe7, 0xeb, 0x65, 0xf1, 0x8b, 0xf6, 0xd9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x98, 0xd2, 0x52,
	0x96, 0xcd, 0x07, 0x00, 0x00,
}

func (x UserState) String() string {
	s, ok := UserState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RoleType) String() string {
	s, ok := RoleType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NamespaceActionGroup) String() string {
	s, ok := NamespaceActionGroup_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AccountActionGroup) String() string {
	s, ok := AccountActionGroup_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *UserSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserSpec)
	if !ok {
		that2, ok := that.(UserSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return false
		}
	}
	return true
}
func (this *UserNamespacePermissions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserNamespacePermissions)
	if !ok {
		that2, ok := that.(UserNamespacePermissions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if len(this.ActionGroups) != len(that1.ActionGroups) {
		return false
	}
	for i := range this.ActionGroups {
		if this.ActionGroups[i] != that1.ActionGroups[i] {
			return false
		}
	}
	return true
}
func (this *Invitation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Invitation)
	if !ok {
		that2, ok := that.(Invitation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uri != that1.Uri {
		return false
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.ExpiryTime.Equal(that1.ExpiryTime) {
		return false
	}
	return true
}
func (this *User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*User)
	if !ok {
		that2, ok := that.(User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.RequestId != that1.RequestId {
		return false
	}
	if !this.Invitation.Equal(that1.Invitation) {
		return false
	}
	if !this.CreatedTime.Equal(that1.CreatedTime) {
		return false
	}
	if !this.LastModifiedTime.Equal(that1.LastModifiedTime) {
		return false
	}
	return true
}
func (this *NamespaceRoleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRoleSpec)
	if !ok {
		that2, ok := that.(NamespaceRoleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ActionGroup != that1.ActionGroup {
		return false
	}
	return true
}
func (this *AccountRoleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountRoleSpec)
	if !ok {
		that2, ok := that.(AccountRoleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActionGroup != that1.ActionGroup {
		return false
	}
	return true
}
func (this *RoleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleSpec)
	if !ok {
		that2, ok := that.(RoleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccountRole.Equal(that1.AccountRole) {
		return false
	}
	if len(this.NamespaceRole) != len(that1.NamespaceRole) {
		return false
	}
	for i := range this.NamespaceRole {
		if !this.NamespaceRole[i].Equal(that1.NamespaceRole[i]) {
			return false
		}
	}
	return true
}
func (this *Role) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Role)
	if !ok {
		that2, ok := that.(Role)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *UserSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.UserSpec{")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Roles: "+fmt.Sprintf("%#v", this.Roles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserNamespacePermissions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.UserNamespacePermissions{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ActionGroups: "+fmt.Sprintf("%#v", this.ActionGroups)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Invitation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&auth.Invitation{")
	s = append(s, "Uri: "+fmt.Sprintf("%#v", this.Uri)+",\n")
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.ExpiryTime != nil {
		s = append(s, "ExpiryTime: "+fmt.Sprintf("%#v", this.ExpiryTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *User) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&auth.User{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "RequestId: "+fmt.Sprintf("%#v", this.RequestId)+",\n")
	if this.Invitation != nil {
		s = append(s, "Invitation: "+fmt.Sprintf("%#v", this.Invitation)+",\n")
	}
	if this.CreatedTime != nil {
		s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	}
	if this.LastModifiedTime != nil {
		s = append(s, "LastModifiedTime: "+fmt.Sprintf("%#v", this.LastModifiedTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRoleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.NamespaceRoleSpec{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ActionGroup: "+fmt.Sprintf("%#v", this.ActionGroup)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountRoleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&auth.AccountRoleSpec{")
	s = append(s, "ActionGroup: "+fmt.Sprintf("%#v", this.ActionGroup)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&auth.RoleSpec{")
	if this.AccountRole != nil {
		s = append(s, "AccountRole: "+fmt.Sprintf("%#v", this.AccountRole)+",\n")
	}
	if this.NamespaceRole != nil {
		s = append(s, "NamespaceRole: "+fmt.Sprintf("%#v", this.NamespaceRole)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Role) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&auth.Role{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *UserSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserNamespacePermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserNamespacePermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserNamespacePermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActionGroups) > 0 {
		dAtA2 := make([]byte, len(m.ActionGroups)*10)
		var j1 int
		for _, num := range m.ActionGroups {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMessage(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Invitation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Invitation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Invitation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryTime != nil {
		{
			size, err := m.ExpiryTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModifiedTime != nil {
		{
			size, err := m.LastModifiedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Invitation != nil {
		{
			size, err := m.Invitation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.State != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceRoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRoleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceRoleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionGroup != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionGroup))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountRoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRoleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRoleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionGroup != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ActionGroup))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NamespaceRole) > 0 {
		for iNdEx := len(m.NamespaceRole) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRole[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AccountRole != nil {
		{
			size, err := m.AccountRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Role) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *UserNamespacePermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.ActionGroups) > 0 {
		l = 0
		for _, e := range m.ActionGroups {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	return n
}

func (m *Invitation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ExpiryTime != nil {
		l = m.ExpiryTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessage(uint64(m.State))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Invitation != nil {
		l = m.Invitation.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.LastModifiedTime != nil {
		l = m.LastModifiedTime.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *NamespaceRoleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ActionGroup != 0 {
		n += 1 + sovMessage(uint64(m.ActionGroup))
	}
	return n
}

func (m *AccountRoleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionGroup != 0 {
		n += 1 + sovMessage(uint64(m.ActionGroup))
	}
	return n
}

func (m *RoleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountRole != nil {
		l = m.AccountRole.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.NamespaceRole) > 0 {
		for _, e := range m.NamespaceRole {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *Role) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UserSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserSpec{`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Roles:` + fmt.Sprintf("%v", this.Roles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserNamespacePermissions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserNamespacePermissions{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`ActionGroups:` + fmt.Sprintf("%v", this.ActionGroups) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Invitation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Invitation{`,
		`Uri:` + fmt.Sprintf("%v", this.Uri) + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`ExpiryTime:` + strings.Replace(fmt.Sprintf("%v", this.ExpiryTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *User) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&User{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "UserSpec", "UserSpec", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`RequestId:` + fmt.Sprintf("%v", this.RequestId) + `,`,
		`Invitation:` + strings.Replace(this.Invitation.String(), "Invitation", "Invitation", 1) + `,`,
		`CreatedTime:` + strings.Replace(fmt.Sprintf("%v", this.CreatedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastModifiedTime:` + strings.Replace(fmt.Sprintf("%v", this.LastModifiedTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRoleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRoleSpec{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ActionGroup:` + fmt.Sprintf("%v", this.ActionGroup) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountRoleSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccountRoleSpec{`,
		`ActionGroup:` + fmt.Sprintf("%v", this.ActionGroup) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoleSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRole := "[]*NamespaceRoleSpec{"
	for _, f := range this.NamespaceRole {
		repeatedStringForNamespaceRole += strings.Replace(f.String(), "NamespaceRoleSpec", "NamespaceRoleSpec", 1) + ","
	}
	repeatedStringForNamespaceRole += "}"
	s := strings.Join([]string{`&RoleSpec{`,
		`AccountRole:` + strings.Replace(this.AccountRole.String(), "AccountRoleSpec", "AccountRoleSpec", 1) + `,`,
		`NamespaceRole:` + repeatedStringForNamespaceRole + `,`,
		`}`,
	}, "")
	return s
}
func (this *Role) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Role{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "RoleSpec", "RoleSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UserSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserNamespacePermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserNamespacePermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserNamespacePermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v NamespaceActionGroup
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NamespaceActionGroup(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActionGroups = append(m.ActionGroups, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ActionGroups) == 0 {
					m.ActionGroups = make([]NamespaceActionGroup, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NamespaceActionGroup
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NamespaceActionGroup(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActionGroups = append(m.ActionGroups, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionGroups", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Invitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryTime == nil {
				m.ExpiryTime = &types.Timestamp{}
			}
			if err := m.ExpiryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &UserSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= UserState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invitation == nil {
				m.Invitation = &Invitation{}
			}
			if err := m.Invitation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifiedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifiedTime == nil {
				m.LastModifiedTime = &types.Timestamp{}
			}
			if err := m.LastModifiedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionGroup", wireType)
			}
			m.ActionGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionGroup |= NamespaceActionGroup(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountRoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionGroup", wireType)
			}
			m.ActionGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionGroup |= AccountActionGroup(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountRole == nil {
				m.AccountRole = &AccountRoleSpec{}
			}
			if err := m.AccountRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRole = append(m.NamespaceRole, &NamespaceRoleSpec{})
			if err := m.NamespaceRole[len(m.NamespaceRole)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RoleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &RoleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
